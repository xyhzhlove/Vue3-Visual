import {
  __export
} from "./chunk-PZ5AY32C.js";

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/index.js
var shape_exports = {};
__export(shape_exports, {
  Circle: () => Circle,
  Edge: () => Edge2,
  Ellipse: () => Ellipse2,
  HTML: () => HTML,
  Image: () => Image,
  Path: () => Path2,
  Polygon: () => Polygon,
  Polyline: () => Polyline2,
  Rect: () => Rect,
  TextBlock: () => TextBlock
});

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/polyfill/index.js
if (typeof window === "object" && window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = Array.prototype.forEach;
}
if (typeof window !== "undefined") {
  ;
  (function(arr) {
    arr.forEach((item) => {
      if (Object.prototype.hasOwnProperty.call(item, "append")) {
        return;
      }
      Object.defineProperty(item, "append", {
        configurable: true,
        enumerable: true,
        writable: true,
        value(...args) {
          const docFrag = document.createDocumentFragment();
          args.forEach((arg) => {
            const isNode = arg instanceof Node;
            docFrag.appendChild(isNode ? arg : document.createTextNode(String(arg)));
          });
          this.appendChild(docFrag);
        }
      });
    });
  })([Element.prototype, Document.prototype, DocumentFragment.prototype]);
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/common/disposable.js
var Disposable = class {
  get disposed() {
    return this._disposed === true;
  }
  dispose() {
    this._disposed = true;
  }
};
(function(Disposable2) {
  function dispose() {
    return (target, methodName, descriptor) => {
      const raw2 = descriptor.value;
      const proto = target.__proto__;
      descriptor.value = function(...args) {
        if (this.disposed) {
          return;
        }
        raw2.call(this, ...args);
        proto.dispose.call(this);
      };
    };
  }
  Disposable2.dispose = dispose;
})(Disposable || (Disposable = {}));
var DisposableDelegate = class {
  /**
   * Construct a new disposable delegate.
   *
   * @param callback - The callback function to invoke on dispose.
   */
  constructor(callback) {
    this.callback = callback;
  }
  /**
   * Test whether the delegate has been disposed.
   */
  get disposed() {
    return !this.callback;
  }
  /**
   * Dispose of the delegate and invoke the callback function.
   */
  dispose() {
    if (!this.callback) {
      return;
    }
    const callback = this.callback;
    this.callback = null;
    callback();
  }
};
var DisposableSet = class {
  constructor() {
    this.isDisposed = false;
    this.items = /* @__PURE__ */ new Set();
  }
  /**
   * Test whether the set has been disposed.
   */
  get disposed() {
    return this.isDisposed;
  }
  /**
   * Dispose of the set and the items it contains.
   *
   * #### Notes
   * Items are disposed in the order they are added to the set.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.isDisposed = true;
    this.items.forEach((item) => {
      item.dispose();
    });
    this.items.clear();
  }
  /**
   * Test whether the set contains a specific item.
   *
   * @param item - The item of interest.
   *
   * @returns `true` if the set contains the item, `false` otherwise.
   */
  contains(item) {
    return this.items.has(item);
  }
  /**
   * Add a disposable item to the set.
   *
   * @param item - The item to add to the set.
   *
   * #### Notes
   * If the item is already contained in the set, this is a no-op.
   */
  add(item) {
    this.items.add(item);
  }
  /**
   * Remove a disposable item from the set.
   *
   * @param item - The item to remove from the set.
   *
   * #### Notes
   * If the item is not contained in the set, this is a no-op.
   */
  remove(item) {
    this.items.delete(item);
  }
  /**
   * Remove all items from the set.
   */
  clear() {
    this.items.clear();
  }
};
(function(DisposableSet2) {
  function from(items) {
    const set2 = new DisposableSet2();
    items.forEach((item) => {
      set2.add(item);
    });
    return set2;
  }
  DisposableSet2.from = from;
})(DisposableSet || (DisposableSet = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/function/main.js
var main_exports = {};
__export(main_exports, {
  apply: () => apply2,
  call: () => call,
  debounce: () => debounce_default,
  isAsync: () => isAsync,
  isAsyncLike: () => isAsyncLike,
  throttle: () => throttle_default,
  toAsyncBoolean: () => toAsyncBoolean,
  toDeferredBoolean: () => toDeferredBoolean
});

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result2;
}
var getRawTag_default = getRawTag;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseToNumber.js
var NAN = 0 / 0;
function baseToNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  return +value;
}
var baseToNumber_default = baseToNumber;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee2) {
  var index2 = -1, length2 = array == null ? 0 : array.length, result2 = Array(length2);
  while (++index2 < length2) {
    result2[index2] = iteratee2(array[index2], index2, array);
  }
  return result2;
}
var arrayMap_default = arrayMap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
}
var baseToString_default = baseToString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createMathOperation.js
function createMathOperation(operator, defaultValue) {
  return function(value, other) {
    var result2;
    if (value === void 0 && other === void 0) {
      return defaultValue;
    }
    if (value !== void 0) {
      result2 = value;
    }
    if (other !== void 0) {
      if (result2 === void 0) {
        return other;
      }
      if (typeof value == "string" || typeof other == "string") {
        value = baseToString_default(value);
        other = baseToString_default(other);
      } else {
        value = baseToNumber_default(value);
        other = baseToNumber_default(other);
      }
      result2 = operator(value, other);
    }
    return result2;
  };
}
var createMathOperation_default = createMathOperation;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/add.js
var add = createMathOperation_default(function(augend, addend) {
  return augend + addend;
}, 0);
var add_default = add;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var trimmedEndIndex_default = trimmedEndIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var baseTrim_default = baseTrim;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toNumber.js
var NAN2 = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN2;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN2 : +value;
}
var toNumber_default = toNumber;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result2 = toFinite_default(value), remainder = result2 % 1;
  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
}
var toInteger_default = toInteger;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/after.js
var FUNC_ERROR_TEXT = "Expected a function";
function after(n, func) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger_default(n);
  return function() {
    if (--n < 1) {
      return func.apply(this, arguments);
    }
  };
}
var after_default = after;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSetData.js
var baseSetData = !metaMap_default ? identity_default : function(func, data2) {
  metaMap_default.set(func, data2);
  return func;
};
var baseSetData_default = baseSetData;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
}();
var baseCreate_default = baseCreate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createCtor.js
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate_default(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject_default(result2) ? result2 : thisBinding;
  };
}
var createCtor_default = createCtor;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBind.js
var WRAP_BIND_FLAG = 1;
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor_default(func);
  function wrapper() {
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var createBind_default = createBind;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_composeArgs.js
var nativeMax = Math.max;
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
var composeArgs_default = composeArgs;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_composeArgsRight.js
var nativeMax2 = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset3 = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset3 + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset3 + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
var composeArgsRight_default = composeArgsRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_countHolders.js
function countHolders(array, placeholder) {
  var length2 = array.length, result2 = 0;
  while (length2--) {
    if (array[length2] === placeholder) {
      ++result2;
    }
  }
  return result2;
}
var countHolders_default = countHolders;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/noop.js
function noop() {
}
var noop_default = noop;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getData.js
var getData = !metaMap_default ? noop_default : function(func) {
  return metaMap_default.get(func);
};
var getData_default = getData;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getFuncName.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function getFuncName(func) {
  var result2 = func.name + "", array = realNames_default[result2], length2 = hasOwnProperty3.call(realNames_default, result2) ? array.length : 0;
  while (length2--) {
    var data2 = array[length2], otherFunc = data2.func;
    if (otherFunc == null || otherFunc == func) {
      return data2.name;
    }
  }
  return result2;
}
var getFuncName_default = getFuncName;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index2 = -1, length2 = source.length;
  array || (array = Array(length2));
  while (++index2 < length2) {
    array[index2] = source[index2];
  }
  return array;
}
var copyArray_default = copyArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result2 = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result2.__actions__ = copyArray_default(wrapper.__actions__);
  result2.__index__ = wrapper.__index__;
  result2.__values__ = wrapper.__values__;
  return result2;
}
var wrapperClone_default = wrapperClone;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/wrapperLodash.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function lodash(value) {
  if (isObjectLike_default(value) && !isArray_default(value) && !(value instanceof LazyWrapper_default)) {
    if (value instanceof LodashWrapper_default) {
      return value;
    }
    if (hasOwnProperty4.call(value, "__wrapped__")) {
      return wrapperClone_default(value);
    }
  }
  return new LodashWrapper_default(value);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isLaziable.js
function isLaziable(func) {
  var funcName = getFuncName_default(func), other = wrapperLodash_default[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data2 = getData_default(other);
  return !!data2 && func === data2[0];
}
var isLaziable_default = isLaziable;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setData.js
var setData = shortOut_default(baseSetData_default);
var setData_default = setData;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getWrapDetails.js
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
var reSplitDetails = /,? & /;
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}
var getWrapDetails_default = getWrapDetails;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_insertWrapDetails.js
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
  var length2 = details.length;
  if (!length2) {
    return source;
  }
  var lastIndex = length2 - 1;
  details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length2 > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var insertWrapDetails_default = insertWrapDetails;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee2) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (iteratee2(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default = arrayEach;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array, value, fromIndex) {
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value) {
  var length2 = array == null ? 0 : array.length;
  return !!length2 && baseIndexOf_default(array, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_updateWrapDetails.js
var WRAP_BIND_FLAG2 = 1;
var WRAP_BIND_KEY_FLAG = 2;
var WRAP_CURRY_FLAG = 8;
var WRAP_CURRY_RIGHT_FLAG = 16;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
var WRAP_FLIP_FLAG = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG],
  ["bind", WRAP_BIND_FLAG2],
  ["bindKey", WRAP_BIND_KEY_FLAG],
  ["curry", WRAP_CURRY_FLAG],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG],
  ["flip", WRAP_FLIP_FLAG],
  ["partial", WRAP_PARTIAL_FLAG],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
  ["rearg", WRAP_REARG_FLAG]
];
function updateWrapDetails(details, bitmask) {
  arrayEach_default(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes_default(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
var updateWrapDetails_default = updateWrapDetails;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setWrapToString.js
function setWrapToString(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString_default(wrapper, insertWrapDetails_default(source, updateWrapDetails_default(getWrapDetails_default(source), bitmask)));
}
var setWrapToString_default = setWrapToString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createRecurry.js
var WRAP_BIND_FLAG3 = 1;
var WRAP_BIND_KEY_FLAG2 = 2;
var WRAP_CURRY_BOUND_FLAG = 4;
var WRAP_CURRY_FLAG2 = 8;
var WRAP_PARTIAL_FLAG2 = 32;
var WRAP_PARTIAL_RIGHT_FLAG2 = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG2, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG2 : WRAP_PARTIAL_RIGHT_FLAG2;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG2 : WRAP_PARTIAL_FLAG2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG3 | WRAP_BIND_KEY_FLAG2);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary2,
    arity
  ];
  var result2 = wrapFunc.apply(void 0, newData);
  if (isLaziable_default(func)) {
    setData_default(result2, newData);
  }
  result2.placeholder = placeholder;
  return setWrapToString_default(result2, func, bitmask);
}
var createRecurry_default = createRecurry;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getHolder.js
function getHolder(func) {
  var object = func;
  return object.placeholder;
}
var getHolder_default = getHolder;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var isIndex_default = isIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_reorder.js
var nativeMin = Math.min;
function reorder(array, indexes) {
  var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray_default(array);
  while (length2--) {
    var index2 = indexes[length2];
    array[length2] = isIndex_default(index2, arrLength) ? oldArray[index2] : void 0;
  }
  return array;
}
var reorder_default = reorder;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_replaceHolders.js
var PLACEHOLDER = "__lodash_placeholder__";
function replaceHolders(array, placeholder) {
  var index2 = -1, length2 = array.length, resIndex = 0, result2 = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index2] = PLACEHOLDER;
      result2[resIndex++] = index2;
    }
  }
  return result2;
}
var replaceHolders_default = replaceHolders;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createHybrid.js
var WRAP_BIND_FLAG4 = 1;
var WRAP_BIND_KEY_FLAG3 = 2;
var WRAP_CURRY_FLAG3 = 8;
var WRAP_CURRY_RIGHT_FLAG2 = 16;
var WRAP_ARY_FLAG2 = 128;
var WRAP_FLIP_FLAG2 = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG2, isBind = bitmask & WRAP_BIND_FLAG4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG3, isCurried = bitmask & (WRAP_CURRY_FLAG3 | WRAP_CURRY_RIGHT_FLAG2), isFlip = bitmask & WRAP_FLIP_FLAG2, Ctor = isBindKey ? void 0 : createCtor_default(func);
  function wrapper() {
    var length2 = arguments.length, args = Array(length2), index2 = length2;
    while (index2--) {
      args[index2] = arguments[index2];
    }
    if (isCurried) {
      var placeholder = getHolder_default(wrapper), holdersCount = countHolders_default(args, placeholder);
    }
    if (partials) {
      args = composeArgs_default(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight_default(args, partialsRight, holdersRight, isCurried);
    }
    length2 -= holdersCount;
    if (isCurried && length2 < arity) {
      var newHolders = replaceHolders_default(args, placeholder);
      return createRecurry_default(
        func,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary2,
        arity - length2
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length2 = args.length;
    if (argPos) {
      args = reorder_default(args, argPos);
    } else if (isFlip && length2 > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length2) {
      args.length = ary2;
    }
    if (this && this !== root_default && this instanceof wrapper) {
      fn = Ctor || createCtor_default(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var createHybrid_default = createHybrid;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createCurry.js
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor_default(func);
  function wrapper() {
    var length2 = arguments.length, args = Array(length2), index2 = length2, placeholder = getHolder_default(wrapper);
    while (index2--) {
      args[index2] = arguments[index2];
    }
    var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders_default(args, placeholder);
    length2 -= holders.length;
    if (length2 < arity) {
      return createRecurry_default(
        func,
        bitmask,
        createHybrid_default,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length2
      );
    }
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return apply_default(fn, this, args);
  }
  return wrapper;
}
var createCurry_default = createCurry;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createPartial.js
var WRAP_BIND_FLAG5 = 1;
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG5, Ctor = createCtor_default(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply_default(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var createPartial_default = createPartial;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mergeData.js
var PLACEHOLDER2 = "__lodash_placeholder__";
var WRAP_BIND_FLAG6 = 1;
var WRAP_BIND_KEY_FLAG4 = 2;
var WRAP_CURRY_BOUND_FLAG2 = 4;
var WRAP_CURRY_FLAG4 = 8;
var WRAP_ARY_FLAG3 = 128;
var WRAP_REARG_FLAG2 = 256;
var nativeMin2 = Math.min;
function mergeData(data2, source) {
  var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG6 | WRAP_BIND_KEY_FLAG4 | WRAP_ARY_FLAG3);
  var isCombo = srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_CURRY_FLAG4 || srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_REARG_FLAG2 && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG3 | WRAP_REARG_FLAG2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG4;
  if (!(isCommon || isCombo)) {
    return data2;
  }
  if (srcBitmask & WRAP_BIND_FLAG6) {
    data2[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG6 ? 0 : WRAP_CURRY_BOUND_FLAG2;
  }
  var value = source[3];
  if (value) {
    var partials = data2[3];
    data2[3] = partials ? composeArgs_default(partials, value, source[4]) : value;
    data2[4] = partials ? replaceHolders_default(data2[3], PLACEHOLDER2) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data2[5];
    data2[5] = partials ? composeArgsRight_default(partials, value, source[6]) : value;
    data2[6] = partials ? replaceHolders_default(data2[5], PLACEHOLDER2) : source[6];
  }
  value = source[7];
  if (value) {
    data2[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG3) {
    data2[8] = data2[8] == null ? source[8] : nativeMin2(data2[8], source[8]);
  }
  if (data2[9] == null) {
    data2[9] = source[9];
  }
  data2[0] = source[0];
  data2[1] = newBitmask;
  return data2;
}
var mergeData_default = mergeData;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createWrap.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var WRAP_BIND_FLAG7 = 1;
var WRAP_BIND_KEY_FLAG5 = 2;
var WRAP_CURRY_FLAG5 = 8;
var WRAP_CURRY_RIGHT_FLAG3 = 16;
var WRAP_PARTIAL_FLAG3 = 32;
var WRAP_PARTIAL_RIGHT_FLAG3 = 64;
var nativeMax3 = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG5;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  var length2 = partials ? partials.length : 0;
  if (!length2) {
    bitmask &= ~(WRAP_PARTIAL_FLAG3 | WRAP_PARTIAL_RIGHT_FLAG3);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax3(toInteger_default(ary2), 0);
  arity = arity === void 0 ? arity : toInteger_default(arity);
  length2 -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG3) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data2 = isBindKey ? void 0 : getData_default(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary2,
    arity
  ];
  if (data2) {
    mergeData_default(newData, data2);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax3(newData[9] - length2, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3)) {
    bitmask &= ~(WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG7) {
    var result2 = createBind_default(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG5 || bitmask == WRAP_CURRY_RIGHT_FLAG3) {
    result2 = createCurry_default(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG3 || bitmask == (WRAP_BIND_FLAG7 | WRAP_PARTIAL_FLAG3)) && !holders.length) {
    result2 = createPartial_default(func, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid_default.apply(void 0, newData);
  }
  var setter = data2 ? baseSetData_default : setData_default;
  return setWrapToString_default(setter(result2, newData), func, bitmask);
}
var createWrap_default = createWrap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/ary.js
var WRAP_ARY_FLAG4 = 128;
function ary(func, n, guard) {
  n = guard ? void 0 : n;
  n = func && n == null ? func.length : n;
  return createWrap_default(func, WRAP_ARY_FLAG4, void 0, void 0, void 0, void 0, n);
}
var ary_default = ary;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assignValue.js
var objectProto6 = Object.prototype;
var hasOwnProperty5 = objectProto6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty5.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length2 = props.length;
  while (++index2 < length2) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overRest.js
var nativeMax4 = Math.max;
function overRest(func, start, transform3) {
  start = nativeMax4(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length2 = nativeMax4(args.length - start, 0), array = Array(length2);
    while (++index2 < length2) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform3(array);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
var baseRest_default = baseRest;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index2, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index2, object.length) : type == "string" && index2 in object) {
    return eq_default(object[index2], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length2 < 3 ? void 0 : customizer;
      length2 = 1;
    }
    object = Object(object);
    while (++index2 < length2) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isPrototype.js
var objectProto7 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto7;
  return value === proto;
}
var isPrototype_default = isPrototype;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee2) {
  var index2 = -1, result2 = Array(n);
  while (++index2 < n) {
    result2[index2] = iteratee2(index2);
  }
  return result2;
}
var baseTimes_default = baseTimes;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArguments.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
var propertyIsEnumerable = objectProto8.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty6.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayLikeKeys.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes_default(value.length, String) : [], length2 = result2.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length2)))) {
      result2.push(key);
    }
  }
  return result2;
}
var arrayLikeKeys_default = arrayLikeKeys;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overArg.js
function overArg(func, transform3) {
  return function(arg) {
    return func(transform3(arg));
  };
}
var overArg_default = overArg;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result2 = [];
  for (var key in Object(object)) {
    if (hasOwnProperty8.call(object, key) && key != "constructor") {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeys_default = baseKeys;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/assign.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
var assign = createAssigner_default(function(object, source) {
  if (isPrototype_default(source) || isArrayLike_default(source)) {
    copyObject_default(source, keys_default(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty9.call(source, key)) {
      assignValue_default(object, key, source[key]);
    }
  }
});
var assign_default = assign;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result2 = [];
  if (object != null) {
    for (var key in Object(object)) {
      result2.push(key);
    }
  }
  return result2;
}
var nativeKeysIn_default = nativeKeysIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeysIn.js
var objectProto12 = Object.prototype;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result2 = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty10.call(object, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeysIn_default = baseKeysIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/assignIn.js
var assignIn = createAssigner_default(function(object, source) {
  copyObject_default(source, keysIn_default(source), object);
});
var assignIn_default = assignIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/assignInWith.js
var assignInWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keysIn_default(source), object, customizer);
});
var assignInWith_default = assignInWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/assignWith.js
var assignWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keys_default(source), object, customizer);
});
var assignWith_default = assignWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var hashDelete_default = hashDelete;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto13 = Object.prototype;
var hasOwnProperty11 = objectProto13.hasOwnProperty;
function hashGet(key) {
  var data2 = this.__data__;
  if (nativeCreate_default) {
    var result2 = data2[key];
    return result2 === HASH_UNDEFINED ? void 0 : result2;
  }
  return hasOwnProperty11.call(data2, key) ? data2[key] : void 0;
}
var hashGet_default = hashGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashHas.js
var objectProto14 = Object.prototype;
var hasOwnProperty12 = objectProto14.hasOwnProperty;
function hashHas(key) {
  var data2 = this.__data__;
  return nativeCreate_default ? data2[key] !== void 0 : hasOwnProperty12.call(data2, key);
}
var hashHas_default = hashHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq_default(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data2 = this.__data__, index2 = assocIndexOf_default(data2, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data2 = this.__data__, index2 = assocIndexOf_default(data2, key);
  return index2 < 0 ? void 0 : data2[index2][1];
}
var listCacheGet_default = listCacheGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data2 = this.__data__, index2 = assocIndexOf_default(data2, key);
  if (index2 < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index2][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js
var Map = getNative_default(root_default, "Map");
var Map_default = Map;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMapData.js
function getMapData(map2, key) {
  var data2 = map2.__data__;
  return isKeyable_default(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
var getMapData_default = getMapData;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result2 = getMapData_default(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var mapCacheDelete_default = mapCacheDelete;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data2 = getMapData_default(this, key), size2 = data2.size;
  data2.set(key, value);
  this.size += data2.size == size2 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  var memoized2 = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized2.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result2 = func.apply(this, args);
    memoized2.cache = cache.set(key, result2) || cache;
    return result2;
  };
  memoized2.cache = new (memoize.Cache || MapCache_default)();
  return memoized2;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result2 = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result2.cache;
  return result2;
}
var memoizeCapped_default = memoizeCapped;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result2 = [];
  if (string.charCodeAt(0) === 46) {
    result2.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result2;
});
var stringToPath_default = stringToPath;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY3 ? "-0" : result2;
}
var toKey_default = toKey;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGet.js
function baseGet(object, path2) {
  path2 = castPath_default(path2, object);
  var index2 = 0, length2 = path2.length;
  while (object != null && index2 < length2) {
    object = object[toKey_default(path2[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
var baseGet_default = baseGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/get.js
function get(object, path2, defaultValue) {
  var result2 = object == null ? void 0 : baseGet_default(object, path2);
  return result2 === void 0 ? defaultValue : result2;
}
var get_default = get;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAt.js
function baseAt(object, paths) {
  var index2 = -1, length2 = paths.length, result2 = Array(length2), skip = object == null;
  while (++index2 < length2) {
    result2[index2] = skip ? void 0 : get_default(object, paths[index2]);
  }
  return result2;
}
var baseAt_default = baseAt;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values2) {
  var index2 = -1, length2 = values2.length, offset3 = array.length;
  while (++index2 < length2) {
    array[offset3 + index2] = values2[index2];
  }
  return array;
}
var arrayPush_default = arrayPush;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth, predicate, isStrict, result2) {
  var index2 = -1, length2 = array.length;
  predicate || (predicate = isFlattenable_default);
  result2 || (result2 = []);
  while (++index2 < length2) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result2);
      } else {
        arrayPush_default(result2, value);
      }
    } else if (!isStrict) {
      result2[result2.length] = value;
    }
  }
  return result2;
}
var baseFlatten_default = baseFlatten;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatten.js
function flatten(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseFlatten_default(array, 1) : [];
}
var flatten_default = flatten;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default), func + "");
}
var flatRest_default = flatRest;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/at.js
var at = flatRest_default(baseAt_default);
var at_default = at;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto15 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty13 = objectProto15.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty13.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag2 = "[object Error]";
function isError(value) {
  if (!isObjectLike_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject_default(value);
}
var isError_default = isError;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/attempt.js
var attempt = baseRest_default(function(func, args) {
  try {
    return apply_default(func, void 0, args);
  } catch (e) {
    return isError_default(e) ? e : new Error(e);
  }
});
var attempt_default = attempt;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/before.js
var FUNC_ERROR_TEXT4 = "Expected a function";
function before(n, func) {
  var result2;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT4);
  }
  n = toInteger_default(n);
  return function() {
    if (--n > 0) {
      result2 = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = void 0;
    }
    return result2;
  };
}
var before_default = before;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/bind.js
var WRAP_BIND_FLAG8 = 1;
var WRAP_PARTIAL_FLAG4 = 32;
var bind = baseRest_default(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG8;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bind));
    bitmask |= WRAP_PARTIAL_FLAG4;
  }
  return createWrap_default(func, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
var bind_default = bind;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/bindAll.js
var bindAll = flatRest_default(function(object, methodNames) {
  arrayEach_default(methodNames, function(key) {
    key = toKey_default(key);
    baseAssignValue_default(object, key, bind_default(object[key], object));
  });
  return object;
});
var bindAll_default = bindAll;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/bindKey.js
var WRAP_BIND_FLAG9 = 1;
var WRAP_BIND_KEY_FLAG6 = 2;
var WRAP_PARTIAL_FLAG5 = 32;
var bindKey = baseRest_default(function(object, key, partials) {
  var bitmask = WRAP_BIND_FLAG9 | WRAP_BIND_KEY_FLAG6;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bindKey));
    bitmask |= WRAP_PARTIAL_FLAG5;
  }
  return createWrap_default(key, bitmask, object, partials, holders);
});
bindKey.placeholder = {};
var bindKey_default = bindKey;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start, end) {
  var index2 = -1, length2 = array.length;
  if (start < 0) {
    start = -start > length2 ? 0 : length2 + start;
  }
  end = end > length2 ? length2 : end;
  if (end < 0) {
    end += length2;
  }
  length2 = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result2 = Array(length2);
  while (++index2 < length2) {
    result2[index2] = array[index2 + start];
  }
  return result2;
}
var baseSlice_default = baseSlice;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castSlice.js
function castSlice(array, start, end) {
  var length2 = array.length;
  end = end === void 0 ? length2 : end;
  return !start && end >= length2 ? array : baseSlice_default(array, start, end);
}
var castSlice_default = castSlice;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var hasUnicode_default = hasUnicode;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string) {
  return string.split("");
}
var asciiToArray_default = asciiToArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stringToArray.js
function stringToArray(string) {
  return hasUnicode_default(string) ? unicodeToArray_default(string) : asciiToArray_default(string);
}
var stringToArray_default = stringToArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string) {
    string = toString_default(string);
    var strSymbols = hasUnicode_default(string) ? stringToArray_default(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/upperFirst.js
var upperFirst = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/capitalize.js
function capitalize(string) {
  return upperFirst_default(toString_default(string).toLowerCase());
}
var capitalize_default = capitalize;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array, iteratee2, accumulator, initAccum) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  if (initAccum && length2) {
    accumulator = array[++index2];
  }
  while (++index2 < length2) {
    accumulator = iteratee2(accumulator, array[index2], index2, array);
  }
  return accumulator;
}
var arrayReduce_default = arrayReduce;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "c",
  "": "D",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "N",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "Y",
  "": "y",
  "": "y",
  "": "Ae",
  "": "ae",
  "": "Th",
  "": "th",
  "": "ss",
  // Latin Extended-A block.
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "D",
  "": "D",
  "": "d",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "H",
  "": "H",
  "": "h",
  "": "h",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "J",
  "": "j",
  "": "K",
  "": "k",
  "": "k",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "R",
  "": "R",
  "": "R",
  "": "r",
  "": "r",
  "": "r",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "T",
  "": "T",
  "": "T",
  "": "t",
  "": "t",
  "": "t",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "W",
  "": "w",
  "": "Y",
  "": "y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "z",
  "": "z",
  "": "z",
  "": "IJ",
  "": "ij",
  "": "Oe",
  "": "oe",
  "": "'n",
  "": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsCombo2 = "[" + rsComboRange3 + "]";
var reComboMark = RegExp(rsCombo2, "g");
function deburr(string) {
  string = toString_default(string);
  return string && string.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_asciiWords.js
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var asciiWords_default = asciiWords;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hasUnicodeWord.js
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var hasUnicodeWord_default = hasUnicodeWord;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_unicodeWords.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange4 = "\\u0300-\\u036f";
var reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
var rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "[']";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo3 = "[" + rsComboRange4 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ3 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
var unicodeWords_default = unicodeWords;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/words.js
function words(string, pattern, guard) {
  string = toString_default(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord_default(string) ? unicodeWords_default(string) : asciiWords_default(string);
  }
  return string.match(pattern) || [];
}
var words_default = words;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createCompounder.js
var rsApos2 = "[']";
var reApos = RegExp(rsApos2, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce_default(words_default(deburr_default(string).replace(reApos, "")), callback, "");
  };
}
var createCompounder_default = createCompounder;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/camelCase.js
var camelCase = createCompounder_default(function(result2, word, index2) {
  word = word.toLowerCase();
  return result2 + (index2 ? capitalize_default(word) : word);
});
var camelCase_default = camelCase;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_default(value) ? value : [value];
}
var castArray_default = castArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createRound.js
var nativeIsFinite = root_default.isFinite;
var nativeMin3 = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber_default(number);
    precision = precision == null ? 0 : nativeMin3(toInteger_default(precision), 292);
    if (precision && nativeIsFinite(number)) {
      var pair = (toString_default(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString_default(value) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func(number);
  };
}
var createRound_default = createRound;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/ceil.js
var ceil = createRound_default("ceil");
var ceil_default = ceil;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/chain.js
function chain(value) {
  var result2 = wrapperLodash_default(value);
  result2.__chain__ = true;
  return result2;
}
var chain_default = chain;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/chunk.js
var nativeCeil = Math.ceil;
var nativeMax5 = Math.max;
function chunk(array, size2, guard) {
  if (guard ? isIterateeCall_default(array, size2, guard) : size2 === void 0) {
    size2 = 1;
  } else {
    size2 = nativeMax5(toInteger_default(size2), 0);
  }
  var length2 = array == null ? 0 : array.length;
  if (!length2 || size2 < 1) {
    return [];
  }
  var index2 = 0, resIndex = 0, result2 = Array(nativeCeil(length2 / size2));
  while (index2 < length2) {
    result2[resIndex++] = baseSlice_default(array, index2, index2 += size2);
  }
  return result2;
}
var chunk_default = chunk;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseClamp.js
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var baseClamp_default = baseClamp;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/clamp.js
function clamp(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber_default(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber_default(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp_default(toNumber_default(number), lower, upper);
}
var clamp_default = clamp;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data2 = this.__data__, result2 = data2["delete"](key);
  this.size = data2.size;
  return result2;
}
var stackDelete_default = stackDelete;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache_default) {
    var pairs = data2.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache_default(pairs);
  }
  data2.set(key, value);
  this.size = data2.size;
  return this;
}
var stackSet_default = stackSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data2 = this.__data__ = new ListCache_default(entries);
  this.size = data2.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer2 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
  buffer.copy(result2);
  return result2;
}
var cloneBuffer_default = cloneBuffer;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var arrayFilter_default = arrayFilter;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbols.js
var objectProto16 = Object.prototype;
var propertyIsEnumerable2 = objectProto16.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result2 = [];
  while (object) {
    arrayPush_default(result2, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result2;
};
var getSymbolsIn_default = getSymbolsIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object);
  return isArray_default(object) ? result2 : arrayPush_default(result2, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result2 = baseGetTag_default(value), Ctor = result2 == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result2;
  };
}
var getTag_default = getTag;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneArray.js
var objectProto17 = Object.prototype;
var hasOwnProperty14 = objectProto17.hasOwnProperty;
function initCloneArray(array) {
  var length2 = array.length, result2 = new array.constructor(length2);
  if (length2 && typeof array[0] == "string" && hasOwnProperty14.call(array, "index")) {
    result2.index = array.index;
    result2.input = array.input;
  }
  return result2;
}
var initCloneArray_default = initCloneArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result2).set(new Uint8Array_default(arrayBuffer));
  return result2;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result2.lastIndex = regexp.lastIndex;
  return result2;
}
var cloneRegExp_default = cloneRegExp;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag3 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag3] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result2 = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result2 = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result2);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
      result2 = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result2, value)) : copySymbols_default(value, baseAssign_default(result2, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result2 = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result2);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result2;
}
var baseClone_default = baseClone;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
}
var clone_default = clone;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/cloneDeepWith.js
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG4 = 4;
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG4, customizer);
}
var cloneDeepWith_default = cloneDeepWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/cloneWith.js
var CLONE_SYMBOLS_FLAG5 = 4;
function cloneWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_SYMBOLS_FLAG5, customizer);
}
var cloneWith_default = cloneWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/commit.js
function wrapperCommit() {
  return new LodashWrapper_default(this.value(), this.__chain__);
}
var commit_default = wrapperCommit;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/compact.js
function compact(array) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (value) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var compact_default = compact;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/concat.js
function concat() {
  var length2 = arguments.length;
  if (!length2) {
    return [];
  }
  var args = Array(length2 - 1), array = arguments[0], index2 = length2;
  while (index2--) {
    args[index2 - 1] = arguments[index2];
  }
  return arrayPush_default(isArray_default(array) ? copyArray_default(array) : [array], baseFlatten_default(args, 1));
}
var concat_default = concat;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index2 = -1, length2 = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index2 < length2) {
    this.add(values2[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
var cacheHas_default = cacheHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result2 = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result2 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result2 = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result2;
}
var equalArrays_default = equalArrays;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapToArray.js
function mapToArray(map2) {
  var index2 = -1, result2 = Array(map2.size);
  map2.forEach(function(value, key) {
    result2[++index2] = [key, value];
  });
  return result2;
}
var mapToArray_default = mapToArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToArray.js
function setToArray(set2) {
  var index2 = -1, result2 = Array(set2.size);
  set2.forEach(function(value) {
    result2[++index2] = value;
  });
  return result2;
}
var setToArray_default = setToArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag4 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other);
    case errorTag4:
      return object.name == other.name && object.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object == other + "";
    case mapTag6:
      var convert = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result2 = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result2;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto18 = Object.prototype;
var hasOwnProperty15 = objectProto18.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty15.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result2 = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result2 = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result2 && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result2 = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result2;
}
var equalObjects_default = equalObjects;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto19 = Object.prototype;
var hasOwnProperty16 = objectProto19.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty16.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty16.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index2--) {
    var data2 = matchData[index2];
    if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
      return false;
    }
  }
  while (++index2 < length2) {
    data2 = matchData[index2];
    var key = data2[0], objValue = object[key], srcValue = data2[1];
    if (noCustomizer && data2[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result2 = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result2 === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result2)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result2 = keys_default(object), length2 = result2.length;
  while (length2--) {
    var key = result2[length2], value = object[key];
    result2[length2] = [key, value, isStrictComparable_default(value)];
  }
  return result2;
}
var getMatchData_default = getMatchData;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hasPath.js
function hasPath(object, path2, hasFunc) {
  path2 = castPath_default(path2, object);
  var index2 = -1, length2 = path2.length, result2 = false;
  while (++index2 < length2) {
    var key = toKey_default(path2[index2]);
    if (!(result2 = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result2 || ++index2 != length2) {
    return result2;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength_default(length2) && isIndex_default(key, length2) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/hasIn.js
function hasIn(object, path2) {
  return object != null && hasPath_default(object, path2, baseHasIn_default);
}
var hasIn_default = hasIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path2, srcValue) {
  if (isKey_default(path2) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path2), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path2) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path2) {
  return function(object) {
    return baseGet_default(object, path2);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/property.js
function property(path2) {
  return isKey_default(path2) ? baseProperty_default(toKey_default(path2)) : basePropertyDeep_default(path2);
}
var property_default = property;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/cond.js
var FUNC_ERROR_TEXT5 = "Expected a function";
function cond(pairs) {
  var length2 = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee_default;
  pairs = !length2 ? [] : arrayMap_default(pairs, function(pair) {
    if (typeof pair[1] != "function") {
      throw new TypeError(FUNC_ERROR_TEXT5);
    }
    return [toIteratee(pair[0]), pair[1]];
  });
  return baseRest_default(function(args) {
    var index2 = -1;
    while (++index2 < length2) {
      var pair = pairs[index2];
      if (apply_default(pair[0], this, args)) {
        return apply_default(pair[1], this, args);
      }
    }
  });
}
var cond_default = cond;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseConformsTo.js
function baseConformsTo(object, source, props) {
  var length2 = props.length;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (length2--) {
    var key = props[length2], predicate = source[key], value = object[key];
    if (value === void 0 && !(key in object) || !predicate(value)) {
      return false;
    }
  }
  return true;
}
var baseConformsTo_default = baseConformsTo;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseConforms.js
function baseConforms(source) {
  var props = keys_default(source);
  return function(object) {
    return baseConformsTo_default(object, source, props);
  };
}
var baseConforms_default = baseConforms;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/conforms.js
var CLONE_DEEP_FLAG4 = 1;
function conforms(source) {
  return baseConforms_default(baseClone_default(source, CLONE_DEEP_FLAG4));
}
var conforms_default = conforms;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/conformsTo.js
function conformsTo(object, source) {
  return source == null || baseConformsTo_default(object, source, keys_default(source));
}
var conformsTo_default = conformsTo;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array, setter, iteratee2, accumulator) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    var value = array[index2];
    setter(accumulator, value, iteratee2(value), array);
  }
  return accumulator;
}
var arrayAggregator_default = arrayAggregator;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee2, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index2];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee2) {
  return object && baseFor_default(object, iteratee2, keys_default);
}
var baseForOwn_default = baseForOwn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length2) {
      if (iteratee2(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee2, accumulator) {
  baseEach_default(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee2(value), collection2);
  });
  return accumulator;
}
var baseAggregator_default = baseAggregator;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee2) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee2, 2), accumulator);
  };
}
var createAggregator_default = createAggregator;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/countBy.js
var objectProto20 = Object.prototype;
var hasOwnProperty17 = objectProto20.hasOwnProperty;
var countBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty17.call(result2, key)) {
    ++result2[key];
  } else {
    baseAssignValue_default(result2, key, 1);
  }
});
var countBy_default = countBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/create.js
function create(prototype, properties) {
  var result2 = baseCreate_default(prototype);
  return properties == null ? result2 : baseAssign_default(result2, properties);
}
var create_default = create;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/curry.js
var WRAP_CURRY_FLAG6 = 8;
function curry(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_FLAG6, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry.placeholder;
  return result2;
}
curry.placeholder = {};
var curry_default = curry;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/curryRight.js
var WRAP_CURRY_RIGHT_FLAG4 = 16;
function curryRight(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_RIGHT_FLAG4, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curryRight.placeholder;
  return result2;
}
curryRight.placeholder = {};
var curryRight_default = curryRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/now.js
var now = function() {
  return root_default.Date.now();
};
var now_default = now;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT6 = "Expected a function";
var nativeMax6 = Math.max;
var nativeMin4 = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT6);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax6(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result2 = func.apply(thisArg, args);
    return result2;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result2;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin4(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result2;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result2 : trailingEdge(now_default());
  }
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result2;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/defaultTo.js
function defaultTo(value, defaultValue) {
  return value == null || value !== value ? defaultValue : value;
}
var defaultTo_default = defaultTo;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/defaults.js
var objectProto21 = Object.prototype;
var hasOwnProperty18 = objectProto21.hasOwnProperty;
var defaults = baseRest_default(function(object, sources) {
  object = Object(object);
  var index2 = -1;
  var length2 = sources.length;
  var guard = length2 > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
    length2 = 1;
  }
  while (++index2 < length2) {
    var source = sources[index2];
    var props = keysIn_default(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];
      if (value === void 0 || eq_default(value, objectProto21[key]) && !hasOwnProperty18.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults_default = defaults;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_customDefaultsMerge.js
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject_default(objValue) && isObject_default(srcValue)) {
    stack.set(srcValue, objValue);
    baseMerge_default(objValue, srcValue, void 0, customDefaultsMerge, stack);
    stack["delete"](srcValue);
  }
  return objValue;
}
var customDefaultsMerge_default = customDefaultsMerge;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/mergeWith.js
var mergeWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  baseMerge_default(object, source, srcIndex, customizer);
});
var mergeWith_default = mergeWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/defaultsDeep.js
var defaultsDeep = baseRest_default(function(args) {
  args.push(void 0, customDefaultsMerge_default);
  return apply_default(mergeWith_default, void 0, args);
});
var defaultsDeep_default = defaultsDeep;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseDelay.js
var FUNC_ERROR_TEXT7 = "Expected a function";
function baseDelay(func, wait, args) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT7);
  }
  return setTimeout(function() {
    func.apply(void 0, args);
  }, wait);
}
var baseDelay_default = baseDelay;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/defer.js
var defer = baseRest_default(function(func, args) {
  return baseDelay_default(func, 1, args);
});
var defer_default = defer;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/delay.js
var delay = baseRest_default(function(func, wait, args) {
  return baseDelay_default(func, toNumber_default(wait) || 0, args);
});
var delay_default = delay;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array, value, comparator) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (comparator(value, array[index2])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseDifference.js
var LARGE_ARRAY_SIZE2 = 200;
function baseDifference(array, values2, iteratee2, comparator) {
  var index2 = -1, includes2 = arrayIncludes_default, isCommon = true, length2 = array.length, result2 = [], valuesLength = values2.length;
  if (!length2) {
    return result2;
  }
  if (iteratee2) {
    values2 = arrayMap_default(values2, baseUnary_default(iteratee2));
  }
  if (comparator) {
    includes2 = arrayIncludesWith_default;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE2) {
    includes2 = cacheHas_default;
    isCommon = false;
    values2 = new SetCache_default(values2);
  }
  outer:
    while (++index2 < length2) {
      var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed) {
            continue outer;
          }
        }
        result2.push(value);
      } else if (!includes2(values2, computed, comparator)) {
        result2.push(value);
      }
    }
  return result2;
}
var baseDifference_default = baseDifference;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/difference.js
var difference = baseRest_default(function(array, values2) {
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true)) : [];
});
var difference_default = difference;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/last.js
function last(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? array[length2 - 1] : void 0;
}
var last_default = last;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/differenceBy.js
var differenceBy = baseRest_default(function(array, values2) {
  var iteratee2 = last_default(values2);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2)) : [];
});
var differenceBy_default = differenceBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/differenceWith.js
var differenceWith = baseRest_default(function(array, values2) {
  var comparator = last_default(values2);
  if (isArrayLikeObject_default(comparator)) {
    comparator = void 0;
  }
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), void 0, comparator) : [];
});
var differenceWith_default = differenceWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/divide.js
var divide = createMathOperation_default(function(dividend, divisor) {
  return dividend / divisor;
}, 1);
var divide_default = divide;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/drop.js
function drop(array, n, guard) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array, n < 0 ? 0 : n, length2);
}
var drop_default = drop;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/dropRight.js
function dropRight(array, n, guard) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length2 - n;
  return baseSlice_default(array, 0, n < 0 ? 0 : n);
}
var dropRight_default = dropRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseWhile.js
function baseWhile(array, predicate, isDrop, fromRight) {
  var length2 = array.length, index2 = fromRight ? length2 : -1;
  while ((fromRight ? index2-- : ++index2 < length2) && predicate(array[index2], index2, array)) {
  }
  return isDrop ? baseSlice_default(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length2) : baseSlice_default(array, fromRight ? index2 + 1 : 0, fromRight ? length2 : index2);
}
var baseWhile_default = baseWhile;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/dropRightWhile.js
function dropRightWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true, true) : [];
}
var dropRightWhile_default = dropRightWhile;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/dropWhile.js
function dropWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true) : [];
}
var dropWhile_default = dropWhile;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castFunction.js
function castFunction(value) {
  return typeof value == "function" ? value : identity_default;
}
var castFunction_default = castFunction;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/forEach.js
function forEach(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEach_default = forEach;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayEachRight.js
function arrayEachRight(array, iteratee2) {
  var length2 = array == null ? 0 : array.length;
  while (length2--) {
    if (iteratee2(array[length2], length2, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEachRight_default = arrayEachRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseForRight.js
var baseForRight = createBaseFor_default(true);
var baseForRight_default = baseForRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseForOwnRight.js
function baseForOwnRight(object, iteratee2) {
  return object && baseForRight_default(object, iteratee2, keys_default);
}
var baseForOwnRight_default = baseForOwnRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseEachRight.js
var baseEachRight = createBaseEach_default(baseForOwnRight_default, true);
var baseEachRight_default = baseEachRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/forEachRight.js
function forEachRight(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEachRight_default : baseEachRight_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEachRight_default = forEachRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/endsWith.js
function endsWith(string, target, position2) {
  string = toString_default(string);
  target = baseToString_default(target);
  var length2 = string.length;
  position2 = position2 === void 0 ? length2 : baseClamp_default(toInteger_default(position2), 0, length2);
  var end = position2;
  position2 -= target.length;
  return position2 >= 0 && string.slice(position2, end) == target;
}
var endsWith_default = endsWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseToPairs.js
function baseToPairs(object, props) {
  return arrayMap_default(props, function(key) {
    return [key, object[key]];
  });
}
var baseToPairs_default = baseToPairs;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToPairs.js
function setToPairs(set2) {
  var index2 = -1, result2 = Array(set2.size);
  set2.forEach(function(value) {
    result2[++index2] = [value, value];
  });
  return result2;
}
var setToPairs_default = setToPairs;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createToPairs.js
var mapTag7 = "[object Map]";
var setTag7 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag_default(object);
    if (tag == mapTag7) {
      return mapToArray_default(object);
    }
    if (tag == setTag7) {
      return setToPairs_default(object);
    }
    return baseToPairs_default(object, keysFunc(object));
  };
}
var createToPairs_default = createToPairs;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toPairs.js
var toPairs = createToPairs_default(keys_default);
var toPairs_default = toPairs;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toPairsIn.js
var toPairsIn = createToPairs_default(keysIn_default);
var toPairsIn_default = toPairsIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_escapeHtmlChar.js
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
var escapeHtmlChar_default = escapeHtmlChar;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/escape.js
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape(string) {
  string = toString_default(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar_default) : string;
}
var escape_default = escape;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string) {
  string = toString_default(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
}
var escapeRegExp_default = escapeRegExp;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayEvery.js
function arrayEvery(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (!predicate(array[index2], index2, array)) {
      return false;
    }
  }
  return true;
}
var arrayEvery_default = arrayEvery;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseEvery.js
function baseEvery(collection, predicate) {
  var result2 = true;
  baseEach_default(collection, function(value, index2, collection2) {
    result2 = !!predicate(value, index2, collection2);
    return result2;
  });
  return result2;
}
var baseEvery_default = baseEvery;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/every.js
function every(collection, predicate, guard) {
  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var every_default = every;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toLength.js
var MAX_ARRAY_LENGTH2 = 4294967295;
function toLength(value) {
  return value ? baseClamp_default(toInteger_default(value), 0, MAX_ARRAY_LENGTH2) : 0;
}
var toLength_default = toLength;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFill.js
function baseFill(array, value, start, end) {
  var length2 = array.length;
  start = toInteger_default(start);
  if (start < 0) {
    start = -start > length2 ? 0 : length2 + start;
  }
  end = end === void 0 || end > length2 ? length2 : toInteger_default(end);
  if (end < 0) {
    end += length2;
  }
  end = start > end ? 0 : toLength_default(end);
  while (start < end) {
    array[start++] = value;
  }
  return array;
}
var baseFill_default = baseFill;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/fill.js
function fill(array, value, start, end) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return [];
  }
  if (start && typeof start != "number" && isIterateeCall_default(array, value, start)) {
    start = 0;
    end = length2;
  }
  return baseFill_default(array, value, start, end);
}
var fill_default = fill;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result2 = [];
  baseEach_default(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result2.push(value);
    }
  });
  return result2;
}
var baseFilter_default = baseFilter;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/filter.js
function filter(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default = filter;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createFind.js
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_default(collection)) {
      var iteratee2 = baseIteratee_default(predicate, 3);
      collection = keys_default(collection);
      predicate = function(key) {
        return iteratee2(iterable[key], key, iterable);
      };
    }
    var index2 = findIndexFunc(collection, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : void 0;
  };
}
var createFind_default = createFind;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/findIndex.js
var nativeMax7 = Math.max;
function findIndex(array, predicate, fromIndex) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax7(length2 + index2, 0);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index2);
}
var findIndex_default = findIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/find.js
var find = createFind_default(findIndex_default);
var find_default = find;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFindKey.js
function baseFindKey(collection, predicate, eachFunc) {
  var result2;
  eachFunc(collection, function(value, key, collection2) {
    if (predicate(value, key, collection2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
}
var baseFindKey_default = baseFindKey;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/findKey.js
function findKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwn_default);
}
var findKey_default = findKey;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/findLastIndex.js
var nativeMax8 = Math.max;
var nativeMin5 = Math.min;
function findLastIndex(array, predicate, fromIndex) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return -1;
  }
  var index2 = length2 - 1;
  if (fromIndex !== void 0) {
    index2 = toInteger_default(fromIndex);
    index2 = fromIndex < 0 ? nativeMax8(length2 + index2, 0) : nativeMin5(index2, length2 - 1);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index2, true);
}
var findLastIndex_default = findLastIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/findLast.js
var findLast = createFind_default(findLastIndex_default);
var findLast_default = findLast;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/findLastKey.js
function findLastKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwnRight_default);
}
var findLastKey_default = findLastKey;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
function head(array) {
  return array && array.length ? array[0] : void 0;
}
var head_default = head;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee2) {
  var index2 = -1, result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result2[++index2] = iteratee2(value, key, collection2);
  });
  return result2;
}
var baseMap_default = baseMap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/map.js
function map(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee2, 3));
}
var map_default = map;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), 1);
}
var flatMap_default = flatMap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatMapDeep.js
var INFINITY4 = 1 / 0;
function flatMapDeep(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), INFINITY4);
}
var flatMapDeep_default = flatMapDeep;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatMapDepth.js
function flatMapDepth(collection, iteratee2, depth) {
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(map_default(collection, iteratee2), depth);
}
var flatMapDepth_default = flatMapDepth;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flattenDeep.js
var INFINITY5 = 1 / 0;
function flattenDeep(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseFlatten_default(array, INFINITY5) : [];
}
var flattenDeep_default = flattenDeep;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flattenDepth.js
function flattenDepth(array, depth) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return [];
  }
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(array, depth);
}
var flattenDepth_default = flattenDepth;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flip.js
var WRAP_FLIP_FLAG3 = 512;
function flip(func) {
  return createWrap_default(func, WRAP_FLIP_FLAG3);
}
var flip_default = flip;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/floor.js
var floor = createRound_default("floor");
var floor_default = floor;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT8 = "Expected a function";
var WRAP_CURRY_FLAG7 = 8;
var WRAP_PARTIAL_FLAG6 = 32;
var WRAP_ARY_FLAG5 = 128;
var WRAP_REARG_FLAG3 = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length2 = funcs.length, index2 = length2, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index2--) {
      var func = funcs[index2];
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT8);
      }
      if (prereq && !wrapper && getFuncName_default(func) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index2 = wrapper ? index2 : length2;
    while (++index2 < length2) {
      func = funcs[index2];
      var funcName = getFuncName_default(func), data2 = funcName == "wrapper" ? getData_default(func) : void 0;
      if (data2 && isLaziable_default(data2[0]) && data2[1] == (WRAP_ARY_FLAG5 | WRAP_CURRY_FLAG7 | WRAP_PARTIAL_FLAG6 | WRAP_REARG_FLAG3) && !data2[4].length && data2[9] == 1) {
        wrapper = wrapper[getFuncName_default(data2[0])].apply(wrapper, data2[3]);
      } else {
        wrapper = func.length == 1 && isLaziable_default(func) ? wrapper[funcName]() : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments, value = args[0];
      if (wrapper && args.length == 1 && isArray_default(value)) {
        return wrapper.plant(value).value();
      }
      var index3 = 0, result2 = length2 ? funcs[index3].apply(this, args) : value;
      while (++index3 < length2) {
        result2 = funcs[index3].call(this, result2);
      }
      return result2;
    };
  });
}
var createFlow_default = createFlow;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flow.js
var flow = createFlow_default();
var flow_default = flow;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flowRight.js
var flowRight = createFlow_default(true);
var flowRight_default = flowRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/forIn.js
function forIn(object, iteratee2) {
  return object == null ? object : baseFor_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forIn_default = forIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/forInRight.js
function forInRight(object, iteratee2) {
  return object == null ? object : baseForRight_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forInRight_default = forInRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/forOwn.js
function forOwn(object, iteratee2) {
  return object && baseForOwn_default(object, castFunction_default(iteratee2));
}
var forOwn_default = forOwn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/forOwnRight.js
function forOwnRight(object, iteratee2) {
  return object && baseForOwnRight_default(object, castFunction_default(iteratee2));
}
var forOwnRight_default = forOwnRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/fromPairs.js
function fromPairs(pairs) {
  var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
  while (++index2 < length2) {
    var pair = pairs[index2];
    result2[pair[0]] = pair[1];
  }
  return result2;
}
var fromPairs_default = fromPairs;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFunctions.js
function baseFunctions(object, props) {
  return arrayFilter_default(props, function(key) {
    return isFunction_default(object[key]);
  });
}
var baseFunctions_default = baseFunctions;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/functions.js
function functions(object) {
  return object == null ? [] : baseFunctions_default(object, keys_default(object));
}
var functions_default = functions;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/functionsIn.js
function functionsIn(object) {
  return object == null ? [] : baseFunctions_default(object, keysIn_default(object));
}
var functionsIn_default = functionsIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/groupBy.js
var objectProto22 = Object.prototype;
var hasOwnProperty19 = objectProto22.hasOwnProperty;
var groupBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty19.call(result2, key)) {
    result2[key].push(value);
  } else {
    baseAssignValue_default(result2, key, [value]);
  }
});
var groupBy_default = groupBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGt.js
function baseGt(value, other) {
  return value > other;
}
var baseGt_default = baseGt;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createRelationalOperation.js
function createRelationalOperation(operator) {
  return function(value, other) {
    if (!(typeof value == "string" && typeof other == "string")) {
      value = toNumber_default(value);
      other = toNumber_default(other);
    }
    return operator(value, other);
  };
}
var createRelationalOperation_default = createRelationalOperation;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/gt.js
var gt = createRelationalOperation_default(baseGt_default);
var gt_default = gt;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/gte.js
var gte = createRelationalOperation_default(function(value, other) {
  return value >= other;
});
var gte_default = gte;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseHas.js
var objectProto23 = Object.prototype;
var hasOwnProperty20 = objectProto23.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty20.call(object, key);
}
var baseHas_default = baseHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/has.js
function has(object, path2) {
  return object != null && hasPath_default(object, path2, baseHas_default);
}
var has_default = has;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseInRange.js
var nativeMax9 = Math.max;
var nativeMin6 = Math.min;
function baseInRange(number, start, end) {
  return number >= nativeMin6(start, end) && number < nativeMax9(start, end);
}
var baseInRange_default = baseInRange;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/inRange.js
function inRange(number, start, end) {
  start = toFinite_default(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite_default(end);
  }
  number = toNumber_default(number);
  return baseInRange_default(number, start, end);
}
var inRange_default = inRange;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isString.js
var stringTag5 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag5;
}
var isString_default = isString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/values.js
function values(object) {
  return object == null ? [] : baseValues_default(object, keys_default(object));
}
var values_default = values;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/includes.js
var nativeMax10 = Math.max;
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length2 = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax10(length2 + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf_default(collection, value, fromIndex) > -1;
}
var includes_default = includes;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/indexOf.js
var nativeMax11 = Math.max;
function indexOf(array, value, fromIndex) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax11(length2 + index2, 0);
  }
  return baseIndexOf_default(array, value, index2);
}
var indexOf_default = indexOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/initial.js
function initial(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseSlice_default(array, 0, -1) : [];
}
var initial_default = initial;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIntersection.js
var nativeMin7 = Math.min;
function baseIntersection(arrays, iteratee2, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee2) {
      array = arrayMap_default(array, baseUnary_default(iteratee2));
    }
    maxLength = nativeMin7(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array.length >= 120) ? new SetCache_default(othIndex && array) : void 0;
  }
  array = arrays[0];
  var index2 = -1, seen = caches[0];
  outer:
    while (++index2 < length2 && result2.length < maxLength) {
      var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (!(seen ? cacheHas_default(seen, computed) : includes2(result2, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas_default(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result2.push(value);
      }
    }
  return result2;
}
var baseIntersection_default = baseIntersection;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value) {
  return isArrayLikeObject_default(value) ? value : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/intersection.js
var intersection = baseRest_default(function(arrays) {
  var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
});
var intersection_default = intersection;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/intersectionBy.js
var intersectionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  if (iteratee2 === last_default(mapped)) {
    iteratee2 = void 0;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, baseIteratee_default(iteratee2, 2)) : [];
});
var intersectionBy_default = intersectionBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/intersectionWith.js
var intersectionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  comparator = typeof comparator == "function" ? comparator : void 0;
  if (comparator) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, void 0, comparator) : [];
});
var intersectionWith_default = intersectionWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseInverter.js
function baseInverter(object, setter, iteratee2, accumulator) {
  baseForOwn_default(object, function(value, key, object2) {
    setter(accumulator, iteratee2(value), key, object2);
  });
  return accumulator;
}
var baseInverter_default = baseInverter;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createInverter.js
function createInverter(setter, toIteratee) {
  return function(object, iteratee2) {
    return baseInverter_default(object, setter, toIteratee(iteratee2), {});
  };
}
var createInverter_default = createInverter;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/invert.js
var objectProto24 = Object.prototype;
var nativeObjectToString3 = objectProto24.toString;
var invert = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString3.call(value);
  }
  result2[value] = key;
}, constant_default(identity_default));
var invert_default = invert;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/invertBy.js
var objectProto25 = Object.prototype;
var hasOwnProperty21 = objectProto25.hasOwnProperty;
var nativeObjectToString4 = objectProto25.toString;
var invertBy = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString4.call(value);
  }
  if (hasOwnProperty21.call(result2, value)) {
    result2[value].push(key);
  } else {
    result2[value] = [key];
  }
}, baseIteratee_default);
var invertBy_default = invertBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_parent.js
function parent(object, path2) {
  return path2.length < 2 ? object : baseGet_default(object, baseSlice_default(path2, 0, -1));
}
var parent_default = parent;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseInvoke.js
function baseInvoke(object, path2, args) {
  path2 = castPath_default(path2, object);
  object = parent_default(object, path2);
  var func = object == null ? object : object[toKey_default(last_default(path2))];
  return func == null ? void 0 : apply_default(func, object, args);
}
var baseInvoke_default = baseInvoke;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/invoke.js
var invoke = baseRest_default(baseInvoke_default);
var invoke_default = invoke;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/invokeMap.js
var invokeMap = baseRest_default(function(collection, path2, args) {
  var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value) {
    result2[++index2] = isFunc ? apply_default(path2, value, args) : baseInvoke_default(value, path2, args);
  });
  return result2;
});
var invokeMap_default = invokeMap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArrayBuffer.js
var arrayBufferTag5 = "[object ArrayBuffer]";
function baseIsArrayBuffer(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == arrayBufferTag5;
}
var baseIsArrayBuffer_default = baseIsArrayBuffer;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayBuffer.js
var nodeIsArrayBuffer = nodeUtil_default && nodeUtil_default.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary_default(nodeIsArrayBuffer) : baseIsArrayBuffer_default;
var isArrayBuffer_default = isArrayBuffer;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBoolean.js
var boolTag5 = "[object Boolean]";
function isBoolean(value) {
  return value === true || value === false || isObjectLike_default(value) && baseGetTag_default(value) == boolTag5;
}
var isBoolean_default = isBoolean;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsDate.js
var dateTag5 = "[object Date]";
function baseIsDate(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == dateTag5;
}
var baseIsDate_default = baseIsDate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isDate.js
var nodeIsDate = nodeUtil_default && nodeUtil_default.isDate;
var isDate = nodeIsDate ? baseUnary_default(nodeIsDate) : baseIsDate_default;
var isDate_default = isDate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isElement.js
function isElement(value) {
  return isObjectLike_default(value) && value.nodeType === 1 && !isPlainObject_default(value);
}
var isElement_default = isElement;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEmpty.js
var mapTag8 = "[object Map]";
var setTag8 = "[object Set]";
var objectProto26 = Object.prototype;
var hasOwnProperty22 = objectProto26.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag = getTag_default(value);
  if (tag == mapTag8 || tag == setTag8) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty22.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEqual.js
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
var isEqual_default = isEqual;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEqualWith.js
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result2 = customizer ? customizer(value, other) : void 0;
  return result2 === void 0 ? baseIsEqual_default(value, other, void 0, customizer) : !!result2;
}
var isEqualWith_default = isEqualWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFinite.js
var nativeIsFinite2 = root_default.isFinite;
function isFinite(value) {
  return typeof value == "number" && nativeIsFinite2(value);
}
var isFinite_default = isFinite;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isInteger.js
function isInteger(value) {
  return typeof value == "number" && value == toInteger_default(value);
}
var isInteger_default = isInteger;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isMatch.js
function isMatch(object, source) {
  return object === source || baseIsMatch_default(object, source, getMatchData_default(source));
}
var isMatch_default = isMatch;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isMatchWith.js
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseIsMatch_default(object, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isNumber.js
var numberTag5 = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike_default(value) && baseGetTag_default(value) == numberTag5;
}
var isNumber_default = isNumber;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isNaN.js
function isNaN(value) {
  return isNumber_default(value) && value != +value;
}
var isNaN_default = isNaN;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMaskable.js
var isMaskable = coreJsData_default ? isFunction_default : stubFalse_default;
var isMaskable_default = isMaskable;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isNative.js
var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
function isNative(value) {
  if (isMaskable_default(value)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative_default(value);
}
var isNative_default = isNative;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isNil.js
function isNil(value) {
  return value == null;
}
var isNil_default = isNil;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isNull.js
function isNull(value) {
  return value === null;
}
var isNull_default = isNull;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsRegExp.js
var regexpTag5 = "[object RegExp]";
function baseIsRegExp(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == regexpTag5;
}
var baseIsRegExp_default = baseIsRegExp;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isRegExp.js
var nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
var isRegExp_default = isRegExp;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSafeInteger.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
function isSafeInteger(value) {
  return isInteger_default(value) && value >= -MAX_SAFE_INTEGER3 && value <= MAX_SAFE_INTEGER3;
}
var isSafeInteger_default = isSafeInteger;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_default = isUndefined;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isWeakMap.js
var weakMapTag4 = "[object WeakMap]";
function isWeakMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == weakMapTag4;
}
var isWeakMap_default = isWeakMap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isWeakSet.js
var weakSetTag = "[object WeakSet]";
function isWeakSet(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == weakSetTag;
}
var isWeakSet_default = isWeakSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/iteratee.js
var CLONE_DEEP_FLAG5 = 1;
function iteratee(func) {
  return baseIteratee_default(typeof func == "function" ? func : baseClone_default(func, CLONE_DEEP_FLAG5));
}
var iteratee_default = iteratee;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/join.js
var arrayProto2 = Array.prototype;
var nativeJoin = arrayProto2.join;
function join(array, separator) {
  return array == null ? "" : nativeJoin.call(array, separator);
}
var join_default = join;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/kebabCase.js
var kebabCase = createCompounder_default(function(result2, word, index2) {
  return result2 + (index2 ? "-" : "") + word.toLowerCase();
});
var kebabCase_default = kebabCase;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keyBy.js
var keyBy = createAggregator_default(function(result2, value, key) {
  baseAssignValue_default(result2, key, value);
});
var keyBy_default = keyBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_strictLastIndexOf.js
function strictLastIndexOf(array, value, fromIndex) {
  var index2 = fromIndex + 1;
  while (index2--) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return index2;
}
var strictLastIndexOf_default = strictLastIndexOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/lastIndexOf.js
var nativeMax12 = Math.max;
var nativeMin8 = Math.min;
function lastIndexOf(array, value, fromIndex) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return -1;
  }
  var index2 = length2;
  if (fromIndex !== void 0) {
    index2 = toInteger_default(fromIndex);
    index2 = index2 < 0 ? nativeMax12(length2 + index2, 0) : nativeMin8(index2, length2 - 1);
  }
  return value === value ? strictLastIndexOf_default(array, value, index2) : baseFindIndex_default(array, baseIsNaN_default, index2, true);
}
var lastIndexOf_default = lastIndexOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/lowerCase.js
var lowerCase = createCompounder_default(function(result2, word, index2) {
  return result2 + (index2 ? " " : "") + word.toLowerCase();
});
var lowerCase_default = lowerCase;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/lowerFirst.js
var lowerFirst = createCaseFirst_default("toLowerCase");
var lowerFirst_default = lowerFirst;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseLt.js
function baseLt(value, other) {
  return value < other;
}
var baseLt_default = baseLt;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/lt.js
var lt = createRelationalOperation_default(baseLt_default);
var lt_default = lt;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/lte.js
var lte = createRelationalOperation_default(function(value, other) {
  return value <= other;
});
var lte_default = lte;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/mapKeys.js
function mapKeys(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, iteratee2(value, key, object2), value);
  });
  return result2;
}
var mapKeys_default = mapKeys;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, key, iteratee2(value, key, object2));
  });
  return result2;
}
var mapValues_default = mapValues;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/matches.js
var CLONE_DEEP_FLAG6 = 1;
function matches(source) {
  return baseMatches_default(baseClone_default(source, CLONE_DEEP_FLAG6));
}
var matches_default = matches;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/matchesProperty.js
var CLONE_DEEP_FLAG7 = 1;
function matchesProperty(path2, srcValue) {
  return baseMatchesProperty_default(path2, baseClone_default(srcValue, CLONE_DEEP_FLAG7));
}
var matchesProperty_default = matchesProperty;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array, iteratee2, comparator) {
  var index2 = -1, length2 = array.length;
  while (++index2 < length2) {
    var value = array[index2], current = iteratee2(value);
    if (current != null && (computed === void 0 ? current === current && !isSymbol_default(current) : comparator(current, computed))) {
      var computed = current, result2 = value;
    }
  }
  return result2;
}
var baseExtremum_default = baseExtremum;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/max.js
function max(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseGt_default) : void 0;
}
var max_default = max;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/maxBy.js
function maxBy(array, iteratee2) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee2, 2), baseGt_default) : void 0;
}
var maxBy_default = maxBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSum.js
function baseSum(array, iteratee2) {
  var result2, index2 = -1, length2 = array.length;
  while (++index2 < length2) {
    var current = iteratee2(array[index2]);
    if (current !== void 0) {
      result2 = result2 === void 0 ? current : result2 + current;
    }
  }
  return result2;
}
var baseSum_default = baseSum;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMean.js
var NAN3 = 0 / 0;
function baseMean(array, iteratee2) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseSum_default(array, iteratee2) / length2 : NAN3;
}
var baseMean_default = baseMean;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/mean.js
function mean(array) {
  return baseMean_default(array, identity_default);
}
var mean_default = mean;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/meanBy.js
function meanBy(array, iteratee2) {
  return baseMean_default(array, baseIteratee_default(iteratee2, 2));
}
var meanBy_default = meanBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/method.js
var method = baseRest_default(function(path2, args) {
  return function(object) {
    return baseInvoke_default(object, path2, args);
  };
});
var method_default = method;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/methodOf.js
var methodOf = baseRest_default(function(object, args) {
  return function(path2) {
    return baseInvoke_default(object, path2, args);
  };
});
var methodOf_default = methodOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/min.js
function min(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseLt_default) : void 0;
}
var min_default = min;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/minBy.js
function minBy(array, iteratee2) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee2, 2), baseLt_default) : void 0;
}
var minBy_default = minBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/mixin.js
function mixin(object, source, options) {
  var props = keys_default(source), methodNames = baseFunctions_default(source, props);
  var chain2 = !(isObject_default(options) && "chain" in options) || !!options.chain, isFunc = isFunction_default(object);
  arrayEach_default(methodNames, function(methodName) {
    var func = source[methodName];
    object[methodName] = func;
    if (isFunc) {
      object.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain2 || chainAll) {
          var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray_default(this.__actions__);
          actions.push({ "func": func, "args": arguments, "thisArg": object });
          result2.__chain__ = chainAll;
          return result2;
        }
        return func.apply(object, arrayPush_default([this.value()], arguments));
      };
    }
  });
  return object;
}
var mixin_default = mixin;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/multiply.js
var multiply = createMathOperation_default(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);
var multiply_default = multiply;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/negate.js
var FUNC_ERROR_TEXT9 = "Expected a function";
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT9);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_default = negate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_iteratorToArray.js
function iteratorToArray(iterator) {
  var data2, result2 = [];
  while (!(data2 = iterator.next()).done) {
    result2.push(data2.value);
  }
  return result2;
}
var iteratorToArray_default = iteratorToArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toArray.js
var mapTag9 = "[object Map]";
var setTag9 = "[object Set]";
var symIterator = Symbol_default ? Symbol_default.iterator : void 0;
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike_default(value)) {
    return isString_default(value) ? stringToArray_default(value) : copyArray_default(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray_default(value[symIterator]());
  }
  var tag = getTag_default(value), func = tag == mapTag9 ? mapToArray_default : tag == setTag9 ? setToArray_default : values_default;
  return func(value);
}
var toArray_default = toArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/next.js
function wrapperNext() {
  if (this.__values__ === void 0) {
    this.__values__ = toArray_default(this.value());
  }
  var done = this.__index__ >= this.__values__.length, value = done ? void 0 : this.__values__[this.__index__++];
  return { "done": done, "value": value };
}
var next_default = wrapperNext;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseNth.js
function baseNth(array, n) {
  var length2 = array.length;
  if (!length2) {
    return;
  }
  n += n < 0 ? length2 : 0;
  return isIndex_default(n, length2) ? array[n] : void 0;
}
var baseNth_default = baseNth;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/nth.js
function nth(array, n) {
  return array && array.length ? baseNth_default(array, toInteger_default(n)) : void 0;
}
var nth_default = nth;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/nthArg.js
function nthArg(n) {
  n = toInteger_default(n);
  return baseRest_default(function(args) {
    return baseNth_default(args, n);
  });
}
var nthArg_default = nthArg;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnset.js
function baseUnset(object, path2) {
  path2 = castPath_default(path2, object);
  object = parent_default(object, path2);
  return object == null || delete object[toKey_default(last_default(path2))];
}
var baseUnset_default = baseUnset;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_customOmitClone.js
function customOmitClone(value) {
  return isPlainObject_default(value) ? void 0 : value;
}
var customOmitClone_default = customOmitClone;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omit.js
var CLONE_DEEP_FLAG8 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG6 = 4;
var omit = flatRest_default(function(object, paths) {
  var result2 = {};
  if (object == null) {
    return result2;
  }
  var isDeep = false;
  paths = arrayMap_default(paths, function(path2) {
    path2 = castPath_default(path2, object);
    isDeep || (isDeep = path2.length > 1);
    return path2;
  });
  copyObject_default(object, getAllKeysIn_default(object), result2);
  if (isDeep) {
    result2 = baseClone_default(result2, CLONE_DEEP_FLAG8 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG6, customOmitClone_default);
  }
  var length2 = paths.length;
  while (length2--) {
    baseUnset_default(result2, paths[length2]);
  }
  return result2;
});
var omit_default = omit;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSet.js
function baseSet(object, path2, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path2 = castPath_default(path2, object);
  var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index2 < length2) {
    var key = toKey_default(path2[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path2[index2 + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index2 = -1, length2 = paths.length, result2 = {};
  while (++index2 < length2) {
    var path2 = paths[index2], value = baseGet_default(object, path2);
    if (predicate(value, path2)) {
      baseSet_default(result2, castPath_default(path2, object), value);
    }
  }
  return result2;
}
var basePickBy_default = basePickBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pickBy.js
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object), function(prop2) {
    return [prop2];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object, props, function(value, path2) {
    return predicate(value, path2[0]);
  });
}
var pickBy_default = pickBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omitBy.js
function omitBy(object, predicate) {
  return pickBy_default(object, negate_default(baseIteratee_default(predicate)));
}
var omitBy_default = omitBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/once.js
function once(func) {
  return before_default(2, func);
}
var once_default = once;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array, comparer) {
  var length2 = array.length;
  array.sort(comparer);
  while (length2--) {
    array[length2] = array[length2].value;
  }
  return array;
}
var baseSortBy_default = baseSortBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_compareAscending.js
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other, orders) {
  var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
  while (++index2 < length2) {
    var result2 = compareAscending_default(objCriteria[index2], othCriteria[index2]);
    if (result2) {
      if (index2 >= ordersLength) {
        return result2;
      }
      var order = orders[index2];
      return result2 * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
var compareMultiple_default = compareMultiple;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee2) {
      if (isArray_default(iteratee2)) {
        return function(value) {
          return baseGet_default(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity_default];
  }
  var index2 = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result2 = baseMap_default(collection, function(value, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee2) {
      return iteratee2(value);
    });
    return { "criteria": criteria, "index": ++index2, "value": value };
  });
  return baseSortBy_default(result2, function(object, other) {
    return compareMultiple_default(object, other, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/orderBy.js
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray_default(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? void 0 : orders;
  if (!isArray_default(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy_default(collection, iteratees, orders);
}
var orderBy_default = orderBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createOver.js
function createOver(arrayFunc) {
  return flatRest_default(function(iteratees) {
    iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
    return baseRest_default(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee2) {
        return apply_default(iteratee2, thisArg, args);
      });
    });
  });
}
var createOver_default = createOver;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/over.js
var over = createOver_default(arrayMap_default);
var over_default = over;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castRest.js
var castRest = baseRest_default;
var castRest_default = castRest;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/overArgs.js
var nativeMin9 = Math.min;
var overArgs = castRest_default(function(func, transforms) {
  transforms = transforms.length == 1 && isArray_default(transforms[0]) ? arrayMap_default(transforms[0], baseUnary_default(baseIteratee_default)) : arrayMap_default(baseFlatten_default(transforms, 1), baseUnary_default(baseIteratee_default));
  var funcsLength = transforms.length;
  return baseRest_default(function(args) {
    var index2 = -1, length2 = nativeMin9(args.length, funcsLength);
    while (++index2 < length2) {
      args[index2] = transforms[index2].call(this, args[index2]);
    }
    return apply_default(func, this, args);
  });
});
var overArgs_default = overArgs;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/overEvery.js
var overEvery = createOver_default(arrayEvery_default);
var overEvery_default = overEvery;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/overSome.js
var overSome = createOver_default(arraySome_default);
var overSome_default = overSome;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER4 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string, n) {
  var result2 = "";
  if (!string || n < 1 || n > MAX_SAFE_INTEGER4) {
    return result2;
  }
  do {
    if (n % 2) {
      result2 += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);
  return result2;
}
var baseRepeat_default = baseRepeat;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_unicodeSize.js
var rsAstralRange4 = "\\ud800-\\udfff";
var rsComboMarksRange5 = "\\u0300-\\u036f";
var reComboHalfMarksRange5 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange5 = "\\u20d0-\\u20ff";
var rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5;
var rsVarRange4 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange4 + "]";
var rsCombo4 = "[" + rsComboRange5 + "]";
var rsFitz3 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")";
var rsNonAstral3 = "[^" + rsAstralRange4 + "]";
var rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ4 = "\\u200d";
var reOptMod3 = rsModifier3 + "?";
var rsOptVar3 = "[" + rsVarRange4 + "]?";
var rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*";
var rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3;
var rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
function unicodeSize(string) {
  var result2 = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string)) {
    ++result2;
  }
  return result2;
}
var unicodeSize_default = unicodeSize;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stringSize.js
function stringSize(string) {
  return hasUnicode_default(string) ? unicodeSize_default(string) : asciiSize_default(string);
}
var stringSize_default = stringSize;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createPadding.js
var nativeCeil2 = Math.ceil;
function createPadding(length2, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length2) : chars;
  }
  var result2 = baseRepeat_default(chars, nativeCeil2(length2 / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result2), 0, length2).join("") : result2.slice(0, length2);
}
var createPadding_default = createPadding;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pad.js
var nativeCeil3 = Math.ceil;
var nativeFloor2 = Math.floor;
function pad(string, length2, chars) {
  string = toString_default(string);
  length2 = toInteger_default(length2);
  var strLength = length2 ? stringSize_default(string) : 0;
  if (!length2 || strLength >= length2) {
    return string;
  }
  var mid = (length2 - strLength) / 2;
  return createPadding_default(nativeFloor2(mid), chars) + string + createPadding_default(nativeCeil3(mid), chars);
}
var pad_default = pad;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/padEnd.js
function padEnd(string, length2, chars) {
  string = toString_default(string);
  length2 = toInteger_default(length2);
  var strLength = length2 ? stringSize_default(string) : 0;
  return length2 && strLength < length2 ? string + createPadding_default(length2 - strLength, chars) : string;
}
var padEnd_default = padEnd;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/padStart.js
function padStart(string, length2, chars) {
  string = toString_default(string);
  length2 = toInteger_default(length2);
  var strLength = length2 ? stringSize_default(string) : 0;
  return length2 && strLength < length2 ? createPadding_default(length2 - strLength, chars) + string : string;
}
var padStart_default = padStart;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/parseInt.js
var reTrimStart2 = /^\s+/;
var nativeParseInt = root_default.parseInt;
function parseInt2(string, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString_default(string).replace(reTrimStart2, ""), radix || 0);
}
var parseInt_default = parseInt2;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/partial.js
var WRAP_PARTIAL_FLAG7 = 32;
var partial = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partial));
  return createWrap_default(func, WRAP_PARTIAL_FLAG7, void 0, partials, holders);
});
partial.placeholder = {};
var partial_default = partial;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/partialRight.js
var WRAP_PARTIAL_RIGHT_FLAG4 = 64;
var partialRight = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partialRight));
  return createWrap_default(func, WRAP_PARTIAL_RIGHT_FLAG4, void 0, partials, holders);
});
partialRight.placeholder = {};
var partialRight_default = partialRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/partition.js
var partition = createAggregator_default(function(result2, value, key) {
  result2[key ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
var partition_default = partition;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePick.js
function basePick(object, paths) {
  return basePickBy_default(object, paths, function(value, path2) {
    return hasIn_default(object, path2);
  });
}
var basePick_default = basePick;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pick.js
var pick = flatRest_default(function(object, paths) {
  return object == null ? {} : basePick_default(object, paths);
});
var pick_default = pick;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/plant.js
function wrapperPlant(value) {
  var result2, parent2 = this;
  while (parent2 instanceof baseLodash_default) {
    var clone2 = wrapperClone_default(parent2);
    clone2.__index__ = 0;
    clone2.__values__ = void 0;
    if (result2) {
      previous.__wrapped__ = clone2;
    } else {
      result2 = clone2;
    }
    var previous = clone2;
    parent2 = parent2.__wrapped__;
  }
  previous.__wrapped__ = value;
  return result2;
}
var plant_default = wrapperPlant;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/propertyOf.js
function propertyOf(object) {
  return function(path2) {
    return object == null ? void 0 : baseGet_default(object, path2);
  };
}
var propertyOf_default = propertyOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (comparator(array[index2], value)) {
      return index2;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePullAll.js
var arrayProto3 = Array.prototype;
var splice2 = arrayProto3.splice;
function basePullAll(array, values2, iteratee2, comparator) {
  var indexOf2 = comparator ? baseIndexOfWith_default : baseIndexOf_default, index2 = -1, length2 = values2.length, seen = array;
  if (array === values2) {
    values2 = copyArray_default(values2);
  }
  if (iteratee2) {
    seen = arrayMap_default(array, baseUnary_default(iteratee2));
  }
  while (++index2 < length2) {
    var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice2.call(seen, fromIndex, 1);
      }
      splice2.call(array, fromIndex, 1);
    }
  }
  return array;
}
var basePullAll_default = basePullAll;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pullAll.js
function pullAll(array, values2) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2) : array;
}
var pullAll_default = pullAll;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default = pull;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pullAllBy.js
function pullAllBy(array, values2, iteratee2) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2, baseIteratee_default(iteratee2, 2)) : array;
}
var pullAllBy_default = pullAllBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pullAllWith.js
function pullAllWith(array, values2, comparator) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2, void 0, comparator) : array;
}
var pullAllWith_default = pullAllWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePullAt.js
var arrayProto4 = Array.prototype;
var splice3 = arrayProto4.splice;
function basePullAt(array, indexes) {
  var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
  while (length2--) {
    var index2 = indexes[length2];
    if (length2 == lastIndex || index2 !== previous) {
      var previous = index2;
      if (isIndex_default(index2)) {
        splice3.call(array, index2, 1);
      } else {
        baseUnset_default(array, index2);
      }
    }
  }
  return array;
}
var basePullAt_default = basePullAt;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pullAt.js
var pullAt = flatRest_default(function(array, indexes) {
  var length2 = array == null ? 0 : array.length, result2 = baseAt_default(array, indexes);
  basePullAt_default(array, arrayMap_default(indexes, function(index2) {
    return isIndex_default(index2, length2) ? +index2 : index2;
  }).sort(compareAscending_default));
  return result2;
});
var pullAt_default = pullAt;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRandom.js
var nativeFloor3 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower, upper) {
  return lower + nativeFloor3(nativeRandom() * (upper - lower + 1));
}
var baseRandom_default = baseRandom;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/random.js
var freeParseFloat = parseFloat;
var nativeMin10 = Math.min;
var nativeRandom2 = Math.random;
function random(lower, upper, floating) {
  if (floating && typeof floating != "boolean" && isIterateeCall_default(lower, upper, floating)) {
    upper = floating = void 0;
  }
  if (floating === void 0) {
    if (typeof upper == "boolean") {
      floating = upper;
      upper = void 0;
    } else if (typeof lower == "boolean") {
      floating = lower;
      lower = void 0;
    }
  }
  if (lower === void 0 && upper === void 0) {
    lower = 0;
    upper = 1;
  } else {
    lower = toFinite_default(lower);
    if (upper === void 0) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite_default(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom2();
    return nativeMin10(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
  }
  return baseRandom_default(lower, upper);
}
var random_default = random;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRange.js
var nativeCeil4 = Math.ceil;
var nativeMax13 = Math.max;
function baseRange(start, end, step, fromRight) {
  var index2 = -1, length2 = nativeMax13(nativeCeil4((end - start) / (step || 1)), 0), result2 = Array(length2);
  while (length2--) {
    result2[fromRight ? length2 : ++index2] = start;
    start += step;
  }
  return result2;
}
var baseRange_default = baseRange;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall_default(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite_default(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite_default(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite_default(step);
    return baseRange_default(start, end, step, fromRight);
  };
}
var createRange_default = createRange;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/range.js
var range = createRange_default();
var range_default = range;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/rangeRight.js
var rangeRight = createRange_default(true);
var rangeRight_default = rangeRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/rearg.js
var WRAP_REARG_FLAG4 = 256;
var rearg = flatRest_default(function(func, indexes) {
  return createWrap_default(func, WRAP_REARG_FLAG4, void 0, void 0, void 0, indexes);
});
var rearg_default = rearg;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseReduce.js
function baseReduce(collection, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index2, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index2, collection2);
  });
  return accumulator;
}
var baseReduce_default = baseReduce;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/reduce.js
function reduce(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEach_default);
}
var reduce_default = reduce;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayReduceRight.js
function arrayReduceRight(array, iteratee2, accumulator, initAccum) {
  var length2 = array == null ? 0 : array.length;
  if (initAccum && length2) {
    accumulator = array[--length2];
  }
  while (length2--) {
    accumulator = iteratee2(accumulator, array[length2], length2, array);
  }
  return accumulator;
}
var arrayReduceRight_default = arrayReduceRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/reduceRight.js
function reduceRight(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduceRight_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEachRight_default);
}
var reduceRight_default = reduceRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/reject.js
function reject(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, negate_default(baseIteratee_default(predicate, 3)));
}
var reject_default = reject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/remove.js
function remove(array, predicate) {
  var result2 = [];
  if (!(array && array.length)) {
    return result2;
  }
  var index2 = -1, indexes = [], length2 = array.length;
  predicate = baseIteratee_default(predicate, 3);
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result2.push(value);
      indexes.push(index2);
    }
  }
  basePullAt_default(array, indexes);
  return result2;
}
var remove_default = remove;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/repeat.js
function repeat(string, n, guard) {
  if (guard ? isIterateeCall_default(string, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  return baseRepeat_default(toString_default(string), n);
}
var repeat_default = repeat;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/replace.js
function replace() {
  var args = arguments, string = toString_default(args[0]);
  return args.length < 3 ? string : string.replace(args[1], args[2]);
}
var replace_default = replace;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/rest.js
var FUNC_ERROR_TEXT10 = "Expected a function";
function rest(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT10);
  }
  start = start === void 0 ? start : toInteger_default(start);
  return baseRest_default(func, start);
}
var rest_default = rest;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/result.js
function result(object, path2, defaultValue) {
  path2 = castPath_default(path2, object);
  var index2 = -1, length2 = path2.length;
  if (!length2) {
    length2 = 1;
    object = void 0;
  }
  while (++index2 < length2) {
    var value = object == null ? void 0 : object[toKey_default(path2[index2])];
    if (value === void 0) {
      index2 = length2;
      value = defaultValue;
    }
    object = isFunction_default(value) ? value.call(object) : value;
  }
  return object;
}
var result_default = result;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/reverse.js
var arrayProto5 = Array.prototype;
var nativeReverse = arrayProto5.reverse;
function reverse(array) {
  return array == null ? array : nativeReverse.call(array);
}
var reverse_default = reverse;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/round.js
var round = createRound_default("round");
var round_default = round;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arraySample.js
function arraySample(array) {
  var length2 = array.length;
  return length2 ? array[baseRandom_default(0, length2 - 1)] : void 0;
}
var arraySample_default = arraySample;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSample.js
function baseSample(collection) {
  return arraySample_default(values_default(collection));
}
var baseSample_default = baseSample;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sample.js
function sample(collection) {
  var func = isArray_default(collection) ? arraySample_default : baseSample_default;
  return func(collection);
}
var sample_default = sample;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array, size2) {
  var index2 = -1, length2 = array.length, lastIndex = length2 - 1;
  size2 = size2 === void 0 ? length2 : size2;
  while (++index2 < size2) {
    var rand = baseRandom_default(index2, lastIndex), value = array[rand];
    array[rand] = array[index2];
    array[index2] = value;
  }
  array.length = size2;
  return array;
}
var shuffleSelf_default = shuffleSelf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arraySampleSize.js
function arraySampleSize(array, n) {
  return shuffleSelf_default(copyArray_default(array), baseClamp_default(n, 0, array.length));
}
var arraySampleSize_default = arraySampleSize;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSampleSize.js
function baseSampleSize(collection, n) {
  var array = values_default(collection);
  return shuffleSelf_default(array, baseClamp_default(n, 0, array.length));
}
var baseSampleSize_default = baseSampleSize;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sampleSize.js
function sampleSize(collection, n, guard) {
  if (guard ? isIterateeCall_default(collection, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  var func = isArray_default(collection) ? arraySampleSize_default : baseSampleSize_default;
  return func(collection, n);
}
var sampleSize_default = sampleSize;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/set.js
function set(object, path2, value) {
  return object == null ? object : baseSet_default(object, path2, value);
}
var set_default = set;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/setWith.js
function setWith(object, path2, value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseSet_default(object, path2, value, customizer);
}
var setWith_default = setWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array) {
  return shuffleSelf_default(copyArray_default(array));
}
var arrayShuffle_default = arrayShuffle;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default(collection));
}
var baseShuffle_default = baseShuffle;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/shuffle.js
function shuffle(collection) {
  var func = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func(collection);
}
var shuffle_default = shuffle;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/size.js
var mapTag10 = "[object Map]";
var setTag10 = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_default(collection)) {
    return isString_default(collection) ? stringSize_default(collection) : collection.length;
  }
  var tag = getTag_default(collection);
  if (tag == mapTag10 || tag == setTag10) {
    return collection.size;
  }
  return baseKeys_default(collection).length;
}
var size_default = size;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/slice.js
function slice(array, start, end) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall_default(array, start, end)) {
    start = 0;
    end = length2;
  } else {
    start = start == null ? 0 : toInteger_default(start);
    end = end === void 0 ? length2 : toInteger_default(end);
  }
  return baseSlice_default(array, start, end);
}
var slice_default = slice;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/snakeCase.js
var snakeCase = createCompounder_default(function(result2, word, index2) {
  return result2 + (index2 ? "_" : "") + word.toLowerCase();
});
var snakeCase_default = snakeCase;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSome.js
function baseSome(collection, predicate) {
  var result2;
  baseEach_default(collection, function(value, index2, collection2) {
    result2 = predicate(value, index2, collection2);
    return !result2;
  });
  return !!result2;
}
var baseSome_default = baseSome;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/some.js
function some(collection, predicate, guard) {
  var func = isArray_default(collection) ? arraySome_default : baseSome_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var some_default = some;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortBy.js
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length2 = iteratees.length;
  if (length2 > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length2 > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSortedIndexBy.js
var MAX_ARRAY_LENGTH3 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH3 - 1;
var nativeFloor4 = Math.floor;
var nativeMin11 = Math.min;
function baseSortedIndexBy(array, value, iteratee2, retHighest) {
  var low = 0, high = array == null ? 0 : array.length;
  if (high === 0) {
    return 0;
  }
  value = iteratee2(value);
  var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol_default(value), valIsUndefined = value === void 0;
  while (low < high) {
    var mid = nativeFloor4((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== void 0, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol_default(computed);
    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value : computed < value;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin11(high, MAX_ARRAY_INDEX);
}
var baseSortedIndexBy_default = baseSortedIndexBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSortedIndex.js
var MAX_ARRAY_LENGTH4 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH4 >>> 1;
function baseSortedIndex(array, value, retHighest) {
  var low = 0, high = array == null ? low : array.length;
  if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1, computed = array[mid];
      if (computed !== null && !isSymbol_default(computed) && (retHighest ? computed <= value : computed < value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy_default(array, value, identity_default, retHighest);
}
var baseSortedIndex_default = baseSortedIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortedIndex.js
function sortedIndex(array, value) {
  return baseSortedIndex_default(array, value);
}
var sortedIndex_default = sortedIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortedIndexBy.js
function sortedIndexBy(array, value, iteratee2) {
  return baseSortedIndexBy_default(array, value, baseIteratee_default(iteratee2, 2));
}
var sortedIndexBy_default = sortedIndexBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortedIndexOf.js
function sortedIndexOf(array, value) {
  var length2 = array == null ? 0 : array.length;
  if (length2) {
    var index2 = baseSortedIndex_default(array, value);
    if (index2 < length2 && eq_default(array[index2], value)) {
      return index2;
    }
  }
  return -1;
}
var sortedIndexOf_default = sortedIndexOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortedLastIndex.js
function sortedLastIndex(array, value) {
  return baseSortedIndex_default(array, value, true);
}
var sortedLastIndex_default = sortedLastIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortedLastIndexBy.js
function sortedLastIndexBy(array, value, iteratee2) {
  return baseSortedIndexBy_default(array, value, baseIteratee_default(iteratee2, 2), true);
}
var sortedLastIndexBy_default = sortedLastIndexBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortedLastIndexOf.js
function sortedLastIndexOf(array, value) {
  var length2 = array == null ? 0 : array.length;
  if (length2) {
    var index2 = baseSortedIndex_default(array, value, true) - 1;
    if (eq_default(array[index2], value)) {
      return index2;
    }
  }
  return -1;
}
var sortedLastIndexOf_default = sortedLastIndexOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSortedUniq.js
function baseSortedUniq(array, iteratee2) {
  var index2 = -1, length2 = array.length, resIndex = 0, result2 = [];
  while (++index2 < length2) {
    var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
    if (!index2 || !eq_default(computed, seen)) {
      var seen = computed;
      result2[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result2;
}
var baseSortedUniq_default = baseSortedUniq;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortedUniq.js
function sortedUniq(array) {
  return array && array.length ? baseSortedUniq_default(array) : [];
}
var sortedUniq_default = sortedUniq;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortedUniqBy.js
function sortedUniqBy(array, iteratee2) {
  return array && array.length ? baseSortedUniq_default(array, baseIteratee_default(iteratee2, 2)) : [];
}
var sortedUniqBy_default = sortedUniqBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/split.js
var MAX_ARRAY_LENGTH5 = 4294967295;
function split(string, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall_default(string, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH5 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString_default(string);
  if (string && (typeof separator == "string" || separator != null && !isRegExp_default(separator))) {
    separator = baseToString_default(separator);
    if (!separator && hasUnicode_default(string)) {
      return castSlice_default(stringToArray_default(string), 0, limit);
    }
  }
  return string.split(separator, limit);
}
var split_default = split;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/spread.js
var FUNC_ERROR_TEXT11 = "Expected a function";
var nativeMax14 = Math.max;
function spread(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT11);
  }
  start = start == null ? 0 : nativeMax14(toInteger_default(start), 0);
  return baseRest_default(function(args) {
    var array = args[start], otherArgs = castSlice_default(args, 0, start);
    if (array) {
      arrayPush_default(otherArgs, array);
    }
    return apply_default(func, this, otherArgs);
  });
}
var spread_default = spread;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/startCase.js
var startCase = createCompounder_default(function(result2, word, index2) {
  return result2 + (index2 ? " " : "") + upperFirst_default(word);
});
var startCase_default = startCase;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/startsWith.js
function startsWith(string, target, position2) {
  string = toString_default(string);
  position2 = position2 == null ? 0 : baseClamp_default(toInteger_default(position2), 0, string.length);
  target = baseToString_default(target);
  return string.slice(position2, position2 + target.length) == target;
}
var startsWith_default = startsWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubObject.js
function stubObject() {
  return {};
}
var stubObject_default = stubObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubString.js
function stubString() {
  return "";
}
var stubString_default = stubString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubTrue.js
function stubTrue() {
  return true;
}
var stubTrue_default = stubTrue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/subtract.js
var subtract = createMathOperation_default(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);
var subtract_default = subtract;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sum.js
function sum(array) {
  return array && array.length ? baseSum_default(array, identity_default) : 0;
}
var sum_default = sum;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sumBy.js
function sumBy(array, iteratee2) {
  return array && array.length ? baseSum_default(array, baseIteratee_default(iteratee2, 2)) : 0;
}
var sumBy_default = sumBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/tail.js
function tail(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseSlice_default(array, 1, length2) : [];
}
var tail_default = tail;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/take.js
function take(array, n, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array, 0, n < 0 ? 0 : n);
}
var take_default = take;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/takeRight.js
function takeRight(array, n, guard) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length2 - n;
  return baseSlice_default(array, n < 0 ? 0 : n, length2);
}
var takeRight_default = takeRight;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/takeRightWhile.js
function takeRightWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), false, true) : [];
}
var takeRightWhile_default = takeRightWhile;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/takeWhile.js
function takeWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3)) : [];
}
var takeWhile_default = takeWhile;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/tap.js
function tap(value, interceptor) {
  interceptor(value);
  return value;
}
var tap_default = tap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_customDefaultsAssignIn.js
var objectProto27 = Object.prototype;
var hasOwnProperty23 = objectProto27.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === void 0 || eq_default(objValue, objectProto27[key]) && !hasOwnProperty23.call(object, key)) {
    return srcValue;
  }
  return objValue;
}
var customDefaultsAssignIn_default = customDefaultsAssignIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_escapeStringChar.js
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var escapeStringChar_default = escapeStringChar;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_reInterpolate.js
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate_default = reInterpolate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_reEscape.js
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape_default = reEscape;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_reEvaluate.js
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate_default = reEvaluate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/templateSettings.js
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape_default,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate_default,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate_default,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": { "escape": escape_default }
  }
};
var templateSettings_default = templateSettings;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/template.js
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto28 = Object.prototype;
var hasOwnProperty24 = objectProto28.hasOwnProperty;
function template(string, options, guard) {
  var settings = templateSettings_default.imports._.templateSettings || templateSettings_default;
  if (guard && isIterateeCall_default(string, options, guard)) {
    options = void 0;
  }
  string = toString_default(string);
  options = assignInWith_default({}, options, settings, customDefaultsAssignIn_default);
  var imports = assignInWith_default({}, options.imports, settings.imports, customDefaultsAssignIn_default), importsKeys = keys_default(imports), importsValues = baseValues_default(imports, importsKeys);
  var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate_default ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
    "g"
  );
  var sourceURL = hasOwnProperty24.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset3) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string.slice(index2, offset3).replace(reUnescapedString, escapeStringChar_default);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index2 = offset3 + match.length;
    return match;
  });
  source += "';\n";
  var variable = hasOwnProperty24.call(options, "variable") && options.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result2 = attempt_default(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result2.source = source;
  if (isError_default(result2)) {
    throw result2;
  }
  return result2;
}
var template_default = template;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT12 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT12);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default = throttle;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/thru.js
function thru(value, interceptor) {
  return interceptor(value);
}
var thru_default = thru;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/times.js
var MAX_SAFE_INTEGER5 = 9007199254740991;
var MAX_ARRAY_LENGTH6 = 4294967295;
var nativeMin12 = Math.min;
function times(n, iteratee2) {
  n = toInteger_default(n);
  if (n < 1 || n > MAX_SAFE_INTEGER5) {
    return [];
  }
  var index2 = MAX_ARRAY_LENGTH6, length2 = nativeMin12(n, MAX_ARRAY_LENGTH6);
  iteratee2 = castFunction_default(iteratee2);
  n -= MAX_ARRAY_LENGTH6;
  var result2 = baseTimes_default(length2, iteratee2);
  while (++index2 < n) {
    iteratee2(index2);
  }
  return result2;
}
var times_default = times;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toIterator.js
function wrapperToIterator() {
  return this;
}
var toIterator_default = wrapperToIterator;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseWrapperValue.js
function baseWrapperValue(value, actions) {
  var result2 = value;
  if (result2 instanceof LazyWrapper_default) {
    result2 = result2.value();
  }
  return arrayReduce_default(actions, function(result3, action) {
    return action.func.apply(action.thisArg, arrayPush_default([result3], action.args));
  }, result2);
}
var baseWrapperValue_default = baseWrapperValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/wrapperValue.js
function wrapperValue() {
  return baseWrapperValue_default(this.__wrapped__, this.__actions__);
}
var wrapperValue_default = wrapperValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toLower.js
function toLower(value) {
  return toString_default(value).toLowerCase();
}
var toLower_default = toLower;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toPath.js
function toPath(value) {
  if (isArray_default(value)) {
    return arrayMap_default(value, toKey_default);
  }
  return isSymbol_default(value) ? [value] : copyArray_default(stringToPath_default(toString_default(value)));
}
var toPath_default = toPath;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toSafeInteger.js
var MAX_SAFE_INTEGER6 = 9007199254740991;
function toSafeInteger(value) {
  return value ? baseClamp_default(toInteger_default(value), -MAX_SAFE_INTEGER6, MAX_SAFE_INTEGER6) : value === 0 ? value : 0;
}
var toSafeInteger_default = toSafeInteger;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toUpper.js
function toUpper(value) {
  return toString_default(value).toUpperCase();
}
var toUpper_default = toUpper;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/transform.js
function transform(object, iteratee2, accumulator) {
  var isArr = isArray_default(object), isArrLike = isArr || isBuffer_default(object) || isTypedArray_default(object);
  iteratee2 = baseIteratee_default(iteratee2, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_default(object)) {
      accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach_default : baseForOwn_default)(object, function(value, index2, object2) {
    return iteratee2(accumulator, value, index2, object2);
  });
  return accumulator;
}
var transform_default = transform;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_charsEndIndex.js
function charsEndIndex(strSymbols, chrSymbols) {
  var index2 = strSymbols.length;
  while (index2-- && baseIndexOf_default(chrSymbols, strSymbols[index2], 0) > -1) {
  }
  return index2;
}
var charsEndIndex_default = charsEndIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_charsStartIndex.js
function charsStartIndex(strSymbols, chrSymbols) {
  var index2 = -1, length2 = strSymbols.length;
  while (++index2 < length2 && baseIndexOf_default(chrSymbols, strSymbols[index2], 0) > -1) {
  }
  return index2;
}
var charsStartIndex_default = charsStartIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/trim.js
function trim(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return baseTrim_default(string);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), chrSymbols = stringToArray_default(chars), start = charsStartIndex_default(strSymbols, chrSymbols), end = charsEndIndex_default(strSymbols, chrSymbols) + 1;
  return castSlice_default(strSymbols, start, end).join("");
}
var trim_default = trim;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/trimEnd.js
function trimEnd(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.slice(0, trimmedEndIndex_default(string) + 1);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), end = charsEndIndex_default(strSymbols, stringToArray_default(chars)) + 1;
  return castSlice_default(strSymbols, 0, end).join("");
}
var trimEnd_default = trimEnd;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/trimStart.js
var reTrimStart3 = /^\s+/;
function trimStart(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.replace(reTrimStart3, "");
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), start = charsStartIndex_default(strSymbols, stringToArray_default(chars));
  return castSlice_default(strSymbols, start).join("");
}
var trimStart_default = trimStart;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/truncate.js
var DEFAULT_TRUNC_LENGTH = 30;
var DEFAULT_TRUNC_OMISSION = "...";
var reFlags2 = /\w*$/;
function truncate(string, options) {
  var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject_default(options)) {
    var separator = "separator" in options ? options.separator : separator;
    length2 = "length" in options ? toInteger_default(options.length) : length2;
    omission = "omission" in options ? baseToString_default(options.omission) : omission;
  }
  string = toString_default(string);
  var strLength = string.length;
  if (hasUnicode_default(string)) {
    var strSymbols = stringToArray_default(string);
    strLength = strSymbols.length;
  }
  if (length2 >= strLength) {
    return string;
  }
  var end = length2 - stringSize_default(omission);
  if (end < 1) {
    return omission;
  }
  var result2 = strSymbols ? castSlice_default(strSymbols, 0, end).join("") : string.slice(0, end);
  if (separator === void 0) {
    return result2 + omission;
  }
  if (strSymbols) {
    end += result2.length - end;
  }
  if (isRegExp_default(separator)) {
    if (string.slice(end).search(separator)) {
      var match, substring = result2;
      if (!separator.global) {
        separator = RegExp(separator.source, toString_default(reFlags2.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match = separator.exec(substring)) {
        var newEnd = match.index;
      }
      result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
    }
  } else if (string.indexOf(baseToString_default(separator), end) != end) {
    var index2 = result2.lastIndexOf(separator);
    if (index2 > -1) {
      result2 = result2.slice(0, index2);
    }
  }
  return result2 + omission;
}
var truncate_default = truncate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/unary.js
function unary(func) {
  return ary_default(func, 1);
}
var unary_default = unary;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_unescapeHtmlChar.js
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
var unescapeHtmlChar = basePropertyOf_default(htmlUnescapes);
var unescapeHtmlChar_default = unescapeHtmlChar;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/unescape.js
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape2(string) {
  string = toString_default(string);
  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar_default) : string;
}
var unescape_default = unescape2;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createSet.js
var INFINITY6 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY6) ? noop_default : function(values2) {
  return new Set_default(values2);
};
var createSet_default = createSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE3 = 200;
function baseUniq(array, iteratee2, comparator) {
  var index2 = -1, includes2 = arrayIncludes_default, length2 = array.length, isCommon = true, result2 = [], seen = result2;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith_default;
  } else if (length2 >= LARGE_ARRAY_SIZE3) {
    var set2 = iteratee2 ? null : createSet_default(array);
    if (set2) {
      return setToArray_default(set2);
    }
    isCommon = false;
    includes2 = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee2 ? [] : result2;
  }
  outer:
    while (++index2 < length2) {
      var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee2) {
          seen.push(computed);
        }
        result2.push(value);
      } else if (!includes2(seen, computed, comparator)) {
        if (seen !== result2) {
          seen.push(computed);
        }
        result2.push(value);
      }
    }
  return result2;
}
var baseUniq_default = baseUniq;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/union.js
var union = baseRest_default(function(arrays) {
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true));
});
var union_default = union;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/unionBy.js
var unionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2));
});
var unionBy_default = unionBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/unionWith.js
var unionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), void 0, comparator);
});
var unionWith_default = unionWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniq.js
function uniq(array) {
  return array && array.length ? baseUniq_default(array) : [];
}
var uniq_default = uniq;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqBy.js
function uniqBy(array, iteratee2) {
  return array && array.length ? baseUniq_default(array, baseIteratee_default(iteratee2, 2)) : [];
}
var uniqBy_default = uniqBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqWith.js
function uniqWith(array, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array && array.length ? baseUniq_default(array, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString_default(prefix) + id;
}
var uniqueId_default = uniqueId;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/unset.js
function unset(object, path2) {
  return object == null ? true : baseUnset_default(object, path2);
}
var unset_default = unset;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/unzip.js
var nativeMax15 = Math.max;
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length2 = 0;
  array = arrayFilter_default(array, function(group) {
    if (isArrayLikeObject_default(group)) {
      length2 = nativeMax15(group.length, length2);
      return true;
    }
  });
  return baseTimes_default(length2, function(index2) {
    return arrayMap_default(array, baseProperty_default(index2));
  });
}
var unzip_default = unzip;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/unzipWith.js
function unzipWith(array, iteratee2) {
  if (!(array && array.length)) {
    return [];
  }
  var result2 = unzip_default(array);
  if (iteratee2 == null) {
    return result2;
  }
  return arrayMap_default(result2, function(group) {
    return apply_default(iteratee2, void 0, group);
  });
}
var unzipWith_default = unzipWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUpdate.js
function baseUpdate(object, path2, updater, customizer) {
  return baseSet_default(object, path2, updater(baseGet_default(object, path2)), customizer);
}
var baseUpdate_default = baseUpdate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/update.js
function update(object, path2, updater) {
  return object == null ? object : baseUpdate_default(object, path2, castFunction_default(updater));
}
var update_default = update;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/updateWith.js
function updateWith(object, path2, updater, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseUpdate_default(object, path2, castFunction_default(updater), customizer);
}
var updateWith_default = updateWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/upperCase.js
var upperCase = createCompounder_default(function(result2, word, index2) {
  return result2 + (index2 ? " " : "") + word.toUpperCase();
});
var upperCase_default = upperCase;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/valuesIn.js
function valuesIn(object) {
  return object == null ? [] : baseValues_default(object, keysIn_default(object));
}
var valuesIn_default = valuesIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/without.js
var without = baseRest_default(function(array, values2) {
  return isArrayLikeObject_default(array) ? baseDifference_default(array, values2) : [];
});
var without_default = without;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/wrap.js
function wrap(value, wrapper) {
  return partial_default(castFunction_default(wrapper), value);
}
var wrap_default = wrap;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/wrapperAt.js
var wrapperAt = flatRest_default(function(paths) {
  var length2 = paths.length, start = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
    return baseAt_default(object, paths);
  };
  if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper_default) || !isIndex_default(start)) {
    return this.thru(interceptor);
  }
  value = value.slice(start, +start + (length2 ? 1 : 0));
  value.__actions__.push({
    "func": thru_default,
    "args": [interceptor],
    "thisArg": void 0
  });
  return new LodashWrapper_default(value, this.__chain__).thru(function(array) {
    if (length2 && !array.length) {
      array.push(void 0);
    }
    return array;
  });
});
var wrapperAt_default = wrapperAt;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/wrapperChain.js
function wrapperChain() {
  return chain_default(this);
}
var wrapperChain_default = wrapperChain;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/wrapperReverse.js
function wrapperReverse() {
  var value = this.__wrapped__;
  if (value instanceof LazyWrapper_default) {
    var wrapped = value;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper_default(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      "func": thru_default,
      "args": [reverse_default],
      "thisArg": void 0
    });
    return new LodashWrapper_default(wrapped, this.__chain__);
  }
  return this.thru(reverse_default);
}
var wrapperReverse_default = wrapperReverse;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseXor.js
function baseXor(arrays, iteratee2, comparator) {
  var length2 = arrays.length;
  if (length2 < 2) {
    return length2 ? baseUniq_default(arrays[0]) : [];
  }
  var index2 = -1, result2 = Array(length2);
  while (++index2 < length2) {
    var array = arrays[index2], othIndex = -1;
    while (++othIndex < length2) {
      if (othIndex != index2) {
        result2[index2] = baseDifference_default(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
      }
    }
  }
  return baseUniq_default(baseFlatten_default(result2, 1), iteratee2, comparator);
}
var baseXor_default = baseXor;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/xor.js
var xor = baseRest_default(function(arrays) {
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default));
});
var xor_default = xor;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/xorBy.js
var xorBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), baseIteratee_default(iteratee2, 2));
});
var xorBy_default = xorBy;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/xorWith.js
var xorWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), void 0, comparator);
});
var xorWith_default = xorWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/zip.js
var zip = baseRest_default(unzip_default);
var zip_default = zip;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseZipObject.js
function baseZipObject(props, values2, assignFunc) {
  var index2 = -1, length2 = props.length, valsLength = values2.length, result2 = {};
  while (++index2 < length2) {
    var value = index2 < valsLength ? values2[index2] : void 0;
    assignFunc(result2, props[index2], value);
  }
  return result2;
}
var baseZipObject_default = baseZipObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/zipObject.js
function zipObject(props, values2) {
  return baseZipObject_default(props || [], values2 || [], assignValue_default);
}
var zipObject_default = zipObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/zipObjectDeep.js
function zipObjectDeep(props, values2) {
  return baseZipObject_default(props || [], values2 || [], baseSet_default);
}
var zipObjectDeep_default = zipObjectDeep;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/zipWith.js
var zipWith = baseRest_default(function(arrays) {
  var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : void 0;
  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
  return unzipWith_default(arrays, iteratee2);
});
var zipWith_default = zipWith;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/array.default.js
var array_default_default = {
  chunk: chunk_default,
  compact: compact_default,
  concat: concat_default,
  difference: difference_default,
  differenceBy: differenceBy_default,
  differenceWith: differenceWith_default,
  drop: drop_default,
  dropRight: dropRight_default,
  dropRightWhile: dropRightWhile_default,
  dropWhile: dropWhile_default,
  fill: fill_default,
  findIndex: findIndex_default,
  findLastIndex: findLastIndex_default,
  first: head_default,
  flatten: flatten_default,
  flattenDeep: flattenDeep_default,
  flattenDepth: flattenDepth_default,
  fromPairs: fromPairs_default,
  head: head_default,
  indexOf: indexOf_default,
  initial: initial_default,
  intersection: intersection_default,
  intersectionBy: intersectionBy_default,
  intersectionWith: intersectionWith_default,
  join: join_default,
  last: last_default,
  lastIndexOf: lastIndexOf_default,
  nth: nth_default,
  pull: pull_default,
  pullAll: pullAll_default,
  pullAllBy: pullAllBy_default,
  pullAllWith: pullAllWith_default,
  pullAt: pullAt_default,
  remove: remove_default,
  reverse: reverse_default,
  slice: slice_default,
  sortedIndex: sortedIndex_default,
  sortedIndexBy: sortedIndexBy_default,
  sortedIndexOf: sortedIndexOf_default,
  sortedLastIndex: sortedLastIndex_default,
  sortedLastIndexBy: sortedLastIndexBy_default,
  sortedLastIndexOf: sortedLastIndexOf_default,
  sortedUniq: sortedUniq_default,
  sortedUniqBy: sortedUniqBy_default,
  tail: tail_default,
  take: take_default,
  takeRight: takeRight_default,
  takeRightWhile: takeRightWhile_default,
  takeWhile: takeWhile_default,
  union: union_default,
  unionBy: unionBy_default,
  unionWith: unionWith_default,
  uniq: uniq_default,
  uniqBy: uniqBy_default,
  uniqWith: uniqWith_default,
  unzip: unzip_default,
  unzipWith: unzipWith_default,
  without: without_default,
  xor: xor_default,
  xorBy: xorBy_default,
  xorWith: xorWith_default,
  zip: zip_default,
  zipObject: zipObject_default,
  zipObjectDeep: zipObjectDeep_default,
  zipWith: zipWith_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/collection.default.js
var collection_default_default = {
  countBy: countBy_default,
  each: forEach_default,
  eachRight: forEachRight_default,
  every: every_default,
  filter: filter_default,
  find: find_default,
  findLast: findLast_default,
  flatMap: flatMap_default,
  flatMapDeep: flatMapDeep_default,
  flatMapDepth: flatMapDepth_default,
  forEach: forEach_default,
  forEachRight: forEachRight_default,
  groupBy: groupBy_default,
  includes: includes_default,
  invokeMap: invokeMap_default,
  keyBy: keyBy_default,
  map: map_default,
  orderBy: orderBy_default,
  partition: partition_default,
  reduce: reduce_default,
  reduceRight: reduceRight_default,
  reject: reject_default,
  sample: sample_default,
  sampleSize: sampleSize_default,
  shuffle: shuffle_default,
  size: size_default,
  some: some_default,
  sortBy: sortBy_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/date.default.js
var date_default_default = {
  now: now_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/function.default.js
var function_default_default = {
  after: after_default,
  ary: ary_default,
  before: before_default,
  bind: bind_default,
  bindKey: bindKey_default,
  curry: curry_default,
  curryRight: curryRight_default,
  debounce: debounce_default,
  defer: defer_default,
  delay: delay_default,
  flip: flip_default,
  memoize: memoize_default,
  negate: negate_default,
  once: once_default,
  overArgs: overArgs_default,
  partial: partial_default,
  partialRight: partialRight_default,
  rearg: rearg_default,
  rest: rest_default,
  spread: spread_default,
  throttle: throttle_default,
  unary: unary_default,
  wrap: wrap_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/lang.default.js
var lang_default_default = {
  castArray: castArray_default,
  clone: clone_default,
  cloneDeep: cloneDeep_default,
  cloneDeepWith: cloneDeepWith_default,
  cloneWith: cloneWith_default,
  conformsTo: conformsTo_default,
  eq: eq_default,
  gt: gt_default,
  gte: gte_default,
  isArguments: isArguments_default,
  isArray: isArray_default,
  isArrayBuffer: isArrayBuffer_default,
  isArrayLike: isArrayLike_default,
  isArrayLikeObject: isArrayLikeObject_default,
  isBoolean: isBoolean_default,
  isBuffer: isBuffer_default,
  isDate: isDate_default,
  isElement: isElement_default,
  isEmpty: isEmpty_default,
  isEqual: isEqual_default,
  isEqualWith: isEqualWith_default,
  isError: isError_default,
  isFinite: isFinite_default,
  isFunction: isFunction_default,
  isInteger: isInteger_default,
  isLength: isLength_default,
  isMap: isMap_default,
  isMatch: isMatch_default,
  isMatchWith: isMatchWith_default,
  isNaN: isNaN_default,
  isNative: isNative_default,
  isNil: isNil_default,
  isNull: isNull_default,
  isNumber: isNumber_default,
  isObject: isObject_default,
  isObjectLike: isObjectLike_default,
  isPlainObject: isPlainObject_default,
  isRegExp: isRegExp_default,
  isSafeInteger: isSafeInteger_default,
  isSet: isSet_default,
  isString: isString_default,
  isSymbol: isSymbol_default,
  isTypedArray: isTypedArray_default,
  isUndefined: isUndefined_default,
  isWeakMap: isWeakMap_default,
  isWeakSet: isWeakSet_default,
  lt: lt_default,
  lte: lte_default,
  toArray: toArray_default,
  toFinite: toFinite_default,
  toInteger: toInteger_default,
  toLength: toLength_default,
  toNumber: toNumber_default,
  toPlainObject: toPlainObject_default,
  toSafeInteger: toSafeInteger_default,
  toString: toString_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/math.default.js
var math_default_default = {
  add: add_default,
  ceil: ceil_default,
  divide: divide_default,
  floor: floor_default,
  max: max_default,
  maxBy: maxBy_default,
  mean: mean_default,
  meanBy: meanBy_default,
  min: min_default,
  minBy: minBy_default,
  multiply: multiply_default,
  round: round_default,
  subtract: subtract_default,
  sum: sum_default,
  sumBy: sumBy_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/number.default.js
var number_default_default = {
  clamp: clamp_default,
  inRange: inRange_default,
  random: random_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/object.default.js
var object_default_default = {
  assign: assign_default,
  assignIn: assignIn_default,
  assignInWith: assignInWith_default,
  assignWith: assignWith_default,
  at: at_default,
  create: create_default,
  defaults: defaults_default,
  defaultsDeep: defaultsDeep_default,
  entries: toPairs_default,
  entriesIn: toPairsIn_default,
  extend: assignIn_default,
  extendWith: assignInWith_default,
  findKey: findKey_default,
  findLastKey: findLastKey_default,
  forIn: forIn_default,
  forInRight: forInRight_default,
  forOwn: forOwn_default,
  forOwnRight: forOwnRight_default,
  functions: functions_default,
  functionsIn: functionsIn_default,
  get: get_default,
  has: has_default,
  hasIn: hasIn_default,
  invert: invert_default,
  invertBy: invertBy_default,
  invoke: invoke_default,
  keys: keys_default,
  keysIn: keysIn_default,
  mapKeys: mapKeys_default,
  mapValues: mapValues_default,
  merge: merge_default,
  mergeWith: mergeWith_default,
  omit: omit_default,
  omitBy: omitBy_default,
  pick: pick_default,
  pickBy: pickBy_default,
  result: result_default,
  set: set_default,
  setWith: setWith_default,
  toPairs: toPairs_default,
  toPairsIn: toPairsIn_default,
  transform: transform_default,
  unset: unset_default,
  update: update_default,
  updateWith: updateWith_default,
  values: values_default,
  valuesIn: valuesIn_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/seq.default.js
var seq_default_default = {
  at: wrapperAt_default,
  chain: chain_default,
  commit: commit_default,
  lodash: wrapperLodash_default,
  next: next_default,
  plant: plant_default,
  reverse: wrapperReverse_default,
  tap: tap_default,
  thru: thru_default,
  toIterator: toIterator_default,
  toJSON: wrapperValue_default,
  value: wrapperValue_default,
  valueOf: wrapperValue_default,
  wrapperChain: wrapperChain_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/string.default.js
var string_default_default = {
  camelCase: camelCase_default,
  capitalize: capitalize_default,
  deburr: deburr_default,
  endsWith: endsWith_default,
  escape: escape_default,
  escapeRegExp: escapeRegExp_default,
  kebabCase: kebabCase_default,
  lowerCase: lowerCase_default,
  lowerFirst: lowerFirst_default,
  pad: pad_default,
  padEnd: padEnd_default,
  padStart: padStart_default,
  parseInt: parseInt_default,
  repeat: repeat_default,
  replace: replace_default,
  snakeCase: snakeCase_default,
  split: split_default,
  startCase: startCase_default,
  startsWith: startsWith_default,
  template: template_default,
  templateSettings: templateSettings_default,
  toLower: toLower_default,
  toUpper: toUpper_default,
  trim: trim_default,
  trimEnd: trimEnd_default,
  trimStart: trimStart_default,
  truncate: truncate_default,
  unescape: unescape_default,
  upperCase: upperCase_default,
  upperFirst: upperFirst_default,
  words: words_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/util.default.js
var util_default_default = {
  attempt: attempt_default,
  bindAll: bindAll_default,
  cond: cond_default,
  conforms: conforms_default,
  constant: constant_default,
  defaultTo: defaultTo_default,
  flow: flow_default,
  flowRight: flowRight_default,
  identity: identity_default,
  iteratee: iteratee_default,
  matches: matches_default,
  matchesProperty: matchesProperty_default,
  method: method_default,
  methodOf: methodOf_default,
  mixin: mixin_default,
  noop: noop_default,
  nthArg: nthArg_default,
  over: over_default,
  overEvery: overEvery_default,
  overSome: overSome_default,
  property: property_default,
  propertyOf: propertyOf_default,
  range: range_default,
  rangeRight: rangeRight_default,
  stubArray: stubArray_default,
  stubFalse: stubFalse_default,
  stubObject: stubObject_default,
  stubString: stubString_default,
  stubTrue: stubTrue_default,
  times: times_default,
  toPath: toPath_default,
  uniqueId: uniqueId_default
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_lazyClone.js
function lazyClone() {
  var result2 = new LazyWrapper_default(this.__wrapped__);
  result2.__actions__ = copyArray_default(this.__actions__);
  result2.__dir__ = this.__dir__;
  result2.__filtered__ = this.__filtered__;
  result2.__iteratees__ = copyArray_default(this.__iteratees__);
  result2.__takeCount__ = this.__takeCount__;
  result2.__views__ = copyArray_default(this.__views__);
  return result2;
}
var lazyClone_default = lazyClone;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_lazyReverse.js
function lazyReverse() {
  if (this.__filtered__) {
    var result2 = new LazyWrapper_default(this);
    result2.__dir__ = -1;
    result2.__filtered__ = true;
  } else {
    result2 = this.clone();
    result2.__dir__ *= -1;
  }
  return result2;
}
var lazyReverse_default = lazyReverse;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getView.js
var nativeMax16 = Math.max;
var nativeMin13 = Math.min;
function getView(start, end, transforms) {
  var index2 = -1, length2 = transforms.length;
  while (++index2 < length2) {
    var data2 = transforms[index2], size2 = data2.size;
    switch (data2.type) {
      case "drop":
        start += size2;
        break;
      case "dropRight":
        end -= size2;
        break;
      case "take":
        end = nativeMin13(end, start + size2);
        break;
      case "takeRight":
        start = nativeMax16(start, end - size2);
        break;
    }
  }
  return { "start": start, "end": end };
}
var getView_default = getView;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_lazyValue.js
var LAZY_FILTER_FLAG = 1;
var LAZY_MAP_FLAG = 2;
var nativeMin14 = Math.min;
function lazyValue() {
  var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray_default(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView_default(0, arrLength, this.__views__), start = view.start, end = view.end, length2 = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin14(length2, this.__takeCount__);
  if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
    return baseWrapperValue_default(array, this.__actions__);
  }
  var result2 = [];
  outer:
    while (length2-- && resIndex < takeCount) {
      index2 += dir;
      var iterIndex = -1, value = array[index2];
      while (++iterIndex < iterLength) {
        var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value);
        if (type == LAZY_MAP_FLAG) {
          value = computed;
        } else if (!computed) {
          if (type == LAZY_FILTER_FLAG) {
            continue outer;
          } else {
            break outer;
          }
        }
      }
      result2[resIndex++] = value;
    }
  return result2;
}
var lazyValue_default = lazyValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/lodash.default.js
var VERSION = "4.17.21";
var WRAP_BIND_KEY_FLAG7 = 2;
var LAZY_FILTER_FLAG2 = 1;
var LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH7 = 4294967295;
var arrayProto6 = Array.prototype;
var objectProto29 = Object.prototype;
var hasOwnProperty25 = objectProto29.hasOwnProperty;
var symIterator2 = Symbol_default ? Symbol_default.iterator : void 0;
var nativeMax17 = Math.max;
var nativeMin15 = Math.min;
var mixin2 = /* @__PURE__ */ function(func) {
  return function(object, source, options) {
    if (options == null) {
      var isObj = isObject_default(source), props = isObj && keys_default(source), methodNames = props && props.length && baseFunctions_default(source, props);
      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object;
        object = this;
      }
    }
    return func(object, source, options);
  };
}(mixin_default);
wrapperLodash_default.after = function_default_default.after;
wrapperLodash_default.ary = function_default_default.ary;
wrapperLodash_default.assign = object_default_default.assign;
wrapperLodash_default.assignIn = object_default_default.assignIn;
wrapperLodash_default.assignInWith = object_default_default.assignInWith;
wrapperLodash_default.assignWith = object_default_default.assignWith;
wrapperLodash_default.at = object_default_default.at;
wrapperLodash_default.before = function_default_default.before;
wrapperLodash_default.bind = function_default_default.bind;
wrapperLodash_default.bindAll = util_default_default.bindAll;
wrapperLodash_default.bindKey = function_default_default.bindKey;
wrapperLodash_default.castArray = lang_default_default.castArray;
wrapperLodash_default.chain = seq_default_default.chain;
wrapperLodash_default.chunk = array_default_default.chunk;
wrapperLodash_default.compact = array_default_default.compact;
wrapperLodash_default.concat = array_default_default.concat;
wrapperLodash_default.cond = util_default_default.cond;
wrapperLodash_default.conforms = util_default_default.conforms;
wrapperLodash_default.constant = util_default_default.constant;
wrapperLodash_default.countBy = collection_default_default.countBy;
wrapperLodash_default.create = object_default_default.create;
wrapperLodash_default.curry = function_default_default.curry;
wrapperLodash_default.curryRight = function_default_default.curryRight;
wrapperLodash_default.debounce = function_default_default.debounce;
wrapperLodash_default.defaults = object_default_default.defaults;
wrapperLodash_default.defaultsDeep = object_default_default.defaultsDeep;
wrapperLodash_default.defer = function_default_default.defer;
wrapperLodash_default.delay = function_default_default.delay;
wrapperLodash_default.difference = array_default_default.difference;
wrapperLodash_default.differenceBy = array_default_default.differenceBy;
wrapperLodash_default.differenceWith = array_default_default.differenceWith;
wrapperLodash_default.drop = array_default_default.drop;
wrapperLodash_default.dropRight = array_default_default.dropRight;
wrapperLodash_default.dropRightWhile = array_default_default.dropRightWhile;
wrapperLodash_default.dropWhile = array_default_default.dropWhile;
wrapperLodash_default.fill = array_default_default.fill;
wrapperLodash_default.filter = collection_default_default.filter;
wrapperLodash_default.flatMap = collection_default_default.flatMap;
wrapperLodash_default.flatMapDeep = collection_default_default.flatMapDeep;
wrapperLodash_default.flatMapDepth = collection_default_default.flatMapDepth;
wrapperLodash_default.flatten = array_default_default.flatten;
wrapperLodash_default.flattenDeep = array_default_default.flattenDeep;
wrapperLodash_default.flattenDepth = array_default_default.flattenDepth;
wrapperLodash_default.flip = function_default_default.flip;
wrapperLodash_default.flow = util_default_default.flow;
wrapperLodash_default.flowRight = util_default_default.flowRight;
wrapperLodash_default.fromPairs = array_default_default.fromPairs;
wrapperLodash_default.functions = object_default_default.functions;
wrapperLodash_default.functionsIn = object_default_default.functionsIn;
wrapperLodash_default.groupBy = collection_default_default.groupBy;
wrapperLodash_default.initial = array_default_default.initial;
wrapperLodash_default.intersection = array_default_default.intersection;
wrapperLodash_default.intersectionBy = array_default_default.intersectionBy;
wrapperLodash_default.intersectionWith = array_default_default.intersectionWith;
wrapperLodash_default.invert = object_default_default.invert;
wrapperLodash_default.invertBy = object_default_default.invertBy;
wrapperLodash_default.invokeMap = collection_default_default.invokeMap;
wrapperLodash_default.iteratee = util_default_default.iteratee;
wrapperLodash_default.keyBy = collection_default_default.keyBy;
wrapperLodash_default.keys = keys_default;
wrapperLodash_default.keysIn = object_default_default.keysIn;
wrapperLodash_default.map = collection_default_default.map;
wrapperLodash_default.mapKeys = object_default_default.mapKeys;
wrapperLodash_default.mapValues = object_default_default.mapValues;
wrapperLodash_default.matches = util_default_default.matches;
wrapperLodash_default.matchesProperty = util_default_default.matchesProperty;
wrapperLodash_default.memoize = function_default_default.memoize;
wrapperLodash_default.merge = object_default_default.merge;
wrapperLodash_default.mergeWith = object_default_default.mergeWith;
wrapperLodash_default.method = util_default_default.method;
wrapperLodash_default.methodOf = util_default_default.methodOf;
wrapperLodash_default.mixin = mixin2;
wrapperLodash_default.negate = negate_default;
wrapperLodash_default.nthArg = util_default_default.nthArg;
wrapperLodash_default.omit = object_default_default.omit;
wrapperLodash_default.omitBy = object_default_default.omitBy;
wrapperLodash_default.once = function_default_default.once;
wrapperLodash_default.orderBy = collection_default_default.orderBy;
wrapperLodash_default.over = util_default_default.over;
wrapperLodash_default.overArgs = function_default_default.overArgs;
wrapperLodash_default.overEvery = util_default_default.overEvery;
wrapperLodash_default.overSome = util_default_default.overSome;
wrapperLodash_default.partial = function_default_default.partial;
wrapperLodash_default.partialRight = function_default_default.partialRight;
wrapperLodash_default.partition = collection_default_default.partition;
wrapperLodash_default.pick = object_default_default.pick;
wrapperLodash_default.pickBy = object_default_default.pickBy;
wrapperLodash_default.property = util_default_default.property;
wrapperLodash_default.propertyOf = util_default_default.propertyOf;
wrapperLodash_default.pull = array_default_default.pull;
wrapperLodash_default.pullAll = array_default_default.pullAll;
wrapperLodash_default.pullAllBy = array_default_default.pullAllBy;
wrapperLodash_default.pullAllWith = array_default_default.pullAllWith;
wrapperLodash_default.pullAt = array_default_default.pullAt;
wrapperLodash_default.range = util_default_default.range;
wrapperLodash_default.rangeRight = util_default_default.rangeRight;
wrapperLodash_default.rearg = function_default_default.rearg;
wrapperLodash_default.reject = collection_default_default.reject;
wrapperLodash_default.remove = array_default_default.remove;
wrapperLodash_default.rest = function_default_default.rest;
wrapperLodash_default.reverse = array_default_default.reverse;
wrapperLodash_default.sampleSize = collection_default_default.sampleSize;
wrapperLodash_default.set = object_default_default.set;
wrapperLodash_default.setWith = object_default_default.setWith;
wrapperLodash_default.shuffle = collection_default_default.shuffle;
wrapperLodash_default.slice = array_default_default.slice;
wrapperLodash_default.sortBy = collection_default_default.sortBy;
wrapperLodash_default.sortedUniq = array_default_default.sortedUniq;
wrapperLodash_default.sortedUniqBy = array_default_default.sortedUniqBy;
wrapperLodash_default.split = string_default_default.split;
wrapperLodash_default.spread = function_default_default.spread;
wrapperLodash_default.tail = array_default_default.tail;
wrapperLodash_default.take = array_default_default.take;
wrapperLodash_default.takeRight = array_default_default.takeRight;
wrapperLodash_default.takeRightWhile = array_default_default.takeRightWhile;
wrapperLodash_default.takeWhile = array_default_default.takeWhile;
wrapperLodash_default.tap = seq_default_default.tap;
wrapperLodash_default.throttle = function_default_default.throttle;
wrapperLodash_default.thru = thru_default;
wrapperLodash_default.toArray = lang_default_default.toArray;
wrapperLodash_default.toPairs = object_default_default.toPairs;
wrapperLodash_default.toPairsIn = object_default_default.toPairsIn;
wrapperLodash_default.toPath = util_default_default.toPath;
wrapperLodash_default.toPlainObject = lang_default_default.toPlainObject;
wrapperLodash_default.transform = object_default_default.transform;
wrapperLodash_default.unary = function_default_default.unary;
wrapperLodash_default.union = array_default_default.union;
wrapperLodash_default.unionBy = array_default_default.unionBy;
wrapperLodash_default.unionWith = array_default_default.unionWith;
wrapperLodash_default.uniq = array_default_default.uniq;
wrapperLodash_default.uniqBy = array_default_default.uniqBy;
wrapperLodash_default.uniqWith = array_default_default.uniqWith;
wrapperLodash_default.unset = object_default_default.unset;
wrapperLodash_default.unzip = array_default_default.unzip;
wrapperLodash_default.unzipWith = array_default_default.unzipWith;
wrapperLodash_default.update = object_default_default.update;
wrapperLodash_default.updateWith = object_default_default.updateWith;
wrapperLodash_default.values = object_default_default.values;
wrapperLodash_default.valuesIn = object_default_default.valuesIn;
wrapperLodash_default.without = array_default_default.without;
wrapperLodash_default.words = string_default_default.words;
wrapperLodash_default.wrap = function_default_default.wrap;
wrapperLodash_default.xor = array_default_default.xor;
wrapperLodash_default.xorBy = array_default_default.xorBy;
wrapperLodash_default.xorWith = array_default_default.xorWith;
wrapperLodash_default.zip = array_default_default.zip;
wrapperLodash_default.zipObject = array_default_default.zipObject;
wrapperLodash_default.zipObjectDeep = array_default_default.zipObjectDeep;
wrapperLodash_default.zipWith = array_default_default.zipWith;
wrapperLodash_default.entries = object_default_default.toPairs;
wrapperLodash_default.entriesIn = object_default_default.toPairsIn;
wrapperLodash_default.extend = object_default_default.assignIn;
wrapperLodash_default.extendWith = object_default_default.assignInWith;
mixin2(wrapperLodash_default, wrapperLodash_default);
wrapperLodash_default.add = math_default_default.add;
wrapperLodash_default.attempt = util_default_default.attempt;
wrapperLodash_default.camelCase = string_default_default.camelCase;
wrapperLodash_default.capitalize = string_default_default.capitalize;
wrapperLodash_default.ceil = math_default_default.ceil;
wrapperLodash_default.clamp = number_default_default.clamp;
wrapperLodash_default.clone = lang_default_default.clone;
wrapperLodash_default.cloneDeep = lang_default_default.cloneDeep;
wrapperLodash_default.cloneDeepWith = lang_default_default.cloneDeepWith;
wrapperLodash_default.cloneWith = lang_default_default.cloneWith;
wrapperLodash_default.conformsTo = lang_default_default.conformsTo;
wrapperLodash_default.deburr = string_default_default.deburr;
wrapperLodash_default.defaultTo = util_default_default.defaultTo;
wrapperLodash_default.divide = math_default_default.divide;
wrapperLodash_default.endsWith = string_default_default.endsWith;
wrapperLodash_default.eq = lang_default_default.eq;
wrapperLodash_default.escape = string_default_default.escape;
wrapperLodash_default.escapeRegExp = string_default_default.escapeRegExp;
wrapperLodash_default.every = collection_default_default.every;
wrapperLodash_default.find = collection_default_default.find;
wrapperLodash_default.findIndex = array_default_default.findIndex;
wrapperLodash_default.findKey = object_default_default.findKey;
wrapperLodash_default.findLast = collection_default_default.findLast;
wrapperLodash_default.findLastIndex = array_default_default.findLastIndex;
wrapperLodash_default.findLastKey = object_default_default.findLastKey;
wrapperLodash_default.floor = math_default_default.floor;
wrapperLodash_default.forEach = collection_default_default.forEach;
wrapperLodash_default.forEachRight = collection_default_default.forEachRight;
wrapperLodash_default.forIn = object_default_default.forIn;
wrapperLodash_default.forInRight = object_default_default.forInRight;
wrapperLodash_default.forOwn = object_default_default.forOwn;
wrapperLodash_default.forOwnRight = object_default_default.forOwnRight;
wrapperLodash_default.get = object_default_default.get;
wrapperLodash_default.gt = lang_default_default.gt;
wrapperLodash_default.gte = lang_default_default.gte;
wrapperLodash_default.has = object_default_default.has;
wrapperLodash_default.hasIn = object_default_default.hasIn;
wrapperLodash_default.head = array_default_default.head;
wrapperLodash_default.identity = identity_default;
wrapperLodash_default.includes = collection_default_default.includes;
wrapperLodash_default.indexOf = array_default_default.indexOf;
wrapperLodash_default.inRange = number_default_default.inRange;
wrapperLodash_default.invoke = object_default_default.invoke;
wrapperLodash_default.isArguments = lang_default_default.isArguments;
wrapperLodash_default.isArray = isArray_default;
wrapperLodash_default.isArrayBuffer = lang_default_default.isArrayBuffer;
wrapperLodash_default.isArrayLike = lang_default_default.isArrayLike;
wrapperLodash_default.isArrayLikeObject = lang_default_default.isArrayLikeObject;
wrapperLodash_default.isBoolean = lang_default_default.isBoolean;
wrapperLodash_default.isBuffer = lang_default_default.isBuffer;
wrapperLodash_default.isDate = lang_default_default.isDate;
wrapperLodash_default.isElement = lang_default_default.isElement;
wrapperLodash_default.isEmpty = lang_default_default.isEmpty;
wrapperLodash_default.isEqual = lang_default_default.isEqual;
wrapperLodash_default.isEqualWith = lang_default_default.isEqualWith;
wrapperLodash_default.isError = lang_default_default.isError;
wrapperLodash_default.isFinite = lang_default_default.isFinite;
wrapperLodash_default.isFunction = lang_default_default.isFunction;
wrapperLodash_default.isInteger = lang_default_default.isInteger;
wrapperLodash_default.isLength = lang_default_default.isLength;
wrapperLodash_default.isMap = lang_default_default.isMap;
wrapperLodash_default.isMatch = lang_default_default.isMatch;
wrapperLodash_default.isMatchWith = lang_default_default.isMatchWith;
wrapperLodash_default.isNaN = lang_default_default.isNaN;
wrapperLodash_default.isNative = lang_default_default.isNative;
wrapperLodash_default.isNil = lang_default_default.isNil;
wrapperLodash_default.isNull = lang_default_default.isNull;
wrapperLodash_default.isNumber = lang_default_default.isNumber;
wrapperLodash_default.isObject = isObject_default;
wrapperLodash_default.isObjectLike = lang_default_default.isObjectLike;
wrapperLodash_default.isPlainObject = lang_default_default.isPlainObject;
wrapperLodash_default.isRegExp = lang_default_default.isRegExp;
wrapperLodash_default.isSafeInteger = lang_default_default.isSafeInteger;
wrapperLodash_default.isSet = lang_default_default.isSet;
wrapperLodash_default.isString = lang_default_default.isString;
wrapperLodash_default.isSymbol = lang_default_default.isSymbol;
wrapperLodash_default.isTypedArray = lang_default_default.isTypedArray;
wrapperLodash_default.isUndefined = lang_default_default.isUndefined;
wrapperLodash_default.isWeakMap = lang_default_default.isWeakMap;
wrapperLodash_default.isWeakSet = lang_default_default.isWeakSet;
wrapperLodash_default.join = array_default_default.join;
wrapperLodash_default.kebabCase = string_default_default.kebabCase;
wrapperLodash_default.last = last_default;
wrapperLodash_default.lastIndexOf = array_default_default.lastIndexOf;
wrapperLodash_default.lowerCase = string_default_default.lowerCase;
wrapperLodash_default.lowerFirst = string_default_default.lowerFirst;
wrapperLodash_default.lt = lang_default_default.lt;
wrapperLodash_default.lte = lang_default_default.lte;
wrapperLodash_default.max = math_default_default.max;
wrapperLodash_default.maxBy = math_default_default.maxBy;
wrapperLodash_default.mean = math_default_default.mean;
wrapperLodash_default.meanBy = math_default_default.meanBy;
wrapperLodash_default.min = math_default_default.min;
wrapperLodash_default.minBy = math_default_default.minBy;
wrapperLodash_default.stubArray = util_default_default.stubArray;
wrapperLodash_default.stubFalse = util_default_default.stubFalse;
wrapperLodash_default.stubObject = util_default_default.stubObject;
wrapperLodash_default.stubString = util_default_default.stubString;
wrapperLodash_default.stubTrue = util_default_default.stubTrue;
wrapperLodash_default.multiply = math_default_default.multiply;
wrapperLodash_default.nth = array_default_default.nth;
wrapperLodash_default.noop = util_default_default.noop;
wrapperLodash_default.now = date_default_default.now;
wrapperLodash_default.pad = string_default_default.pad;
wrapperLodash_default.padEnd = string_default_default.padEnd;
wrapperLodash_default.padStart = string_default_default.padStart;
wrapperLodash_default.parseInt = string_default_default.parseInt;
wrapperLodash_default.random = number_default_default.random;
wrapperLodash_default.reduce = collection_default_default.reduce;
wrapperLodash_default.reduceRight = collection_default_default.reduceRight;
wrapperLodash_default.repeat = string_default_default.repeat;
wrapperLodash_default.replace = string_default_default.replace;
wrapperLodash_default.result = object_default_default.result;
wrapperLodash_default.round = math_default_default.round;
wrapperLodash_default.sample = collection_default_default.sample;
wrapperLodash_default.size = collection_default_default.size;
wrapperLodash_default.snakeCase = string_default_default.snakeCase;
wrapperLodash_default.some = collection_default_default.some;
wrapperLodash_default.sortedIndex = array_default_default.sortedIndex;
wrapperLodash_default.sortedIndexBy = array_default_default.sortedIndexBy;
wrapperLodash_default.sortedIndexOf = array_default_default.sortedIndexOf;
wrapperLodash_default.sortedLastIndex = array_default_default.sortedLastIndex;
wrapperLodash_default.sortedLastIndexBy = array_default_default.sortedLastIndexBy;
wrapperLodash_default.sortedLastIndexOf = array_default_default.sortedLastIndexOf;
wrapperLodash_default.startCase = string_default_default.startCase;
wrapperLodash_default.startsWith = string_default_default.startsWith;
wrapperLodash_default.subtract = math_default_default.subtract;
wrapperLodash_default.sum = math_default_default.sum;
wrapperLodash_default.sumBy = math_default_default.sumBy;
wrapperLodash_default.template = string_default_default.template;
wrapperLodash_default.times = util_default_default.times;
wrapperLodash_default.toFinite = lang_default_default.toFinite;
wrapperLodash_default.toInteger = toInteger_default;
wrapperLodash_default.toLength = lang_default_default.toLength;
wrapperLodash_default.toLower = string_default_default.toLower;
wrapperLodash_default.toNumber = lang_default_default.toNumber;
wrapperLodash_default.toSafeInteger = lang_default_default.toSafeInteger;
wrapperLodash_default.toString = lang_default_default.toString;
wrapperLodash_default.toUpper = string_default_default.toUpper;
wrapperLodash_default.trim = string_default_default.trim;
wrapperLodash_default.trimEnd = string_default_default.trimEnd;
wrapperLodash_default.trimStart = string_default_default.trimStart;
wrapperLodash_default.truncate = string_default_default.truncate;
wrapperLodash_default.unescape = string_default_default.unescape;
wrapperLodash_default.uniqueId = util_default_default.uniqueId;
wrapperLodash_default.upperCase = string_default_default.upperCase;
wrapperLodash_default.upperFirst = string_default_default.upperFirst;
wrapperLodash_default.each = collection_default_default.forEach;
wrapperLodash_default.eachRight = collection_default_default.forEachRight;
wrapperLodash_default.first = array_default_default.head;
mixin2(wrapperLodash_default, function() {
  var source = {};
  baseForOwn_default(wrapperLodash_default, function(func, methodName) {
    if (!hasOwnProperty25.call(wrapperLodash_default.prototype, methodName)) {
      source[methodName] = func;
    }
  });
  return source;
}(), { "chain": false });
wrapperLodash_default.VERSION = VERSION;
(wrapperLodash_default.templateSettings = string_default_default.templateSettings).imports._ = wrapperLodash_default;
arrayEach_default(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
  wrapperLodash_default[methodName].placeholder = wrapperLodash_default;
});
arrayEach_default(["drop", "take"], function(methodName, index2) {
  LazyWrapper_default.prototype[methodName] = function(n) {
    n = n === void 0 ? 1 : nativeMax17(toInteger_default(n), 0);
    var result2 = this.__filtered__ && !index2 ? new LazyWrapper_default(this) : this.clone();
    if (result2.__filtered__) {
      result2.__takeCount__ = nativeMin15(n, result2.__takeCount__);
    } else {
      result2.__views__.push({
        "size": nativeMin15(n, MAX_ARRAY_LENGTH7),
        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
      });
    }
    return result2;
  };
  LazyWrapper_default.prototype[methodName + "Right"] = function(n) {
    return this.reverse()[methodName](n).reverse();
  };
});
arrayEach_default(["filter", "map", "takeWhile"], function(methodName, index2) {
  var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG2 || type == LAZY_WHILE_FLAG;
  LazyWrapper_default.prototype[methodName] = function(iteratee2) {
    var result2 = this.clone();
    result2.__iteratees__.push({
      "iteratee": baseIteratee_default(iteratee2, 3),
      "type": type
    });
    result2.__filtered__ = result2.__filtered__ || isFilter;
    return result2;
  };
});
arrayEach_default(["head", "last"], function(methodName, index2) {
  var takeName = "take" + (index2 ? "Right" : "");
  LazyWrapper_default.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});
arrayEach_default(["initial", "tail"], function(methodName, index2) {
  var dropName = "drop" + (index2 ? "" : "Right");
  LazyWrapper_default.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper_default(this) : this[dropName](1);
  };
});
LazyWrapper_default.prototype.compact = function() {
  return this.filter(identity_default);
};
LazyWrapper_default.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};
LazyWrapper_default.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};
LazyWrapper_default.prototype.invokeMap = baseRest_default(function(path2, args) {
  if (typeof path2 == "function") {
    return new LazyWrapper_default(this);
  }
  return this.map(function(value) {
    return baseInvoke_default(value, path2, args);
  });
});
LazyWrapper_default.prototype.reject = function(predicate) {
  return this.filter(negate_default(baseIteratee_default(predicate)));
};
LazyWrapper_default.prototype.slice = function(start, end) {
  start = toInteger_default(start);
  var result2 = this;
  if (result2.__filtered__ && (start > 0 || end < 0)) {
    return new LazyWrapper_default(result2);
  }
  if (start < 0) {
    result2 = result2.takeRight(-start);
  } else if (start) {
    result2 = result2.drop(start);
  }
  if (end !== void 0) {
    end = toInteger_default(end);
    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
  }
  return result2;
};
LazyWrapper_default.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper_default.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH7);
};
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = wrapperLodash_default[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
  if (!lodashFunc) {
    return;
  }
  wrapperLodash_default.prototype[methodName] = function() {
    var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper_default, iteratee2 = args[0], useLazy = isLazy || isArray_default(value);
    var interceptor = function(value2) {
      var result3 = lodashFunc.apply(wrapperLodash_default, arrayPush_default([value2], args));
      return isTaker && chainAll ? result3[0] : result3;
    };
    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
    if (!retUnwrapped && useLazy) {
      value = onlyLazy ? value : new LazyWrapper_default(this);
      var result2 = func.apply(value, args);
      result2.__actions__.push({ "func": thru_default, "args": [interceptor], "thisArg": void 0 });
      return new LodashWrapper_default(result2, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func.apply(this, args);
    }
    result2 = this.thru(interceptor);
    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
  };
});
arrayEach_default(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
  var func = arrayProto6[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
  wrapperLodash_default.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value = this.value();
      return func.apply(isArray_default(value) ? value : [], args);
    }
    return this[chainName](function(value2) {
      return func.apply(isArray_default(value2) ? value2 : [], args);
    });
  };
});
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var lodashFunc = wrapperLodash_default[methodName];
  if (lodashFunc) {
    var key = lodashFunc.name + "";
    if (!hasOwnProperty25.call(realNames_default, key)) {
      realNames_default[key] = [];
    }
    realNames_default[key].push({ "name": methodName, "func": lodashFunc });
  }
});
realNames_default[createHybrid_default(void 0, WRAP_BIND_KEY_FLAG7).name] = [{
  "name": "wrapper",
  "func": void 0
}];
LazyWrapper_default.prototype.clone = lazyClone_default;
LazyWrapper_default.prototype.reverse = lazyReverse_default;
LazyWrapper_default.prototype.value = lazyValue_default;
wrapperLodash_default.prototype.at = seq_default_default.at;
wrapperLodash_default.prototype.chain = seq_default_default.wrapperChain;
wrapperLodash_default.prototype.commit = seq_default_default.commit;
wrapperLodash_default.prototype.next = seq_default_default.next;
wrapperLodash_default.prototype.plant = seq_default_default.plant;
wrapperLodash_default.prototype.reverse = seq_default_default.reverse;
wrapperLodash_default.prototype.toJSON = wrapperLodash_default.prototype.valueOf = wrapperLodash_default.prototype.value = seq_default_default.value;
wrapperLodash_default.prototype.first = wrapperLodash_default.prototype.head;
if (symIterator2) {
  wrapperLodash_default.prototype[symIterator2] = seq_default_default.toIterator;
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/function/function.js
function apply2(fn, ctx, args) {
  if (args) {
    switch (args.length) {
      case 0:
        return fn.call(ctx);
      case 1:
        return fn.call(ctx, args[0]);
      case 2:
        return fn.call(ctx, args[0], args[1]);
      case 3:
        return fn.call(ctx, args[0], args[1], args[2]);
      case 4:
        return fn.call(ctx, args[0], args[1], args[2], args[3]);
      case 5:
        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4], args[5]);
      default:
        return fn.apply(ctx, args);
    }
  }
  return fn.call(ctx);
}
function call(fn, ctx, ...args) {
  return apply2(fn, ctx, args);
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/function/async.js
function isAsyncLike(obj) {
  return typeof obj === "object" && obj.then && typeof obj.then === "function";
}
function isAsync(obj) {
  return obj != null && (obj instanceof Promise || isAsyncLike(obj));
}
function toAsyncBoolean(...inputs) {
  const results = [];
  inputs.forEach((arg) => {
    if (Array.isArray(arg)) {
      results.push(...arg);
    } else {
      results.push(arg);
    }
  });
  const hasAsync = results.some((res) => isAsync(res));
  if (hasAsync) {
    const deferres = results.map((res) => isAsync(res) ? res : Promise.resolve(res !== false));
    return Promise.all(deferres).then((arr) => arr.reduce((memo, item) => item !== false && memo, true));
  }
  return results.every((res) => res !== false);
}
function toDeferredBoolean(...inputs) {
  const ret = toAsyncBoolean(inputs);
  return typeof ret === "boolean" ? Promise.resolve(ret) : ret;
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/event/util.js
function call2(list, args) {
  const results = [];
  for (let i = 0; i < list.length; i += 2) {
    const handler = list[i];
    const context = list[i + 1];
    const params = Array.isArray(args) ? args : [args];
    const ret = main_exports.apply(handler, context, params);
    results.push(ret);
  }
  return main_exports.toAsyncBoolean(results);
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/event/events.js
var Events = class {
  constructor() {
    this.listeners = {};
  }
  on(name, handler, context) {
    if (handler == null) {
      return this;
    }
    if (!this.listeners[name]) {
      this.listeners[name] = [];
    }
    const cache = this.listeners[name];
    cache.push(handler, context);
    return this;
  }
  once(name, handler, context) {
    const cb = (...args) => {
      this.off(name, cb);
      return call2([handler, context], args);
    };
    return this.on(name, cb, this);
  }
  off(name, handler, context) {
    if (!(name || handler || context)) {
      this.listeners = {};
      return this;
    }
    const listeners = this.listeners;
    const names = name ? [name] : Object.keys(listeners);
    names.forEach((n) => {
      const cache = listeners[n];
      if (!cache) {
        return;
      }
      if (!(handler || context)) {
        delete listeners[n];
        return;
      }
      for (let i = cache.length - 2; i >= 0; i -= 2) {
        if (!(handler && cache[i] !== handler || context && cache[i + 1] !== context)) {
          cache.splice(i, 2);
        }
      }
    });
    return this;
  }
  trigger(name, ...args) {
    let returned = true;
    if (name !== "*") {
      const list2 = this.listeners[name];
      if (list2 != null) {
        returned = call2([...list2], args);
      }
    }
    const list = this.listeners["*"];
    if (list != null) {
      return main_exports.toAsyncBoolean([
        returned,
        call2([...list], [name, ...args])
      ]);
    }
    return returned;
  }
  emit(name, ...args) {
    return this.trigger(name, ...args);
  }
};

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/object/object.js
var object_exports = {};
__export(object_exports, {
  applyMixins: () => applyMixins,
  clone: () => clone_default,
  cloneDeep: () => cloneDeep_default,
  createClass: () => createClass,
  defaults: () => defaults_default,
  defaultsDeep: () => defaultsDeep_default,
  ensure: () => ensure,
  flatten: () => flatten2,
  getBoolean: () => getBoolean,
  getByPath: () => getByPath,
  getNumber: () => getNumber,
  getValue: () => getValue2,
  has: () => has_default,
  inherit: () => inherit,
  isEmpty: () => isEmpty_default,
  isEqual: () => isEqual_default,
  isMaliciousProp: () => isMaliciousProp,
  isObject: () => isObject_default,
  isPlainObject: () => isPlainObject_default,
  merge: () => merge_default,
  pick: () => pick_default,
  setByPath: () => setByPath,
  unsetByPath: () => unsetByPath
});

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/object/mixins.js
function applyMixins(derivedCtor, ...baseCtors) {
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
      if (name !== "constructor") {
        Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
      }
    });
  });
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/object/inherit.js
var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
  d.__proto__ = b;
} || function(d, b) {
  for (const p in b) {
    if (Object.prototype.hasOwnProperty.call(b, p)) {
      d[p] = b[p];
    }
  }
};
function inherit(cls, base) {
  extendStatics(cls, base);
  function tmp() {
    this.constructor = cls;
  }
  cls.prototype = base === null ? Object.create(base) : (tmp.prototype = base.prototype, new tmp());
}
var A = class {
};
var isNativeClass = /^\s*class\s+/.test(`${A}`) || /^\s*class\s*\{/.test(`${class {
}}`);
function createClass(className3, base) {
  let cls;
  if (isNativeClass) {
    cls = class extends base {
    };
  } else {
    cls = function() {
      return base.apply(this, arguments);
    };
    inherit(cls, base);
  }
  Object.defineProperty(cls, "name", { value: className3 });
  return cls;
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/object/object.js
function ensure(value, defaultValue) {
  return value != null ? value : defaultValue;
}
function getValue2(obj, key, defaultValue) {
  const value = obj != null ? obj[key] : null;
  return defaultValue !== void 0 ? ensure(value, defaultValue) : value;
}
function getNumber(obj, key, defaultValue) {
  let value = obj != null ? obj[key] : null;
  if (value == null) {
    return defaultValue;
  }
  value = +value;
  if (Number.isNaN(value) || !Number.isFinite(value)) {
    return defaultValue;
  }
  return value;
}
function getBoolean(obj, key, defaultValue) {
  const value = obj != null ? obj[key] : null;
  if (value == null) {
    return defaultValue;
  }
  return !!value;
}
function isMaliciousProp(prop2) {
  return prop2 === "__proto__";
}
function getByPath(obj, path2, delimiter = "/") {
  let ret;
  const keys2 = Array.isArray(path2) ? path2 : path2.split(delimiter);
  if (keys2.length) {
    ret = obj;
    while (keys2.length) {
      const key = keys2.shift();
      if (Object(ret) === ret && key && key in ret) {
        ret = ret[key];
      } else {
        return void 0;
      }
    }
  }
  return ret;
}
function setByPath(obj, path2, value, delimiter = "/") {
  const keys2 = Array.isArray(path2) ? path2 : path2.split(delimiter);
  const lastKey = keys2.pop();
  if (lastKey && !isMaliciousProp(lastKey)) {
    let diver = obj;
    keys2.forEach((key) => {
      if (!isMaliciousProp(key)) {
        if (diver[key] == null) {
          diver[key] = {};
        }
        diver = diver[key];
      }
    });
    diver[lastKey] = value;
  }
  return obj;
}
function unsetByPath(obj, path2, delimiter = "/") {
  const keys2 = Array.isArray(path2) ? path2.slice() : path2.split(delimiter);
  const propertyToRemove = keys2.pop();
  if (propertyToRemove) {
    if (keys2.length > 0) {
      const parent2 = getByPath(obj, keys2);
      if (parent2) {
        delete parent2[propertyToRemove];
      }
    } else {
      delete obj[propertyToRemove];
    }
  }
  return obj;
}
function flatten2(obj, delim = "/", stop) {
  const ret = {};
  Object.keys(obj).forEach((key) => {
    const val = obj[key];
    let deep = typeof val === "object" || Array.isArray(val);
    if (deep && stop && stop(val)) {
      deep = false;
    }
    if (deep) {
      const flatObject = flatten2(val, delim, stop);
      Object.keys(flatObject).forEach((flatKey) => {
        ret[key + delim + flatKey] = flatObject[flatKey];
      });
    } else {
      ret[key] = val;
    }
  });
  for (const key in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, key)) {
      continue;
    }
  }
  return ret;
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/common/basecoat.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Basecoat = class extends Events {
  dispose() {
    this.off();
  }
};
__decorate([
  Disposable.dispose()
], Basecoat.prototype, "dispose", null);
(function(Basecoat2) {
  Basecoat2.dispose = Disposable.dispose;
})(Basecoat || (Basecoat = {}));
object_exports.applyMixins(Basecoat, Disposable);

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/common/disablable.js
var Disablable = class extends Basecoat {
  get disabled() {
    return this._disabled === true;
  }
  enable() {
    delete this._disabled;
  }
  disable() {
    this._disabled = true;
  }
};

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/array/array.js
var array_exports = {};
__export(array_exports, {
  difference: () => difference_default,
  groupBy: () => groupBy_default,
  max: () => max_default,
  sortBy: () => sortBy_default,
  sortedIndex: () => sortedIndex_default,
  sortedIndexBy: () => sortedIndexBy_default,
  union: () => union_default,
  uniq: () => uniq_default
});

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/string/string.js
var string_exports = {};
__export(string_exports, {
  camelCase: () => camelCase_default,
  constantCase: () => constantCase,
  dotCase: () => dotCase,
  getSpellingSuggestion: () => getSpellingSuggestion,
  hashcode: () => hashcode,
  kebabCase: () => kebabCase2,
  lowerFirst: () => lowerFirst_default,
  pascalCase: () => pascalCase,
  pathCase: () => pathCase,
  sentenceCase: () => sentenceCase,
  titleCase: () => titleCase,
  uniqueId: () => uniqueId_default,
  upperFirst: () => upperFirst_default,
  uuid: () => uuid
});

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/string/format.js
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var kebabCase2 = cacheStringFunction((s) => s.replace(/\B([A-Z])/g, "-$1").toLowerCase());
var pascalCase = cacheStringFunction((s) => startCase_default(camelCase_default(s)).replace(/ /g, ""));
var constantCase = cacheStringFunction((s) => upperCase_default(s).replace(/ /g, "_"));
var dotCase = cacheStringFunction((s) => lowerCase_default(s).replace(/ /g, "."));
var pathCase = cacheStringFunction((s) => lowerCase_default(s).replace(/ /g, "/"));
var sentenceCase = cacheStringFunction((s) => upperFirst_default(lowerCase_default(s)));
var titleCase = cacheStringFunction((s) => startCase_default(camelCase_default(s)));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/string/hashcode.js
function hashcode(str) {
  let hash = 2166136261;
  let isUnicoded = false;
  let string = str;
  for (let i = 0, ii = string.length; i < ii; i += 1) {
    let characterCode = string.charCodeAt(i);
    if (characterCode > 127 && !isUnicoded) {
      string = unescape(encodeURIComponent(string));
      characterCode = string.charCodeAt(i);
      isUnicoded = true;
    }
    hash ^= characterCode;
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
  }
  return hash >>> 0;
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/string/uuid.js
function uuid() {
  let res = "";
  const template2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
  for (let i = 0, len = template2.length; i < len; i += 1) {
    const s = template2[i];
    const r = Math.random() * 16 | 0;
    const v = s === "x" ? r : s === "y" ? r & 3 | 8 : s;
    res += v.toString(16);
  }
  return res;
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/string/suggestion.js
function getSpellingSuggestion(name, candidates, getName) {
  const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34));
  let bestDistance = Math.floor(name.length * 0.4) + 1;
  let bestCandidate;
  let justCheckExactMatches = false;
  const nameLowerCase = name.toLowerCase();
  for (const candidate of candidates) {
    const candidateName = getName(candidate);
    if (candidateName !== void 0 && Math.abs(candidateName.length - nameLowerCase.length) <= maximumLengthDifference) {
      const candidateNameLowerCase = candidateName.toLowerCase();
      if (candidateNameLowerCase === nameLowerCase) {
        if (candidateName === name) {
          continue;
        }
        return candidate;
      }
      if (justCheckExactMatches) {
        continue;
      }
      if (candidateName.length < 3) {
        continue;
      }
      const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);
      if (distance === void 0) {
        continue;
      }
      if (distance < 3) {
        justCheckExactMatches = true;
        bestCandidate = candidate;
      } else {
        bestDistance = distance;
        bestCandidate = candidate;
      }
    }
  }
  return bestCandidate;
}
function levenshteinWithMax(s1, s2, max2) {
  let previous = new Array(s2.length + 1);
  let current = new Array(s2.length + 1);
  const big = max2 + 1;
  for (let i = 0; i <= s2.length; i += 1) {
    previous[i] = i;
  }
  for (let i = 1; i <= s1.length; i += 1) {
    const c1 = s1.charCodeAt(i - 1);
    const minJ = i > max2 ? i - max2 : 1;
    const maxJ = s2.length > max2 + i ? max2 + i : s2.length;
    current[0] = i;
    let colMin = i;
    for (let j = 1; j < minJ; j += 1) {
      current[j] = big;
    }
    for (let j = minJ; j <= maxJ; j += 1) {
      const dist = c1 === s2.charCodeAt(j - 1) ? previous[j - 1] : Math.min(
        /* delete */
        previous[j] + 1,
        /* insert */
        current[j - 1] + 1,
        /* substitute */
        previous[j - 1] + 2
      );
      current[j] = dist;
      colMin = Math.min(colMin, dist);
    }
    for (let j = maxJ + 1; j <= s2.length; j += 1) {
      current[j] = big;
    }
    if (colMin > max2) {
      return void 0;
    }
    const temp = previous;
    previous = current;
    current = temp;
  }
  const res = previous[s2.length];
  return res > max2 ? void 0 : res;
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/number/number.js
var number_exports = {};
__export(number_exports, {
  clamp: () => clamp_default,
  isNumber: () => isNumber_default,
  isPercentage: () => isPercentage,
  mod: () => mod,
  normalizePercentage: () => normalizePercentage,
  normalizeSides: () => normalizeSides,
  parseCssNumeric: () => parseCssNumeric,
  random: () => random2
});
function mod(n, m) {
  return (n % m + m) % m;
}
function random2(lower, upper) {
  if (upper == null) {
    upper = lower == null ? 1 : lower;
    lower = 0;
  } else if (upper < lower) {
    const tmp = lower;
    lower = upper;
    upper = tmp;
  }
  return Math.floor(Math.random() * (upper - lower + 1) + lower);
}
function isPercentage(val) {
  return typeof val === "string" && val.slice(-1) === "%";
}
function normalizePercentage(num, ref2) {
  if (num == null) {
    return 0;
  }
  let raw2;
  if (typeof num === "string") {
    raw2 = parseFloat(num);
    if (isPercentage(num)) {
      raw2 /= 100;
      if (Number.isFinite(raw2)) {
        return raw2 * ref2;
      }
    }
  } else {
    raw2 = num;
  }
  if (!Number.isFinite(raw2)) {
    return 0;
  }
  if (raw2 > 0 && raw2 < 1) {
    return raw2 * ref2;
  }
  return raw2;
}
function parseCssNumeric(val, units) {
  function getUnit(regexp2) {
    const matches2 = new RegExp(`(?:\\d+(?:\\.\\d+)*)(${regexp2})$`).exec(val);
    if (!matches2) {
      return null;
    }
    return matches2[1];
  }
  const number = parseFloat(val);
  if (Number.isNaN(number)) {
    return null;
  }
  let regexp;
  if (units == null) {
    regexp = "[A-Za-z]*";
  } else if (Array.isArray(units)) {
    if (units.length === 0) {
      return null;
    }
    regexp = units.join("|");
  } else if (typeof units === "string") {
    regexp = units;
  }
  const unit = getUnit(regexp);
  if (unit === null) {
    return null;
  }
  return {
    unit,
    value: number
  };
}
function normalizeSides(box) {
  if (typeof box === "object") {
    let left4 = 0;
    let top4 = 0;
    let right4 = 0;
    let bottom4 = 0;
    if (box.vertical != null && Number.isFinite(box.vertical)) {
      top4 = bottom4 = box.vertical;
    }
    if (box.horizontal != null && Number.isFinite(box.horizontal)) {
      right4 = left4 = box.horizontal;
    }
    if (box.left != null && Number.isFinite(box.left))
      left4 = box.left;
    if (box.top != null && Number.isFinite(box.top))
      top4 = box.top;
    if (box.right != null && Number.isFinite(box.right))
      right4 = box.right;
    if (box.bottom != null && Number.isFinite(box.bottom))
      bottom4 = box.bottom;
    return { top: top4, right: right4, bottom: bottom4, left: left4 };
  }
  let val = 0;
  if (box != null && Number.isFinite(box)) {
    val = box;
  }
  return { top: val, right: val, bottom: val, left: val };
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/platform/index.js
var _IS_MAC = false;
var _IS_IOS = false;
var _IS_WINDOWS = false;
var _IS_IE = false;
var _IS_IE11 = false;
var _IS_EDGE = false;
var _IS_NETSCAPE = false;
var _IS_CHROME_APP = false;
var _IS_CHROME = false;
var _IS_OPERA = false;
var _IS_FIREFOX = false;
var _IS_SAFARI = false;
var _SUPPORT_TOUCH = false;
var _SUPPORT_POINTER = false;
var _SUPPORT_PASSIVE = false;
var _NO_FOREIGNOBJECT = false;
if (typeof navigator === "object") {
  const ua = navigator.userAgent;
  _IS_MAC = ua.indexOf("Macintosh") >= 0;
  _IS_IOS = !!ua.match(/(iPad|iPhone|iPod)/g);
  _IS_WINDOWS = ua.indexOf("Windows") >= 0;
  _IS_IE = ua.indexOf("MSIE") >= 0;
  _IS_IE11 = !!ua.match(/Trident\/7\./);
  _IS_EDGE = !!ua.match(/Edge\//);
  _IS_NETSCAPE = ua.indexOf("Mozilla/") >= 0 && ua.indexOf("MSIE") < 0 && ua.indexOf("Edge/") < 0;
  _IS_CHROME = ua.indexOf("Chrome/") >= 0 && ua.indexOf("Edge/") < 0;
  _IS_OPERA = ua.indexOf("Opera/") >= 0 || ua.indexOf("OPR/") >= 0;
  _IS_FIREFOX = ua.indexOf("Firefox/") >= 0;
  _IS_SAFARI = ua.indexOf("AppleWebKit/") >= 0 && ua.indexOf("Chrome/") < 0 && ua.indexOf("Edge/") < 0;
  if (typeof document === "object") {
    _NO_FOREIGNOBJECT = !document.createElementNS || `${document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")}` !== "[object SVGForeignObjectElement]" || ua.indexOf("Opera/") >= 0;
  }
}
if (typeof window === "object") {
  _IS_CHROME_APP = window.chrome != null && window.chrome.app != null && window.chrome.app.runtime != null;
  _SUPPORT_POINTER = window.PointerEvent != null && !_IS_MAC;
}
if (typeof document === "object") {
  _SUPPORT_TOUCH = "ontouchstart" in document.documentElement;
  try {
    const options = Object.defineProperty({}, "passive", {
      get() {
        _SUPPORT_PASSIVE = true;
      }
    });
    const div = document.createElement("div");
    if (div.addEventListener) {
      div.addEventListener("click", () => {
      }, options);
    }
  } catch (err) {
  }
}
var Platform;
(function(Platform2) {
  Platform2.IS_MAC = _IS_MAC;
  Platform2.IS_IOS = _IS_IOS;
  Platform2.IS_WINDOWS = _IS_WINDOWS;
  Platform2.IS_IE = _IS_IE;
  Platform2.IS_IE11 = _IS_IE11;
  Platform2.IS_EDGE = _IS_EDGE;
  Platform2.IS_NETSCAPE = _IS_NETSCAPE;
  Platform2.IS_CHROME_APP = _IS_CHROME_APP;
  Platform2.IS_CHROME = _IS_CHROME;
  Platform2.IS_OPERA = _IS_OPERA;
  Platform2.IS_FIREFOX = _IS_FIREFOX;
  Platform2.IS_SAFARI = _IS_SAFARI;
  Platform2.SUPPORT_TOUCH = _SUPPORT_TOUCH;
  Platform2.SUPPORT_POINTER = _SUPPORT_POINTER;
  Platform2.SUPPORT_PASSIVE = _SUPPORT_PASSIVE;
  Platform2.NO_FOREIGNOBJECT = _NO_FOREIGNOBJECT;
  Platform2.SUPPORT_FOREIGNOBJECT = !Platform2.NO_FOREIGNOBJECT;
})(Platform || (Platform = {}));
(function(Platform2) {
  function getHMRStatus() {
    const mod3 = window.module;
    if (mod3 != null && mod3.hot != null && mod3.hot.status != null) {
      return mod3.hot.status();
    }
    return "unkonwn";
  }
  Platform2.getHMRStatus = getHMRStatus;
  function isApplyingHMR() {
    return getHMRStatus() === "apply";
  }
  Platform2.isApplyingHMR = isApplyingHMR;
  const TAGNAMES = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  function isEventSupported(event) {
    const elem = document.createElement(TAGNAMES[event] || "div");
    const eventName = `on${event}`;
    let isSupported = eventName in elem;
    if (!isSupported) {
      elem.setAttribute(eventName, "return;");
      isSupported = typeof elem[eventName] === "function";
    }
    return isSupported;
  }
  Platform2.isEventSupported = isEventSupported;
})(Platform || (Platform = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/text/main.js
var main_exports2 = {};
__export(main_exports2, {
  annotate: () => annotate,
  findAnnotationsAtIndex: () => findAnnotationsAtIndex,
  findAnnotationsBetweenIndexes: () => findAnnotationsBetweenIndexes,
  sanitize: () => sanitize,
  shiftAnnotations: () => shiftAnnotations
});

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/class.js
var rclass = /[\t\r\n\f]/g;
var rnotwhite = /\S+/g;
var fillSpaces = (str) => ` ${str} `;
function getClass(elem) {
  return elem && elem.getAttribute && elem.getAttribute("class") || "";
}
function hasClass(elem, selector) {
  if (elem == null || selector == null) {
    return false;
  }
  const classNames = fillSpaces(getClass(elem));
  const className3 = fillSpaces(selector);
  return elem.nodeType === 1 ? classNames.replace(rclass, " ").includes(className3) : false;
}
function addClass(elem, selector) {
  if (elem == null || selector == null) {
    return;
  }
  if (typeof selector === "function") {
    return addClass(elem, selector(getClass(elem)));
  }
  if (typeof selector === "string" && elem.nodeType === 1) {
    const classes = selector.match(rnotwhite) || [];
    const oldValue = fillSpaces(getClass(elem)).replace(rclass, " ");
    let newValue = classes.reduce((memo, cls) => {
      if (memo.indexOf(fillSpaces(cls)) < 0) {
        return `${memo}${cls} `;
      }
      return memo;
    }, oldValue);
    newValue = newValue.trim();
    if (oldValue !== newValue) {
      elem.setAttribute("class", newValue);
    }
  }
}
function removeClass(elem, selector) {
  if (elem == null) {
    return;
  }
  if (typeof selector === "function") {
    return removeClass(elem, selector(getClass(elem)));
  }
  if ((!selector || typeof selector === "string") && elem.nodeType === 1) {
    const classes = (selector || "").match(rnotwhite) || [];
    const oldValue = fillSpaces(getClass(elem)).replace(rclass, " ");
    let newValue = classes.reduce((memo, cls) => {
      const className3 = fillSpaces(cls);
      if (memo.indexOf(className3) > -1) {
        return memo.replace(className3, " ");
      }
      return memo;
    }, oldValue);
    newValue = selector ? newValue.trim() : "";
    if (oldValue !== newValue) {
      elem.setAttribute("class", newValue);
    }
  }
}
function toggleClass(elem, selector, stateVal) {
  if (elem == null || selector == null) {
    return;
  }
  if (stateVal != null && typeof selector === "string") {
    stateVal ? addClass(elem, selector) : removeClass(elem, selector);
    return;
  }
  if (typeof selector === "function") {
    return toggleClass(elem, selector(getClass(elem), stateVal), stateVal);
  }
  if (typeof selector === "string") {
    const metches = selector.match(rnotwhite) || [];
    metches.forEach((cls) => {
      hasClass(elem, cls) ? removeClass(elem, cls) : addClass(elem, cls);
    });
  }
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/elem.js
var idCounter2 = 0;
function uniqueId2() {
  idCounter2 += 1;
  return `v${idCounter2}`;
}
function ensureId(elem) {
  if (elem.id == null || elem.id === "") {
    elem.id = uniqueId2();
  }
  return elem.id;
}
function isSVGGraphicsElement(elem) {
  if (elem == null) {
    return false;
  }
  return typeof elem.getScreenCTM === "function" && elem instanceof SVGElement;
}
var ns = {
  svg: "http://www.w3.org/2000/svg",
  xmlns: "http://www.w3.org/2000/xmlns/",
  xml: "http://www.w3.org/XML/1998/namespace",
  xlink: "http://www.w3.org/1999/xlink",
  xhtml: "http://www.w3.org/1999/xhtml"
};
var svgVersion = "1.1";
function createElement(tagName2, doc = document) {
  return doc.createElement(tagName2);
}
function createElementNS(tagName2, namespaceURI = ns.xhtml, doc = document) {
  return doc.createElementNS(namespaceURI, tagName2);
}
function createSvgElement(tagName2, doc = document) {
  return createElementNS(tagName2, ns.svg, doc);
}
function createSvgDocument(content2) {
  if (content2) {
    const xml = `<svg xmlns="${ns.svg}" xmlns:xlink="${ns.xlink}" version="${svgVersion}">${content2}</svg>`;
    const { documentElement } = parseXML(xml, { async: false });
    return documentElement;
  }
  const svg = document.createElementNS(ns.svg, "svg");
  svg.setAttributeNS(ns.xmlns, "xmlns:xlink", ns.xlink);
  svg.setAttribute("version", svgVersion);
  return svg;
}
function parseXML(data2, options = {}) {
  let xml;
  try {
    const parser = new DOMParser();
    if (options.async != null) {
      const instance = parser;
      instance.async = options.async;
    }
    xml = parser.parseFromString(data2, options.mimeType || "text/xml");
  } catch (error) {
    xml = void 0;
  }
  if (!xml || xml.getElementsByTagName("parsererror").length) {
    throw new Error(`Invalid XML: ${data2}`);
  }
  return xml;
}
function tagName(node, lowercase = true) {
  const nodeName = node.nodeName;
  return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();
}
function index(elem) {
  let index2 = 0;
  let node = elem.previousSibling;
  while (node) {
    if (node.nodeType === 1) {
      index2 += 1;
    }
    node = node.previousSibling;
  }
  return index2;
}
function find2(elem, selector) {
  return elem.querySelectorAll(selector);
}
function findOne(elem, selector) {
  return elem.querySelector(selector);
}
function findParentByClass(elem, className3, terminator) {
  const ownerSVGElement = elem.ownerSVGElement;
  let node = elem.parentNode;
  while (node && node !== terminator && node !== ownerSVGElement) {
    if (hasClass(node, className3)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
}
function contains(parent2, child) {
  const bup = child && child.parentNode;
  return parent2 === bup || !!(bup && bup.nodeType === 1 && parent2.compareDocumentPosition(bup) & 16);
}
function remove2(elem) {
  if (elem) {
    const elems = Array.isArray(elem) ? elem : [elem];
    elems.forEach((item) => {
      if (item.parentNode) {
        item.parentNode.removeChild(item);
      }
    });
  }
}
function empty(elem) {
  while (elem.firstChild) {
    elem.removeChild(elem.firstChild);
  }
}
function append(elem, elems) {
  const arr = Array.isArray(elems) ? elems : [elems];
  arr.forEach((child) => {
    if (child != null) {
      elem.appendChild(child);
    }
  });
}
function prepend(elem, elems) {
  const child = elem.firstChild;
  return child ? before2(child, elems) : append(elem, elems);
}
function before2(elem, elems) {
  const parent2 = elem.parentNode;
  if (parent2) {
    const arr = Array.isArray(elems) ? elems : [elems];
    arr.forEach((child) => {
      if (child != null) {
        parent2.insertBefore(child, elem);
      }
    });
  }
}
function after2(elem, elems) {
  const parent2 = elem.parentNode;
  if (parent2) {
    const arr = Array.isArray(elems) ? elems : [elems];
    arr.forEach((child) => {
      if (child != null) {
        parent2.insertBefore(child, elem.nextSibling);
      }
    });
  }
}
function appendTo(elem, target) {
  if (target != null) {
    target.appendChild(elem);
  }
}
function isElement2(x) {
  return !!x && x.nodeType === 1;
}
function isHTMLElement(elem) {
  try {
    return elem instanceof HTMLElement;
  } catch (e) {
    return typeof elem === "object" && elem.nodeType === 1 && typeof elem.style === "object" && typeof elem.ownerDocument === "object";
  }
}
function children(parent2, className3) {
  const matched = [];
  let elem = parent2.firstChild;
  for (; elem; elem = elem.nextSibling) {
    if (elem.nodeType === 1) {
      if (!className3 || hasClass(elem, className3)) {
        matched.push(elem);
      }
    }
  }
  return matched;
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/attr.js
var CASE_SENSITIVE_ATTR = [
  "viewBox",
  "attributeName",
  "attributeType",
  "repeatCount",
  "textLength",
  "lengthAdjust",
  "gradientUnits"
];
function getAttribute(elem, name) {
  return elem.getAttribute(name);
}
function removeAttribute(elem, name) {
  const qualified = qualifyAttr(name);
  if (qualified.ns) {
    if (elem.hasAttributeNS(qualified.ns, qualified.local)) {
      elem.removeAttributeNS(qualified.ns, qualified.local);
    }
  } else if (elem.hasAttribute(name)) {
    elem.removeAttribute(name);
  }
}
function setAttribute(elem, name, value) {
  if (value == null) {
    return removeAttribute(elem, name);
  }
  const qualified = qualifyAttr(name);
  if (qualified.ns && typeof value === "string") {
    elem.setAttributeNS(qualified.ns, name, value);
  } else if (name === "id") {
    elem.id = `${value}`;
  } else {
    elem.setAttribute(name, `${value}`);
  }
}
function setAttributes(elem, attrs) {
  Object.keys(attrs).forEach((name) => {
    setAttribute(elem, name, attrs[name]);
  });
}
function attr(elem, name, value) {
  if (name == null) {
    const attrs = elem.attributes;
    const ret = {};
    for (let i = 0; i < attrs.length; i += 1) {
      ret[attrs[i].name] = attrs[i].value;
    }
    return ret;
  }
  if (typeof name === "string" && value === void 0) {
    return elem.getAttribute(name);
  }
  if (typeof name === "object") {
    setAttributes(elem, name);
  } else {
    setAttribute(elem, name, value);
  }
}
function qualifyAttr(name) {
  if (name.indexOf(":") !== -1) {
    const combinedKey = name.split(":");
    return {
      ns: ns[combinedKey[0]],
      local: combinedKey[1]
    };
  }
  return {
    ns: null,
    local: name
  };
}
function kebablizeAttrs(attrs) {
  const result2 = {};
  Object.keys(attrs).forEach((key) => {
    const name = CASE_SENSITIVE_ATTR.includes(key) ? key : kebabCase2(key);
    result2[name] = attrs[key];
  });
  return result2;
}
function styleToObject(styleString) {
  const ret = {};
  const styles = styleString.split(";");
  styles.forEach((item) => {
    const section = item.trim();
    if (section) {
      const pair = section.split("=");
      if (pair.length) {
        ret[pair[0].trim()] = pair[1] ? pair[1].trim() : "";
      }
    }
  });
  return ret;
}
function mergeAttrs(target, source) {
  Object.keys(source).forEach((attr2) => {
    if (attr2 === "class") {
      target[attr2] = target[attr2] ? `${target[attr2]} ${source[attr2]}` : source[attr2];
    } else if (attr2 === "style") {
      const to = typeof target[attr2] === "object";
      const so = typeof source[attr2] === "object";
      let tt;
      let ss;
      if (to && so) {
        tt = target[attr2];
        ss = source[attr2];
      } else if (to) {
        tt = target[attr2];
        ss = styleToObject(source[attr2]);
      } else if (so) {
        tt = styleToObject(target[attr2]);
        ss = source[attr2];
      } else {
        tt = styleToObject(target[attr2]);
        ss = styleToObject(source[attr2]);
      }
      target[attr2] = mergeAttrs(tt, ss);
    } else {
      target[attr2] = source[attr2];
    }
  });
  return target;
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/text/annotate.js
function annotate(t, annotations2, opt = {}) {
  const offset3 = opt.offset || 0;
  const compacted = [];
  const ret = [];
  let curr;
  let prev;
  let batch = null;
  for (let i = 0; i < t.length; i += 1) {
    curr = ret[i] = t[i];
    for (let j = 0, jj = annotations2.length; j < jj; j += 1) {
      const annotation = annotations2[j];
      const start = annotation.start + offset3;
      const end = annotation.end + offset3;
      if (i >= start && i < end) {
        if (typeof curr === "string") {
          curr = ret[i] = {
            t: t[i],
            attrs: annotation.attrs
          };
        } else {
          curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs);
        }
        if (opt.includeAnnotationIndices) {
          if (curr.annotations == null) {
            curr.annotations = [];
          }
          curr.annotations.push(j);
        }
      }
    }
    prev = ret[i - 1];
    if (!prev) {
      batch = curr;
    } else if (object_exports.isObject(curr) && object_exports.isObject(prev)) {
      batch = batch;
      if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {
        batch.t += curr.t;
      } else {
        compacted.push(batch);
        batch = curr;
      }
    } else if (object_exports.isObject(curr)) {
      batch = batch;
      compacted.push(batch);
      batch = curr;
    } else if (object_exports.isObject(prev)) {
      batch = batch;
      compacted.push(batch);
      batch = curr;
    } else {
      batch = (batch || "") + curr;
    }
  }
  if (batch != null) {
    compacted.push(batch);
  }
  return compacted;
}
function findAnnotationsAtIndex(annotations2, index2) {
  return annotations2 ? annotations2.filter((a) => a.start < index2 && index2 <= a.end) : [];
}
function findAnnotationsBetweenIndexes(annotations2, start, end) {
  return annotations2 ? annotations2.filter((a) => start >= a.start && start < a.end || end > a.start && end <= a.end || a.start >= start && a.end < end) : [];
}
function shiftAnnotations(annotations2, index2, offset3) {
  if (annotations2) {
    annotations2.forEach((a) => {
      if (a.start < index2 && a.end >= index2) {
        a.end += offset3;
      } else if (a.start >= index2) {
        a.start += offset3;
        a.end += offset3;
      }
    });
  }
  return annotations2;
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/text/sanitize.js
function sanitize(text3) {
  return text3.replace(/ /g, "");
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/datauri/index.js
var DataUri;
(function(DataUri2) {
  function isDataUrl(url) {
    const prefix = "data:";
    return url.substr(0, prefix.length) === prefix;
  }
  DataUri2.isDataUrl = isDataUrl;
  function imageToDataUri(url, callback) {
    if (!url || isDataUrl(url)) {
      setTimeout(() => callback(null, url));
      return;
    }
    const onError = () => {
      callback(new Error(`Failed to load image: ${url}`));
    };
    const onLoad = window.FileReader ? (
      // chrome, IE10+
      (xhr2) => {
        if (xhr2.status === 200) {
          const reader = new FileReader();
          reader.onload = (evt) => {
            const dataUri = evt.target.result;
            callback(null, dataUri);
          };
          reader.onerror = onError;
          reader.readAsDataURL(xhr2.response);
        } else {
          onError();
        }
      }
    ) : (xhr2) => {
      const toString2 = (u8a) => {
        const CHUNK_SZ = 32768;
        const c = [];
        for (let i = 0; i < u8a.length; i += CHUNK_SZ) {
          c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
        }
        return c.join("");
      };
      if (xhr2.status === 200) {
        let suffix = url.split(".").pop() || "png";
        if (suffix === "svg") {
          suffix = "svg+xml";
        }
        const meta = `data:image/${suffix};base64,`;
        const bytes = new Uint8Array(xhr2.response);
        const base64 = meta + btoa(toString2(bytes));
        callback(null, base64);
      } else {
        onError();
      }
    };
    const xhr = new XMLHttpRequest();
    xhr.responseType = window.FileReader ? "blob" : "arraybuffer";
    xhr.open("GET", url, true);
    xhr.addEventListener("error", onError);
    xhr.addEventListener("load", () => onLoad(xhr));
    xhr.send();
  }
  DataUri2.imageToDataUri = imageToDataUri;
  function dataUriToBlob(dataUrl) {
    let uri = dataUrl.replace(/\s/g, "");
    uri = decodeURIComponent(uri);
    const index2 = uri.indexOf(",");
    const dataType = uri.slice(0, index2);
    const mime = dataType.split(":")[1].split(";")[0];
    const data2 = uri.slice(index2 + 1);
    let decodedString;
    if (dataType.indexOf("base64") >= 0) {
      decodedString = atob(data2);
    } else {
      decodedString = unescape(encodeURIComponent(data2));
    }
    const ia = new Uint8Array(decodedString.length);
    for (let i = 0; i < decodedString.length; i += 1) {
      ia[i] = decodedString.charCodeAt(i);
    }
    return new Blob([ia], { type: mime });
  }
  DataUri2.dataUriToBlob = dataUriToBlob;
  function downloadBlob(blob, fileName) {
    const msSaveBlob = window.navigator.msSaveBlob;
    if (msSaveBlob) {
      msSaveBlob(blob, fileName);
    } else {
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    }
  }
  DataUri2.downloadBlob = downloadBlob;
  function downloadDataUri(dataUrl, fileName) {
    const blob = dataUriToBlob(dataUrl);
    downloadBlob(blob, fileName);
  }
  DataUri2.downloadDataUri = downloadDataUri;
  function parseViewBox(svg) {
    const matches2 = svg.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    if (matches2 && matches2[2]) {
      return matches2[2].replace(/\s+/, " ").split(" ");
    }
    return null;
  }
  function getNumber3(str) {
    const ret = parseFloat(str);
    return Number.isNaN(ret) ? null : ret;
  }
  function svgToDataUrl(svg, options = {}) {
    let viewBox = null;
    const getNumberFromViewBox = (index2) => {
      if (viewBox == null) {
        viewBox = parseViewBox(svg);
      }
      if (viewBox != null) {
        return getNumber3(viewBox[index2]);
      }
      return null;
    };
    const getNumberFromMatches = (reg) => {
      const matches2 = svg.match(reg);
      if (matches2 && matches2[2]) {
        return getNumber3(matches2[2]);
      }
      return null;
    };
    let w = options.width;
    if (w == null) {
      w = getNumberFromMatches(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    }
    if (w == null) {
      w = getNumberFromViewBox(2);
    }
    if (w == null) {
      throw new Error("Can not parse width from svg string");
    }
    let h = options.height;
    if (h == null) {
      h = getNumberFromMatches(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    }
    if (h == null) {
      h = getNumberFromViewBox(3);
    }
    if (h == null) {
      throw new Error("Can not parse height from svg string");
    }
    const decoded = encodeURIComponent(svg).replace(/'/g, "%27").replace(/"/g, "%22");
    const header = "data:image/svg+xml";
    const dataUrl = `${header},${decoded}`;
    return dataUrl;
  }
  DataUri2.svgToDataUrl = svgToDataUrl;
})(DataUri || (DataUri = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/unit/index.js
var millimeterSize;
var supportedUnits = {
  px(val) {
    return val;
  },
  mm(val) {
    return millimeterSize * val;
  },
  cm(val) {
    return millimeterSize * val * 10;
  },
  in(val) {
    return millimeterSize * val * 25.4;
  },
  pt(val) {
    return millimeterSize * (25.4 * val / 72);
  },
  pc(val) {
    return millimeterSize * (25.4 * val / 6);
  }
};
var Unit;
(function(Unit2) {
  function measure(cssWidth, cssHeight, unit) {
    const div = document.createElement("div");
    const style2 = div.style;
    style2.display = "inline-block";
    style2.position = "absolute";
    style2.left = "-15000px";
    style2.top = "-15000px";
    style2.width = cssWidth + (unit || "px");
    style2.height = cssHeight + (unit || "px");
    document.body.appendChild(div);
    const rect2 = div.getBoundingClientRect();
    const size2 = {
      width: rect2.width || 0,
      height: rect2.height || 0
    };
    document.body.removeChild(div);
    return size2;
  }
  Unit2.measure = measure;
  function toPx(val, unit) {
    if (millimeterSize == null) {
      millimeterSize = measure("1", "1", "mm").width;
    }
    const convert = unit ? supportedUnits[unit] : null;
    if (convert) {
      return convert(val);
    }
    return val;
  }
  Unit2.toPx = toPx;
})(Unit || (Unit = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/main.js
var main_exports3 = {};
__export(main_exports3, {
  CASE_SENSITIVE_ATTR: () => CASE_SENSITIVE_ATTR,
  Event: () => Event,
  EventHook: () => EventHook,
  EventObject: () => EventObject,
  KAPPA: () => KAPPA,
  MouseWheelHandle: () => MouseWheelHandle,
  addClass: () => addClass,
  after: () => after2,
  append: () => append,
  appendTo: () => appendTo,
  attr: () => attr,
  before: () => before2,
  breakText: () => breakText,
  children: () => children,
  circleToPathData: () => circleToPathData,
  clearSelection: () => clearSelection,
  computeStyle: () => computeStyle,
  computeStyleInt: () => computeStyleInt,
  contains: () => contains,
  createElement: () => createElement,
  createElementNS: () => createElementNS,
  createSVGMatrix: () => createSVGMatrix,
  createSVGPoint: () => createSVGPoint,
  createSVGTransform: () => createSVGTransform,
  createSlicePathData: () => createSlicePathData,
  createSvgDocument: () => createSvgDocument,
  createSvgElement: () => createSvgElement,
  css: () => css,
  data: () => data,
  decomposeMatrix: () => decomposeMatrix,
  ellipseToPathData: () => ellipseToPathData,
  empty: () => empty,
  ensureId: () => ensureId,
  find: () => find2,
  findOne: () => findOne,
  findParentByClass: () => findParentByClass,
  getAttribute: () => getAttribute,
  getClass: () => getClass,
  getComputedStyle: () => getComputedStyle2,
  getData: () => getData2,
  getPointsFromSvgElement: () => getPointsFromSvgElement,
  getTransformToElement: () => getTransformToElement,
  getTransformToParentElement: () => getTransformToParentElement,
  getVendorPrefixedName: () => getVendorPrefixedName,
  hasClass: () => hasClass,
  hasScrollbars: () => hasScrollbars,
  height: () => height,
  index: () => index,
  isCSSVariable: () => isCSSVariable,
  isElement: () => isElement2,
  isHTMLElement: () => isHTMLElement,
  isSVGGraphicsElement: () => isSVGGraphicsElement,
  kebablizeAttrs: () => kebablizeAttrs,
  lineToPathData: () => lineToPathData,
  matrixToRotation: () => matrixToRotation,
  matrixToScale: () => matrixToScale,
  matrixToTransformString: () => matrixToTransformString,
  matrixToTranslation: () => matrixToTranslation,
  measureText: () => measureText,
  mergeAttrs: () => mergeAttrs,
  ns: () => ns,
  offset: () => offset,
  parseTransformString: () => parseTransformString,
  parseXML: () => parseXML,
  polygonToPathData: () => polygonToPathData,
  polylineToPathData: () => polylineToPathData,
  position: () => position,
  prepend: () => prepend,
  prop: () => prop,
  qualifyAttr: () => qualifyAttr,
  rectToPathData: () => rectToPathData,
  rectangleToPathData: () => rectangleToPathData,
  remove: () => remove2,
  removeAttribute: () => removeAttribute,
  removeClass: () => removeClass,
  rotate: () => rotate,
  sample: () => sample2,
  scale: () => scale,
  setAttribute: () => setAttribute,
  setAttributes: () => setAttributes,
  setData: () => setData2,
  setPrefixedStyle: () => setPrefixedStyle,
  splitTextByLength: () => splitTextByLength,
  styleToObject: () => styleToObject,
  svgVersion: () => svgVersion,
  tagName: () => tagName,
  text: () => text,
  toLocalPoint: () => toLocalPoint,
  toPath: () => toPath2,
  toPathData: () => toPathData,
  toggleClass: () => toggleClass,
  transform: () => transform2,
  transformStringToMatrix: () => transformStringToMatrix,
  translate: () => translate,
  uniqueId: () => uniqueId2,
  width: () => width
});

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/prefix.js
var hyphenPattern = /-(.)/g;
function camelize(str) {
  return str.replace(hyphenPattern, (_, char) => char.toUpperCase());
}
var memoized = {};
var prefixes = ["webkit", "ms", "moz", "o"];
var testStyle = typeof document !== "undefined" ? document.createElement("div").style : {};
function getWithPrefix(name) {
  for (let i = 0; i < prefixes.length; i += 1) {
    const prefixedName = prefixes[i] + name;
    if (prefixedName in testStyle) {
      return prefixedName;
    }
  }
  return null;
}
function getVendorPrefixedName(property2) {
  const name = camelize(property2);
  if (memoized[name] == null) {
    const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
    memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
  }
  return memoized[name];
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/style.js
function setPrefixedStyle(style2, name, value) {
  const vendor = getVendorPrefixedName(name);
  if (vendor != null) {
    style2[vendor] = value;
  }
  style2[name] = value;
}
function getComputedStyle2(elem, name) {
  const computed = elem.ownerDocument && elem.ownerDocument.defaultView && elem.ownerDocument.defaultView.opener ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : window.getComputedStyle(elem, null);
  if (computed && name) {
    return computed.getPropertyValue(name) || computed[name];
  }
  return computed;
}
function hasScrollbars(container) {
  const style2 = getComputedStyle2(container);
  return style2 != null && (style2.overflow === "scroll" || style2.overflow === "auto");
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/selection.js
var clearSelection = function() {
  if (typeof document == "undefined")
    return function() {
    };
  const doc = document;
  if (doc.selection) {
    return function() {
      doc.selection.empty();
    };
  }
  if (window.getSelection) {
    return function() {
      const selection = window.getSelection();
      if (selection) {
        if (selection.empty) {
          selection.empty();
        } else if (selection.removeAllRanges) {
          selection.removeAllRanges();
        }
      }
    };
  }
  return function() {
  };
}();

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/css.js
var numericProps = {
  animationIterationCount: true,
  columnCount: true,
  flexGrow: true,
  flexShrink: true,
  fontWeight: true,
  gridArea: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnStart: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowStart: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  widows: true,
  zIndex: true
};
function isCSSVariable(prop2) {
  return /^--/.test(prop2);
}
function computeStyle(elem, prop2, isVariable) {
  const style2 = window.getComputedStyle(elem, null);
  return isVariable ? style2.getPropertyValue(prop2) || void 0 : style2[prop2] || elem.style[prop2];
}
function computeStyleInt(elem, prop2) {
  return parseInt(computeStyle(elem, prop2), 10) || 0;
}
function getSuffixedValue(prop2, value) {
  return !numericProps[prop2] && typeof value === "number" ? `${value}px` : value;
}
function css(elem, prop2, value) {
  if (typeof prop2 === "string") {
    const isVariable = isCSSVariable(prop2);
    if (!isVariable) {
      prop2 = getVendorPrefixedName(prop2);
    }
    if (value === void 0) {
      return computeStyle(elem, prop2, isVariable);
    }
    if (!isVariable) {
      value = getSuffixedValue(prop2, value);
    }
    const style2 = elem.style;
    if (isVariable) {
      style2.setProperty(prop2, value);
    } else {
      style2[prop2] = value;
    }
    return;
  }
  for (const key in prop2) {
    css(elem, key, prop2[key]);
  }
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/data.js
var dataset = /* @__PURE__ */ new WeakMap();
function getData2(elem, name) {
  const key = string_exports.camelCase(name);
  const cache = dataset.get(elem);
  if (cache) {
    return cache[key];
  }
}
function setData2(elem, name, value) {
  const key = string_exports.camelCase(name);
  const cache = dataset.get(elem);
  if (cache) {
    cache[key] = value;
  } else {
    dataset.set(elem, {
      [key]: value
    });
  }
}
function data(elem, name, value) {
  if (!name) {
    const datas = {};
    Object.keys(dataset).forEach((key) => {
      datas[key] = getData2(elem, key);
    });
    return datas;
  }
  if (typeof name === "string") {
    if (value === void 0) {
      return getData2(elem, name);
    }
    setData2(elem, name, value);
    return;
  }
  for (const key in name) {
    data(elem, key, name[key]);
  }
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/prop.js
var propMap = {
  /* GENERAL */
  class: "className",
  contenteditable: "contentEditable",
  /* LABEL */
  for: "htmlFor",
  /* INPUT */
  readonly: "readOnly",
  maxlength: "maxLength",
  tabindex: "tabIndex",
  /* TABLE */
  colspan: "colSpan",
  rowspan: "rowSpan",
  /* IMAGE */
  usemap: "useMap"
};
function prop(elem, props, value) {
  if (!props) {
    return;
  }
  if (typeof props === "string") {
    props = propMap[props] || props;
    if (arguments.length < 3) {
      return elem[props];
    }
    ;
    elem[props] = value;
    return;
  }
  for (const key in props) {
    prop(elem, key, props[key]);
  }
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/vector/index.js
var Vector = class _Vector {
  get [Symbol.toStringTag]() {
    return _Vector.toStringTag;
  }
  get type() {
    return this.node.nodeName;
  }
  get id() {
    return this.node.id;
  }
  set id(id) {
    this.node.id = id;
  }
  constructor(elem, attrs, children2) {
    if (!elem) {
      throw new TypeError("Invalid element to create vector");
    }
    let node;
    if (_Vector.isVector(elem)) {
      node = elem.node;
    } else if (typeof elem === "string") {
      if (elem.toLowerCase() === "svg") {
        node = createSvgDocument();
      } else if (elem[0] === "<") {
        const doc = createSvgDocument(elem);
        node = document.importNode(doc.firstChild, true);
      } else {
        node = document.createElementNS(ns.svg, elem);
      }
    } else {
      node = elem;
    }
    this.node = node;
    if (attrs) {
      this.setAttributes(attrs);
    }
    if (children2) {
      this.append(children2);
    }
  }
  transform(matrix, options) {
    if (matrix == null) {
      return transform2(this.node);
    }
    transform2(this.node, matrix, options);
    return this;
  }
  translate(tx, ty = 0, options = {}) {
    if (tx == null) {
      return translate(this.node);
    }
    translate(this.node, tx, ty, options);
    return this;
  }
  rotate(angle, cx, cy, options = {}) {
    if (angle == null) {
      return rotate(this.node);
    }
    rotate(this.node, angle, cx, cy, options);
    return this;
  }
  scale(sx, sy) {
    if (sx == null) {
      return scale(this.node);
    }
    scale(this.node, sx, sy);
    return this;
  }
  /**
   * Returns an SVGMatrix that specifies the transformation necessary
   * to convert this coordinate system into `target` coordinate system.
   */
  getTransformToElement(target) {
    const ref2 = _Vector.toNode(target);
    return getTransformToElement(this.node, ref2);
  }
  removeAttribute(name) {
    removeAttribute(this.node, name);
    return this;
  }
  getAttribute(name) {
    return getAttribute(this.node, name);
  }
  setAttribute(name, value) {
    setAttribute(this.node, name, value);
    return this;
  }
  setAttributes(attrs) {
    setAttributes(this.node, attrs);
    return this;
  }
  attr(name, value) {
    if (name == null) {
      return attr(this.node);
    }
    if (typeof name === "string" && value === void 0) {
      return attr(this.node, name);
    }
    if (typeof name === "object") {
      attr(this.node, name);
    } else {
      attr(this.node, name, value);
    }
    return this;
  }
  svg() {
    return this.node instanceof SVGSVGElement ? this : _Vector.create(this.node.ownerSVGElement);
  }
  defs() {
    const context = this.svg() || this;
    const defsNode = context.node.getElementsByTagName("defs")[0];
    if (defsNode) {
      return _Vector.create(defsNode);
    }
    return _Vector.create("defs").appendTo(context);
  }
  text(content2, options = {}) {
    text(this.node, content2, options);
    return this;
  }
  tagName() {
    return tagName(this.node);
  }
  clone() {
    return _Vector.create(this.node.cloneNode(true));
  }
  remove() {
    remove2(this.node);
    return this;
  }
  empty() {
    empty(this.node);
    return this;
  }
  append(elems) {
    append(this.node, _Vector.toNodes(elems));
    return this;
  }
  appendTo(target) {
    appendTo(this.node, _Vector.isVector(target) ? target.node : target);
    return this;
  }
  prepend(elems) {
    prepend(this.node, _Vector.toNodes(elems));
    return this;
  }
  before(elems) {
    before2(this.node, _Vector.toNodes(elems));
    return this;
  }
  replace(elem) {
    if (this.node.parentNode) {
      this.node.parentNode.replaceChild(_Vector.toNode(elem), this.node);
    }
    return _Vector.create(elem);
  }
  first() {
    return this.node.firstChild ? _Vector.create(this.node.firstChild) : null;
  }
  last() {
    return this.node.lastChild ? _Vector.create(this.node.lastChild) : null;
  }
  get(index2) {
    const child = this.node.childNodes[index2];
    return child ? _Vector.create(child) : null;
  }
  indexOf(elem) {
    const children2 = Array.prototype.slice.call(this.node.childNodes);
    return children2.indexOf(_Vector.toNode(elem));
  }
  find(selector) {
    const vels = [];
    const nodes = find2(this.node, selector);
    if (nodes) {
      for (let i = 0, ii = nodes.length; i < ii; i += 1) {
        vels.push(_Vector.create(nodes[i]));
      }
    }
    return vels;
  }
  findOne(selector) {
    const found = findOne(this.node, selector);
    return found ? _Vector.create(found) : null;
  }
  findParentByClass(className3, terminator) {
    const node = findParentByClass(this.node, className3, terminator);
    return node ? _Vector.create(node) : null;
  }
  matches(selector) {
    const node = this.node;
    const matches2 = this.node.matches;
    const matcher = node.matches || node.matchesSelector || node.msMatchesSelector || node.mozMatchesSelector || node.webkitMatchesSelector || node.oMatchesSelector || null;
    return matcher && matcher.call(node, selector);
  }
  contains(child) {
    return contains(this.node, _Vector.isVector(child) ? child.node : child);
  }
  wrap(node) {
    const vel = _Vector.create(node);
    const parentNode = this.node.parentNode;
    if (parentNode != null) {
      parentNode.insertBefore(vel.node, this.node);
    }
    return vel.append(this);
  }
  parent(type) {
    let parent2 = this;
    if (parent2.node.parentNode == null) {
      return null;
    }
    parent2 = _Vector.create(parent2.node.parentNode);
    if (type == null) {
      return parent2;
    }
    do {
      if (typeof type === "string" ? parent2.matches(type) : parent2 instanceof type) {
        return parent2;
      }
    } while (parent2 = _Vector.create(parent2.node.parentNode));
    return parent2;
  }
  children() {
    const children2 = this.node.childNodes;
    const vels = [];
    for (let i = 0; i < children2.length; i += 1) {
      const currentChild = children2[i];
      if (currentChild.nodeType === 1) {
        vels.push(_Vector.create(children2[i]));
      }
    }
    return vels;
  }
  eachChild(fn, deep) {
    const children2 = this.children();
    for (let i = 0, l = children2.length; i < l; i += 1) {
      fn.call(children2[i], children2[i], i, children2);
      if (deep) {
        children2[i].eachChild(fn, deep);
      }
    }
    return this;
  }
  index() {
    return index(this.node);
  }
  hasClass(className3) {
    return hasClass(this.node, className3);
  }
  addClass(className3) {
    addClass(this.node, className3);
    return this;
  }
  removeClass(className3) {
    removeClass(this.node, className3);
    return this;
  }
  toggleClass(className3, stateVal) {
    toggleClass(this.node, className3, stateVal);
    return this;
  }
  toLocalPoint(x, y) {
    return toLocalPoint(this.node, x, y);
  }
  /**
   * Samples the underlying SVG element (it currently works only on
   * paths - where it is most useful anyway). Returns an array of objects
   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
   * objects represent a point on the path. This basically creates a discrete
   * representation of the path (which is possible a curve). The sampling
   * interval defines the accuracy of the sampling. In other words, we travel
   * from the beginning of the path to the end by interval distance (on the
   * path, not between the resulting points) and collect the discrete points
   * on the path. This is very useful in many situations. For example, SVG
   * does not provide a built-in mechanism to find intersections between two
   * paths. Using sampling, we can just generate bunch of points for each of
   * the path and find the closest ones from each set.
   */
  sample(interval = 1) {
    if (this.node instanceof SVGPathElement) {
      return sample2(this.node, interval);
    }
    return [];
  }
  toPath() {
    return _Vector.create(toPath2(this.node));
  }
  toPathData() {
    return toPathData(this.node);
  }
};
(function(Vector2) {
  Vector2.toStringTag = `X6.${Vector2.name}`;
  function isVector(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Vector2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const vector = instance;
    if ((tag == null || tag === Vector2.toStringTag) && vector.node instanceof SVGElement && typeof vector.sample === "function" && typeof vector.toPath === "function") {
      return true;
    }
    return false;
  }
  Vector2.isVector = isVector;
  function create2(elem, attrs, children2) {
    return new Vector2(elem, attrs, children2);
  }
  Vector2.create = create2;
  function createVectors(markup) {
    if (markup[0] === "<") {
      const svgDoc = createSvgDocument(markup);
      const vels = [];
      for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {
        const childNode = svgDoc.childNodes[i];
        vels.push(create2(document.importNode(childNode, true)));
      }
      return vels;
    }
    return [create2(markup)];
  }
  Vector2.createVectors = createVectors;
  function toNode(elem) {
    if (isVector(elem)) {
      return elem.node;
    }
    return elem;
  }
  Vector2.toNode = toNode;
  function toNodes(elems) {
    if (Array.isArray(elems)) {
      return elems.map((elem) => toNode(elem));
    }
    return [toNode(elems)];
  }
  Vector2.toNodes = toNodes;
})(Vector || (Vector = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/text.js
function createTextPathNode(attrs, elem) {
  const vel = Vector.create(elem);
  const textPath2 = Vector.create("textPath");
  const d = attrs.d;
  if (d && attrs["xlink:href"] === void 0) {
    const path2 = Vector.create("path").attr("d", d).appendTo(vel.defs());
    textPath2.attr("xlink:href", `#${path2.id}`);
  }
  if (typeof attrs === "object") {
    textPath2.attr(attrs);
  }
  return textPath2.node;
}
function annotateTextLine(lineNode, lineAnnotations, options) {
  const eol2 = options.eol;
  const baseSize = options.baseSize;
  const lineHeight2 = options.lineHeight;
  let maxFontSize = 0;
  let tspanNode;
  const fontMetrics = {};
  const lastJ = lineAnnotations.length - 1;
  for (let j = 0; j <= lastJ; j += 1) {
    let annotation = lineAnnotations[j];
    let fontSize = null;
    if (typeof annotation === "object") {
      const annotationAttrs = annotation.attrs;
      const vTSpan = Vector.create("tspan", annotationAttrs);
      tspanNode = vTSpan.node;
      let t = annotation.t;
      if (eol2 && j === lastJ) {
        t += eol2;
      }
      tspanNode.textContent = t;
      const annotationClass = annotationAttrs.class;
      if (annotationClass) {
        vTSpan.addClass(annotationClass);
      }
      if (options.includeAnnotationIndices) {
        vTSpan.attr("annotations", annotation.annotations.join(","));
      }
      fontSize = parseFloat(annotationAttrs["font-size"]);
      if (fontSize === void 0)
        fontSize = baseSize;
      if (fontSize && fontSize > maxFontSize)
        maxFontSize = fontSize;
    } else {
      if (eol2 && j === lastJ) {
        annotation += eol2;
      }
      tspanNode = document.createTextNode(annotation || " ");
      if (baseSize && baseSize > maxFontSize) {
        maxFontSize = baseSize;
      }
    }
    lineNode.appendChild(tspanNode);
  }
  if (maxFontSize) {
    fontMetrics.maxFontSize = maxFontSize;
  }
  if (lineHeight2) {
    fontMetrics.lineHeight = lineHeight2;
  } else if (maxFontSize) {
    fontMetrics.lineHeight = maxFontSize * 1.2;
  }
  return fontMetrics;
}
var emRegex = /em$/;
function emToPx(em, fontSize) {
  const numerical = parseFloat(em);
  if (emRegex.test(em)) {
    return numerical * fontSize;
  }
  return numerical;
}
function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight2) {
  if (!Array.isArray(linesMetrics)) {
    return 0;
  }
  const n = linesMetrics.length;
  if (!n)
    return 0;
  let lineMetrics = linesMetrics[0];
  const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
  let rLineHeights = 0;
  const lineHeightPx = emToPx(lineHeight2, baseSizePx);
  for (let i = 1; i < n; i += 1) {
    lineMetrics = linesMetrics[i];
    const iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
    rLineHeights += iLineHeight;
  }
  const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
  let dy;
  switch (alignment) {
    case "middle":
      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
      break;
    case "bottom":
      dy = -(0.25 * llMaxFont) - rLineHeights;
      break;
    case "top":
    default:
      dy = 0.8 * flMaxFont;
      break;
  }
  return dy;
}
function text(elem, content2, options = {}) {
  content2 = main_exports2.sanitize(content2);
  const eol2 = options.eol;
  let textPath2 = options.textPath;
  const verticalAnchor = options.textVerticalAnchor;
  const namedVerticalAnchor = verticalAnchor === "middle" || verticalAnchor === "bottom" || verticalAnchor === "top";
  let x = options.x;
  if (x === void 0) {
    x = elem.getAttribute("x") || 0;
  }
  const iai = options.includeAnnotationIndices;
  let annotations2 = options.annotations;
  if (annotations2 && !Array.isArray(annotations2)) {
    annotations2 = [annotations2];
  }
  const defaultLineHeight = options.lineHeight;
  const autoLineHeight = defaultLineHeight === "auto";
  const lineHeight2 = autoLineHeight ? "1.5em" : defaultLineHeight || "1em";
  let needEmpty = true;
  const childNodes = elem.childNodes;
  if (childNodes.length === 1) {
    const node = childNodes[0];
    if (node && node.tagName.toUpperCase() === "TITLE") {
      needEmpty = false;
    }
  }
  if (needEmpty) {
    empty(elem);
  }
  attr(elem, {
    // Preserve spaces, do not consecutive spaces to get collapsed to one.
    "xml:space": "preserve",
    // An empty text gets rendered into the DOM in webkit-based browsers.
    // In order to unify this behaviour across all browsers
    // we rather hide the text element when it's empty.
    display: content2 || options.displayEmpty ? null : "none"
  });
  const strFontSize = attr(elem, "font-size");
  let fontSize = parseFloat(strFontSize);
  if (!fontSize) {
    fontSize = 16;
    if ((namedVerticalAnchor || annotations2) && !strFontSize) {
      attr(elem, "font-size", `${fontSize}`);
    }
  }
  let containerNode;
  if (textPath2) {
    if (typeof textPath2 === "string") {
      textPath2 = { d: textPath2 };
    }
    containerNode = createTextPathNode(textPath2, elem);
  } else {
    containerNode = document.createDocumentFragment();
  }
  let dy;
  let offset3 = 0;
  let annotatedY;
  const lines = content2.split("\n");
  const linesMetrics = [];
  const lastI = lines.length - 1;
  for (let i = 0; i <= lastI; i += 1) {
    dy = lineHeight2;
    let lineClassName = "v-line";
    const lineNode = createSvgElement("tspan");
    let lineMetrics;
    let line2 = lines[i];
    if (line2) {
      if (annotations2) {
        const lineAnnotations = main_exports2.annotate(line2, annotations2, {
          offset: -offset3,
          includeAnnotationIndices: iai
        });
        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
          eol: i !== lastI && eol2,
          baseSize: fontSize,
          lineHeight: autoLineHeight ? null : lineHeight2,
          includeAnnotationIndices: iai
        });
        const iLineHeight = lineMetrics.lineHeight;
        if (iLineHeight && autoLineHeight && i !== 0) {
          dy = iLineHeight;
        }
        if (i === 0) {
          annotatedY = lineMetrics.maxFontSize * 0.8;
        }
      } else {
        if (eol2 && i !== lastI) {
          line2 += eol2;
        }
        lineNode.textContent = line2;
      }
    } else {
      lineNode.textContent = "-";
      lineClassName += " v-empty-line";
      const lineNodeStyle = lineNode.style;
      lineNodeStyle.fillOpacity = 0;
      lineNodeStyle.strokeOpacity = 0;
      if (annotations2) {
        lineMetrics = {};
      }
    }
    if (lineMetrics) {
      linesMetrics.push(lineMetrics);
    }
    if (i > 0) {
      lineNode.setAttribute("dy", dy);
    }
    if (i > 0 || textPath2) {
      lineNode.setAttribute("x", x);
    }
    lineNode.className.baseVal = lineClassName;
    containerNode.appendChild(lineNode);
    offset3 += line2.length + 1;
  }
  if (namedVerticalAnchor) {
    if (annotations2) {
      dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight2);
    } else if (verticalAnchor === "top") {
      dy = "0.8em";
    } else {
      let rh;
      if (lastI > 0) {
        rh = parseFloat(lineHeight2) || 1;
        rh *= lastI;
        if (!emRegex.test(lineHeight2))
          rh /= fontSize;
      } else {
        rh = 0;
      }
      switch (verticalAnchor) {
        case "middle":
          dy = `${0.3 - rh / 2}em`;
          break;
        case "bottom":
          dy = `${-rh - 0.3}em`;
          break;
        default:
          break;
      }
    }
  } else if (verticalAnchor === 0) {
    dy = "0em";
  } else if (verticalAnchor) {
    dy = verticalAnchor;
  } else {
    dy = 0;
    if (elem.getAttribute("y") == null) {
      elem.setAttribute("y", `${annotatedY || "0.8em"}`);
    }
  }
  const firstLine = containerNode.firstChild;
  firstLine.setAttribute("dy", dy);
  elem.appendChild(containerNode);
}
function measureText(text3, styles = {}) {
  const canvasContext = document.createElement("canvas").getContext("2d");
  if (!text3) {
    return { width: 0 };
  }
  const font = [];
  const fontSize = styles["font-size"] ? `${parseFloat(styles["font-size"])}px` : "14px";
  font.push(styles["font-style"] || "normal");
  font.push(styles["font-variant"] || "normal");
  font.push(styles["font-weight"] || 400);
  font.push(fontSize);
  font.push(styles["font-family"] || "sans-serif");
  canvasContext.font = font.join(" ");
  return canvasContext.measureText(text3);
}
function splitTextByLength(text3, splitWidth, totalWidth, style2 = {}) {
  if (splitWidth >= totalWidth) {
    return [text3, ""];
  }
  const length2 = text3.length;
  const caches = {};
  let index2 = Math.round(splitWidth / totalWidth * length2 - 1);
  if (index2 < 0) {
    index2 = 0;
  }
  while (index2 >= 0 && index2 < length2) {
    const frontText = text3.slice(0, index2);
    const frontWidth = caches[frontText] || measureText(frontText, style2).width;
    const behindText = text3.slice(0, index2 + 1);
    const behindWidth = caches[behindText] || measureText(behindText, style2).width;
    caches[frontText] = frontWidth;
    caches[behindText] = behindWidth;
    if (frontWidth > splitWidth) {
      index2 -= 1;
    } else if (behindWidth <= splitWidth) {
      index2 += 1;
    } else {
      break;
    }
  }
  return [text3.slice(0, index2), text3.slice(index2)];
}
function breakText(text3, size2, styles = {}, options = {}) {
  const width2 = size2.width;
  const height2 = size2.height;
  const eol2 = options.eol || "\n";
  const fontSize = styles.fontSize || 14;
  const lineHeight2 = styles.lineHeight ? parseFloat(styles.lineHeight) : Math.ceil(fontSize * 1.4);
  const maxLines = Math.floor(height2 / lineHeight2);
  if (text3.indexOf(eol2) > -1) {
    const delimiter = string_exports.uuid();
    const splitText = [];
    text3.split(eol2).map((line2) => {
      const part = breakText(line2, Object.assign(Object.assign({}, size2), { height: Number.MAX_SAFE_INTEGER }), styles, Object.assign(Object.assign({}, options), { eol: delimiter }));
      if (part) {
        splitText.push(...part.split(delimiter));
      }
    });
    return splitText.slice(0, maxLines).join(eol2);
  }
  const { width: textWidth } = measureText(text3, styles);
  if (textWidth < width2) {
    return text3;
  }
  const lines = [];
  let remainText = text3;
  let remainWidth = textWidth;
  let ellipsis = options.ellipsis;
  let ellipsisWidth = 0;
  if (ellipsis) {
    if (typeof ellipsis !== "string") {
      ellipsis = "";
    }
    ellipsisWidth = measureText(ellipsis, styles).width;
  }
  for (let i = 0; i < maxLines; i += 1) {
    if (remainWidth > width2) {
      const isLast = i === maxLines - 1;
      if (isLast) {
        const [front] = splitTextByLength(remainText, width2 - ellipsisWidth, remainWidth, styles);
        lines.push(ellipsis ? `${front}${ellipsis}` : front);
      } else {
        const [front, behind] = splitTextByLength(remainText, width2, remainWidth, styles);
        lines.push(front);
        remainText = behind;
        remainWidth = measureText(remainText, styles).width;
      }
    } else {
      lines.push(remainText);
      break;
    }
  }
  return lines.join(eol2);
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/path.js
var KAPPA = 0.551784;
function getNumbericAttribute(elem, attr2, defaultValue = NaN) {
  const v = elem.getAttribute(attr2);
  if (v == null) {
    return defaultValue;
  }
  const n = parseFloat(v);
  return Number.isNaN(n) ? defaultValue : n;
}
function sample2(elem, interval = 1) {
  const length2 = elem.getTotalLength();
  const samples = [];
  let distance = 0;
  let sample3;
  while (distance < length2) {
    sample3 = elem.getPointAtLength(distance);
    samples.push({ distance, x: sample3.x, y: sample3.y });
    distance += interval;
  }
  return samples;
}
function lineToPathData(line2) {
  return [
    "M",
    getNumbericAttribute(line2, "x1"),
    getNumbericAttribute(line2, "y1"),
    "L",
    getNumbericAttribute(line2, "x2"),
    getNumbericAttribute(line2, "y2")
  ].join(" ");
}
function polygonToPathData(polygon) {
  const points = getPointsFromSvgElement(polygon);
  if (points.length === 0) {
    return null;
  }
  return `${svgPointsToPath(points)} Z`;
}
function polylineToPathData(polyline) {
  const points = getPointsFromSvgElement(polyline);
  if (points.length === 0) {
    return null;
  }
  return svgPointsToPath(points);
}
function svgPointsToPath(points) {
  const arr = points.map((p) => `${p.x} ${p.y}`);
  return `M ${arr.join(" L")}`;
}
function getPointsFromSvgElement(elem) {
  const points = [];
  const nodePoints = elem.points;
  if (nodePoints) {
    for (let i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {
      points.push(nodePoints.getItem(i));
    }
  }
  return points;
}
function circleToPathData(circle2) {
  const cx = getNumbericAttribute(circle2, "cx", 0);
  const cy = getNumbericAttribute(circle2, "cy", 0);
  const r = getNumbericAttribute(circle2, "r");
  const cd = r * KAPPA;
  return [
    "M",
    cx,
    cy - r,
    "C",
    cx + cd,
    cy - r,
    cx + r,
    cy - cd,
    cx + r,
    cy,
    "C",
    cx + r,
    cy + cd,
    cx + cd,
    cy + r,
    cx,
    cy + r,
    "C",
    cx - cd,
    cy + r,
    cx - r,
    cy + cd,
    cx - r,
    cy,
    "C",
    cx - r,
    cy - cd,
    cx - cd,
    cy - r,
    cx,
    cy - r,
    "Z"
  ].join(" ");
}
function ellipseToPathData(ellipse3) {
  const cx = getNumbericAttribute(ellipse3, "cx", 0);
  const cy = getNumbericAttribute(ellipse3, "cy", 0);
  const rx = getNumbericAttribute(ellipse3, "rx");
  const ry = getNumbericAttribute(ellipse3, "ry") || rx;
  const cdx = rx * KAPPA;
  const cdy = ry * KAPPA;
  const d = [
    "M",
    cx,
    cy - ry,
    "C",
    cx + cdx,
    cy - ry,
    cx + rx,
    cy - cdy,
    cx + rx,
    cy,
    "C",
    cx + rx,
    cy + cdy,
    cx + cdx,
    cy + ry,
    cx,
    cy + ry,
    "C",
    cx - cdx,
    cy + ry,
    cx - rx,
    cy + cdy,
    cx - rx,
    cy,
    "C",
    cx - rx,
    cy - cdy,
    cx - cdx,
    cy - ry,
    cx,
    cy - ry,
    "Z"
  ].join(" ");
  return d;
}
function rectangleToPathData(rect2) {
  return rectToPathData({
    x: getNumbericAttribute(rect2, "x", 0),
    y: getNumbericAttribute(rect2, "y", 0),
    width: getNumbericAttribute(rect2, "width", 0),
    height: getNumbericAttribute(rect2, "height", 0),
    rx: getNumbericAttribute(rect2, "rx", 0),
    ry: getNumbericAttribute(rect2, "ry", 0)
  });
}
function rectToPathData(r) {
  let d;
  const x = r.x;
  const y = r.y;
  const width2 = r.width;
  const height2 = r.height;
  const topRx = Math.min(r.rx || r["top-rx"] || 0, width2 / 2);
  const bottomRx = Math.min(r.rx || r["bottom-rx"] || 0, width2 / 2);
  const topRy = Math.min(r.ry || r["top-ry"] || 0, height2 / 2);
  const bottomRy = Math.min(r.ry || r["bottom-ry"] || 0, height2 / 2);
  if (topRx || bottomRx || topRy || bottomRy) {
    d = [
      "M",
      x,
      y + topRy,
      "v",
      height2 - topRy - bottomRy,
      "a",
      bottomRx,
      bottomRy,
      0,
      0,
      0,
      bottomRx,
      bottomRy,
      "h",
      width2 - 2 * bottomRx,
      "a",
      bottomRx,
      bottomRy,
      0,
      0,
      0,
      bottomRx,
      -bottomRy,
      "v",
      -(height2 - bottomRy - topRy),
      "a",
      topRx,
      topRy,
      0,
      0,
      0,
      -topRx,
      -topRy,
      "h",
      -(width2 - 2 * topRx),
      "a",
      topRx,
      topRy,
      0,
      0,
      0,
      -topRx,
      topRy,
      "Z"
    ];
  } else {
    d = ["M", x, y, "H", x + width2, "V", y + height2, "H", x, "V", y, "Z"];
  }
  return d.join(" ");
}
function toPath2(elem) {
  const path2 = createSvgElement("path");
  attr(path2, attr(elem));
  const d = toPathData(elem);
  if (d) {
    path2.setAttribute("d", d);
  }
  return path2;
}
function toPathData(elem) {
  const tagName2 = elem.tagName.toLowerCase();
  switch (tagName2) {
    case "path":
      return elem.getAttribute("d");
    case "line":
      return lineToPathData(elem);
    case "polygon":
      return polygonToPathData(elem);
    case "polyline":
      return polylineToPathData(elem);
    case "ellipse":
      return ellipseToPathData(elem);
    case "circle":
      return circleToPathData(elem);
    case "rect":
      return rectangleToPathData(elem);
    default:
      break;
  }
  throw new Error(`"${tagName2}" cannot be converted to svg path element.`);
}
function createSlicePathData(innerRadius, outerRadius, startAngle, endAngle) {
  const svgArcMax = 2 * Math.PI - 1e-6;
  const r0 = innerRadius;
  const r1 = outerRadius;
  let a0 = startAngle;
  let a1 = endAngle;
  if (a1 < a0) {
    const tmp = a0;
    a0 = a1;
    a1 = tmp;
  }
  const da = a1 - a0;
  const df = da < Math.PI ? "0" : "1";
  const c0 = Math.cos(a0);
  const s0 = Math.sin(a0);
  const c1 = Math.cos(a1);
  const s1 = Math.sin(a1);
  return da >= svgArcMax ? r0 ? (
    // eslint-disable-next-line
    `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}M0,${r0}A${r0},${r0} 0 1,0 0,${-r0}A${r0},${r0} 0 1,0 0,${r0}Z`
  ) : (
    // eslint-disable-next-line
    `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}Z`
  ) : r0 ? (
    // eslint-disable-next-line
    `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L${r0 * c1},${r0 * s1}A${r0},${r0} 0 ${df},0 ${r0 * c0},${r0 * s0}Z`
  ) : (
    // eslint-disable-next-line
    `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L0,0Z`
  );
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/matrix.js
var transformRegex = /(\w+)\(([^,)]+),?([^)]+)?\)/gi;
var transformSeparatorRegex = /[ ,]+/;
var transformationListRegex = /^(\w+)\((.*)\)/;
function createSVGPoint(x, y) {
  const svgDocument = createSvgElement("svg");
  const p = svgDocument.createSVGPoint();
  p.x = x;
  p.y = y;
  return p;
}
function createSVGMatrix(matrix) {
  const svgDocument = createSvgElement("svg");
  const mat = svgDocument.createSVGMatrix();
  if (matrix != null) {
    const source = matrix;
    const target = mat;
    for (const key in source) {
      target[key] = source[key];
    }
  }
  return mat;
}
function createSVGTransform(matrix) {
  const svgDocument = createSvgElement("svg");
  if (matrix != null) {
    if (!(matrix instanceof DOMMatrix)) {
      matrix = createSVGMatrix(matrix);
    }
    return svgDocument.createSVGTransformFromMatrix(matrix);
  }
  return svgDocument.createSVGTransform();
}
function transformStringToMatrix(transform3) {
  let mat = createSVGMatrix();
  const matches2 = transform3 != null && transform3.match(transformRegex);
  if (!matches2) {
    return mat;
  }
  for (let i = 0, n = matches2.length; i < n; i += 1) {
    const transformationString = matches2[i];
    const transformationMatch = transformationString.match(transformationListRegex);
    if (transformationMatch) {
      let sx;
      let sy;
      let tx;
      let ty;
      let angle;
      let ctm = createSVGMatrix();
      const args = transformationMatch[2].split(transformSeparatorRegex);
      switch (transformationMatch[1].toLowerCase()) {
        case "scale":
          sx = parseFloat(args[0]);
          sy = args[1] === void 0 ? sx : parseFloat(args[1]);
          ctm = ctm.scaleNonUniform(sx, sy);
          break;
        case "translate":
          tx = parseFloat(args[0]);
          ty = parseFloat(args[1]);
          ctm = ctm.translate(tx, ty);
          break;
        case "rotate":
          angle = parseFloat(args[0]);
          tx = parseFloat(args[1]) || 0;
          ty = parseFloat(args[2]) || 0;
          if (tx !== 0 || ty !== 0) {
            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);
          } else {
            ctm = ctm.rotate(angle);
          }
          break;
        case "skewx":
          angle = parseFloat(args[0]);
          ctm = ctm.skewX(angle);
          break;
        case "skewy":
          angle = parseFloat(args[0]);
          ctm = ctm.skewY(angle);
          break;
        case "matrix":
          ctm.a = parseFloat(args[0]);
          ctm.b = parseFloat(args[1]);
          ctm.c = parseFloat(args[2]);
          ctm.d = parseFloat(args[3]);
          ctm.e = parseFloat(args[4]);
          ctm.f = parseFloat(args[5]);
          break;
        default:
          continue;
      }
      mat = mat.multiply(ctm);
    }
  }
  return mat;
}
function matrixToTransformString(matrix) {
  const m = matrix || {};
  const a = m.a != null ? m.a : 1;
  const b = m.b != null ? m.b : 0;
  const c = m.c != null ? m.c : 0;
  const d = m.d != null ? m.d : 1;
  const e = m.e != null ? m.e : 0;
  const f = m.f != null ? m.f : 0;
  return `matrix(${a},${b},${c},${d},${e},${f})`;
}
function parseTransformString(transform3) {
  let translation;
  let rotation;
  let scale2;
  if (transform3) {
    const separator = transformSeparatorRegex;
    if (transform3.trim().indexOf("matrix") >= 0) {
      const matrix = transformStringToMatrix(transform3);
      const decomposedMatrix = decomposeMatrix(matrix);
      translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];
      rotation = [decomposedMatrix.rotation];
      scale2 = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];
      const transformations = [];
      if (translation[0] !== 0 || translation[1] !== 0) {
        transformations.push(`translate(${translation.join(",")})`);
      }
      if (scale2[0] !== 1 || scale2[1] !== 1) {
        transformations.push(`scale(${scale2.join(",")})`);
      }
      if (rotation[0] !== 0) {
        transformations.push(`rotate(${rotation[0]})`);
      }
      transform3 = transformations.join(" ");
    } else {
      const translateMatch = transform3.match(/translate\((.*?)\)/);
      if (translateMatch) {
        translation = translateMatch[1].split(separator);
      }
      const rotateMatch = transform3.match(/rotate\((.*?)\)/);
      if (rotateMatch) {
        rotation = rotateMatch[1].split(separator);
      }
      const scaleMatch = transform3.match(/scale\((.*?)\)/);
      if (scaleMatch) {
        scale2 = scaleMatch[1].split(separator);
      }
    }
  }
  const sx = scale2 && scale2[0] ? parseFloat(scale2[0]) : 1;
  return {
    raw: transform3 || "",
    translation: {
      tx: translation && translation[0] ? parseInt(translation[0], 10) : 0,
      ty: translation && translation[1] ? parseInt(translation[1], 10) : 0
    },
    rotation: {
      angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,
      cx: rotation && rotation[1] ? parseInt(rotation[1], 10) : void 0,
      cy: rotation && rotation[2] ? parseInt(rotation[2], 10) : void 0
    },
    scale: {
      sx,
      sy: scale2 && scale2[1] ? parseFloat(scale2[1]) : sx
    }
  };
}
function deltaTransformPoint(matrix, point) {
  const dx = point.x * matrix.a + point.y * matrix.c + 0;
  const dy = point.x * matrix.b + point.y * matrix.d + 0;
  return { x: dx, y: dy };
}
function decomposeMatrix(matrix) {
  const px = deltaTransformPoint(matrix, { x: 0, y: 1 });
  const py = deltaTransformPoint(matrix, { x: 1, y: 0 });
  const skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;
  const skewY = 180 / Math.PI * Math.atan2(py.y, py.x);
  return {
    skewX,
    skewY,
    translateX: matrix.e,
    translateY: matrix.f,
    scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
    scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
    rotation: skewX
  };
}
function matrixToScale(matrix) {
  let a;
  let b;
  let c;
  let d;
  if (matrix) {
    a = matrix.a == null ? 1 : matrix.a;
    d = matrix.d == null ? 1 : matrix.d;
    b = matrix.b;
    c = matrix.c;
  } else {
    a = d = 1;
  }
  return {
    sx: b ? Math.sqrt(a * a + b * b) : a,
    sy: c ? Math.sqrt(c * c + d * d) : d
  };
}
function matrixToRotation(matrix) {
  let p = { x: 0, y: 1 };
  if (matrix) {
    p = deltaTransformPoint(matrix, p);
  }
  const deg = 180 * Math.atan2(p.y, p.x) / Math.PI % 360 - 90;
  const angle = deg % 360 + (deg < 0 ? 360 : 0);
  return {
    angle
  };
}
function matrixToTranslation(matrix) {
  return {
    tx: matrix && matrix.e || 0,
    ty: matrix && matrix.f || 0
  };
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/transform.js
function transform2(elem, matrix, options = {}) {
  if (matrix == null) {
    return transformStringToMatrix(attr(elem, "transform"));
  }
  if (options.absolute) {
    elem.setAttribute("transform", matrixToTransformString(matrix));
    return;
  }
  const transformList = elem.transform;
  const svgTransform = createSVGTransform(matrix);
  transformList.baseVal.appendItem(svgTransform);
}
function translate(elem, tx, ty = 0, options = {}) {
  let transformAttr = attr(elem, "transform");
  const transform3 = parseTransformString(transformAttr);
  if (tx == null) {
    return transform3.translation;
  }
  transformAttr = transform3.raw;
  transformAttr = transformAttr.replace(/translate\([^)]*\)/g, "").trim();
  const newTx = options.absolute ? tx : transform3.translation.tx + tx;
  const newTy = options.absolute ? ty : transform3.translation.ty + ty;
  const newTranslate = `translate(${newTx},${newTy})`;
  elem.setAttribute("transform", `${newTranslate} ${transformAttr}`.trim());
}
function rotate(elem, angle, cx, cy, options = {}) {
  let transformAttr = attr(elem, "transform");
  const transform3 = parseTransformString(transformAttr);
  if (angle == null) {
    return transform3.rotation;
  }
  transformAttr = transform3.raw;
  transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, "").trim();
  angle %= 360;
  const newAngle = options.absolute ? angle : transform3.rotation.angle + angle;
  const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : "";
  const newRotate = `rotate(${newAngle}${newOrigin})`;
  elem.setAttribute("transform", `${transformAttr} ${newRotate}`.trim());
}
function scale(elem, sx, sy) {
  let transformAttr = attr(elem, "transform");
  const transform3 = parseTransformString(transformAttr);
  if (sx == null) {
    return transform3.scale;
  }
  sy = sy == null ? sx : sy;
  transformAttr = transform3.raw;
  transformAttr = transformAttr.replace(/scale\([^)]*\)/g, "").trim();
  const newScale = `scale(${sx},${sy})`;
  elem.setAttribute("transform", `${transformAttr} ${newScale}`.trim());
}
function getTransformToElement(elem, target) {
  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {
    const targetCTM = target.getScreenCTM();
    const nodeCTM = elem.getScreenCTM();
    if (targetCTM && nodeCTM) {
      return targetCTM.inverse().multiply(nodeCTM);
    }
  }
  return createSVGMatrix();
}
function getTransformToParentElement(elem, target) {
  let matrix = createSVGMatrix();
  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {
    let node = elem;
    const matrixList = [];
    while (node && node !== target) {
      const transform3 = node.getAttribute("transform") || null;
      const nodeMatrix = transformStringToMatrix(transform3);
      matrixList.push(nodeMatrix);
      node = node.parentNode;
    }
    matrixList.reverse().forEach((m) => {
      matrix = matrix.multiply(m);
    });
  }
  return matrix;
}
function toLocalPoint(elem, x, y) {
  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
  const p = svg.createSVGPoint();
  p.x = x;
  p.y = y;
  try {
    const ctm = svg.getScreenCTM();
    const globalPoint = p.matrixTransform(ctm.inverse());
    const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();
    return globalPoint.matrixTransform(globalToLocalMatrix);
  } catch (e) {
    return p;
  }
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/event/hook.js
var EventHook;
(function(EventHook2) {
  const cache = {};
  function get2(type) {
    return cache[type] || {};
  }
  EventHook2.get = get2;
  function register(type, hook) {
    cache[type] = hook;
  }
  EventHook2.register = register;
  function unregister(type) {
    delete cache[type];
  }
  EventHook2.unregister = unregister;
})(EventHook || (EventHook = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/event/store.js
var Store;
(function(Store3) {
  const cache = /* @__PURE__ */ new WeakMap();
  function ensure3(target) {
    if (!cache.has(target)) {
      cache.set(target, { events: /* @__PURE__ */ Object.create(null) });
    }
    return cache.get(target);
  }
  Store3.ensure = ensure3;
  function get2(target) {
    return cache.get(target);
  }
  Store3.get = get2;
  function remove3(target) {
    return cache.delete(target);
  }
  Store3.remove = remove3;
})(Store || (Store = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/event/util.js
var Util;
(function(Util3) {
  Util3.returnTrue = () => true;
  Util3.returnFalse = () => false;
  function stopPropagationCallback(e) {
    e.stopPropagation();
  }
  Util3.stopPropagationCallback = stopPropagationCallback;
  function addEventListener(elem, type, handler) {
    if (elem.addEventListener != null) {
      elem.addEventListener(type, handler);
    }
  }
  Util3.addEventListener = addEventListener;
  function removeEventListener(elem, type, handler) {
    if (elem.removeEventListener != null) {
      elem.removeEventListener(type, handler);
    }
  }
  Util3.removeEventListener = removeEventListener;
})(Util || (Util = {}));
(function(Util3) {
  const rNotHTMLWhite = /[^\x20\t\r\n\f]+/g;
  const rNamespace = /^([^.]*)(?:\.(.+)|)/;
  function splitType(types) {
    return (types || "").match(rNotHTMLWhite) || [""];
  }
  Util3.splitType = splitType;
  function normalizeType(type) {
    const parts = rNamespace.exec(type) || [];
    return {
      originType: parts[1] ? parts[1].trim() : parts[1],
      namespaces: parts[2] ? parts[2].split(".").map((ns2) => ns2.trim()).sort() : []
    };
  }
  Util3.normalizeType = normalizeType;
  function isValidTarget(target) {
    return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType;
  }
  Util3.isValidTarget = isValidTarget;
  function isValidSelector(elem, selector) {
    if (selector) {
      const node = elem;
      return node.querySelector != null && node.querySelector(selector) != null;
    }
    return true;
  }
  Util3.isValidSelector = isValidSelector;
})(Util || (Util = {}));
(function(Util3) {
  let seed = 0;
  const cache = /* @__PURE__ */ new WeakMap();
  function ensureHandlerId(handler) {
    if (!cache.has(handler)) {
      cache.set(handler, seed);
      seed += 1;
    }
    return cache.get(handler);
  }
  Util3.ensureHandlerId = ensureHandlerId;
  function getHandlerId(handler) {
    return cache.get(handler);
  }
  Util3.getHandlerId = getHandlerId;
  function removeHandlerId(handler) {
    return cache.delete(handler);
  }
  Util3.removeHandlerId = removeHandlerId;
  function setHandlerId(handler, id) {
    return cache.set(handler, id);
  }
  Util3.setHandlerId = setHandlerId;
})(Util || (Util = {}));
(function(Util3) {
  function getHandlerQueue(elem, event) {
    const queue = [];
    const store = Store.get(elem);
    const bag = store && store.events && store.events[event.type];
    const handlers = bag && bag.handlers || [];
    const delegateCount = bag ? bag.delegateCount : 0;
    if (delegateCount > 0 && // Support: Firefox <=42 - 66+
    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
    // Support: IE 11+
    // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
    !(event.type === "click" && typeof event.button === "number" && event.button >= 1)) {
      for (let curr = event.target; curr !== elem; curr = curr.parentNode || elem) {
        if (curr.nodeType === 1 && !(event.type === "click" && curr.disabled === true)) {
          const matchedHandlers = [];
          const matchedSelectors = {};
          for (let i = 0; i < delegateCount; i += 1) {
            const handleObj = handlers[i];
            const selector = handleObj.selector;
            if (selector != null && matchedSelectors[selector] == null) {
              const node = elem;
              const nodes = [];
              node.querySelectorAll(selector).forEach((child) => {
                nodes.push(child);
              });
              matchedSelectors[selector] = nodes.includes(curr);
            }
            if (matchedSelectors[selector]) {
              matchedHandlers.push(handleObj);
            }
          }
          if (matchedHandlers.length) {
            queue.push({ elem: curr, handlers: matchedHandlers });
          }
        }
      }
    }
    if (delegateCount < handlers.length) {
      queue.push({ elem, handlers: handlers.slice(delegateCount) });
    }
    return queue;
  }
  Util3.getHandlerQueue = getHandlerQueue;
})(Util || (Util = {}));
(function(Util3) {
  function isWindow(obj) {
    return obj != null && obj === obj.window;
  }
  Util3.isWindow = isWindow;
})(Util || (Util = {}));
(function(Util3) {
  function contains2(a, b) {
    const adown = a.nodeType === 9 ? a.documentElement : a;
    const bup = b && b.parentNode;
    return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
    // IE doesn't have `contains` on SVG.
    (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
  }
  Util3.contains = contains2;
})(Util || (Util = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/event/object.js
var EventObject = class {
  constructor(e, props) {
    this.isDefaultPrevented = Util.returnFalse;
    this.isPropagationStopped = Util.returnFalse;
    this.isImmediatePropagationStopped = Util.returnFalse;
    this.isSimulated = false;
    this.preventDefault = () => {
      const e2 = this.originalEvent;
      this.isDefaultPrevented = Util.returnTrue;
      if (e2 && !this.isSimulated) {
        e2.preventDefault();
      }
    };
    this.stopPropagation = () => {
      const e2 = this.originalEvent;
      this.isPropagationStopped = Util.returnTrue;
      if (e2 && !this.isSimulated) {
        e2.stopPropagation();
      }
    };
    this.stopImmediatePropagation = () => {
      const e2 = this.originalEvent;
      this.isImmediatePropagationStopped = Util.returnTrue;
      if (e2 && !this.isSimulated) {
        e2.stopImmediatePropagation();
      }
      this.stopPropagation();
    };
    if (typeof e === "string") {
      this.type = e;
    } else if (e.type) {
      this.originalEvent = e;
      this.type = e.type;
      this.isDefaultPrevented = e.defaultPrevented ? Util.returnTrue : Util.returnFalse;
      this.target = e.target;
      this.currentTarget = e.currentTarget;
      this.relatedTarget = e.relatedTarget;
      this.timeStamp = e.timeStamp;
    }
    if (props) {
      Object.assign(this, props);
    }
    if (!this.timeStamp) {
      this.timeStamp = Date.now();
    }
  }
};
(function(EventObject2) {
  function create2(originalEvent) {
    return originalEvent instanceof EventObject2 ? originalEvent : new EventObject2(originalEvent);
  }
  EventObject2.create = create2;
})(EventObject || (EventObject = {}));
(function(EventObject2) {
  function addProperty(name, hook) {
    Object.defineProperty(EventObject2.prototype, name, {
      enumerable: true,
      configurable: true,
      get: typeof hook === "function" ? (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        }
      ) : (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        }
      ),
      set(value) {
        Object.defineProperty(this, name, {
          enumerable: true,
          configurable: true,
          writable: true,
          value
        });
      }
    });
  }
  EventObject2.addProperty = addProperty;
})(EventObject || (EventObject = {}));
(function(EventObject2) {
  const commonProps = {
    bubbles: true,
    cancelable: true,
    eventPhase: true,
    detail: true,
    view: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pageX: true,
    pageY: true,
    screenX: true,
    screenY: true,
    toElement: true,
    pointerId: true,
    pointerType: true,
    char: true,
    code: true,
    charCode: true,
    key: true,
    keyCode: true,
    touches: true,
    changedTouches: true,
    targetTouches: true,
    which: true,
    altKey: true,
    ctrlKey: true,
    metaKey: true,
    shiftKey: true
  };
  Object.keys(commonProps).forEach((name) => EventObject2.addProperty(name, commonProps[name]));
})(EventObject || (EventObject = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/event/special.js
var Special;
(function(Special2) {
  EventHook.register("load", {
    noBubble: true
  });
})(Special || (Special = {}));
(function(Special2) {
  EventHook.register("beforeunload", {
    postDispatch(elem, event) {
      if (event.result !== void 0 && event.originalEvent) {
        event.originalEvent.returnValue = event.result;
      }
    }
  });
})(Special || (Special = {}));
(function(Special2) {
  EventHook.register("mouseenter", {
    delegateType: "mouseover",
    bindType: "mouseover",
    handle(target, event) {
      let ret;
      const related = event.relatedTarget;
      const handleObj = event.handleObj;
      if (!related || related !== target && !Util.contains(target, related)) {
        event.type = handleObj.originType;
        ret = handleObj.handler.call(target, event);
        event.type = "mouseover";
      }
      return ret;
    }
  });
  EventHook.register("mouseleave", {
    delegateType: "mouseout",
    bindType: "mouseout",
    handle(target, event) {
      let ret;
      const related = event.relatedTarget;
      const handleObj = event.handleObj;
      if (!related || related !== target && !Util.contains(target, related)) {
        event.type = handleObj.originType;
        ret = handleObj.handler.call(target, event);
        event.type = "mouseout";
      }
      return ret;
    }
  });
})(Special || (Special = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/event/core.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Core;
(function(Core2) {
  let triggered;
  function on(elem, types, handler, data2, selector) {
    if (!Util.isValidTarget(elem)) {
      return;
    }
    let handlerData;
    if (typeof handler !== "function") {
      const { handler: h, selector: s } = handler, others = __rest(handler, ["handler", "selector"]);
      handler = h;
      selector = s;
      handlerData = others;
    }
    const store = Store.ensure(elem);
    let mainHandler = store.handler;
    if (mainHandler == null) {
      mainHandler = store.handler = function(e, ...args) {
        return triggered !== e.type ? dispatch(elem, e, ...args) : void 0;
      };
    }
    const guid = Util.ensureHandlerId(handler);
    Util.splitType(types).forEach((item) => {
      const { originType, namespaces } = Util.normalizeType(item);
      if (!originType) {
        return;
      }
      let type = originType;
      let hook = EventHook.get(type);
      type = (selector ? hook.delegateType : hook.bindType) || type;
      hook = EventHook.get(type);
      const handleObj = Object.assign({
        type,
        originType,
        data: data2,
        selector,
        guid,
        handler,
        namespace: namespaces.join(".")
      }, handlerData);
      const events = store.events;
      let bag = events[type];
      if (!bag) {
        bag = events[type] = { handlers: [], delegateCount: 0 };
        if (!hook.setup || hook.setup(elem, data2, namespaces, mainHandler) === false) {
          Util.addEventListener(elem, type, mainHandler);
        }
      }
      if (hook.add) {
        Util.removeHandlerId(handleObj.handler);
        hook.add(elem, handleObj);
        Util.setHandlerId(handleObj.handler, guid);
      }
      if (selector) {
        bag.handlers.splice(bag.delegateCount, 0, handleObj);
        bag.delegateCount += 1;
      } else {
        bag.handlers.push(handleObj);
      }
    });
  }
  Core2.on = on;
  function off(elem, types, handler, selector, mappedTypes) {
    const store = Store.get(elem);
    if (!store) {
      return;
    }
    const events = store.events;
    if (!events) {
      return;
    }
    Util.splitType(types).forEach((item) => {
      const { originType, namespaces } = Util.normalizeType(item);
      if (!originType) {
        Object.keys(events).forEach((key) => {
          off(elem, key + item, handler, selector, true);
        });
        return;
      }
      let type = originType;
      const hook = EventHook.get(type);
      type = (selector ? hook.delegateType : hook.bindType) || type;
      const bag = events[type];
      if (!bag) {
        return;
      }
      const rns = namespaces.length > 0 ? new RegExp(`(^|\\.)${namespaces.join("\\.(?:.*\\.|)")}(\\.|$)`) : null;
      const originHandlerCount = bag.handlers.length;
      for (let i = bag.handlers.length - 1; i >= 0; i -= 1) {
        const handleObj = bag.handlers[i];
        if ((mappedTypes || originType === handleObj.originType) && (!handler || Util.getHandlerId(handler) === handleObj.guid) && (rns == null || handleObj.namespace && rns.test(handleObj.namespace)) && (selector == null || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
          bag.handlers.splice(i, 1);
          if (handleObj.selector) {
            bag.delegateCount -= 1;
          }
          if (hook.remove) {
            hook.remove(elem, handleObj);
          }
        }
      }
      if (originHandlerCount && bag.handlers.length === 0) {
        if (!hook.teardown || hook.teardown(elem, namespaces, store.handler) === false) {
          Util.removeEventListener(elem, type, store.handler);
        }
        delete events[type];
      }
    });
    if (Object.keys(events).length === 0) {
      Store.remove(elem);
    }
  }
  Core2.off = off;
  function dispatch(elem, evt, ...args) {
    const event = EventObject.create(evt);
    event.delegateTarget = elem;
    const hook = EventHook.get(event.type);
    if (hook.preDispatch && hook.preDispatch(elem, event) === false) {
      return;
    }
    const handlerQueue = Util.getHandlerQueue(elem, event);
    for (let i = 0, l = handlerQueue.length; i < l && !event.isPropagationStopped(); i += 1) {
      const matched = handlerQueue[i];
      event.currentTarget = matched.elem;
      for (let j = 0, k = matched.handlers.length; j < k && !event.isImmediatePropagationStopped(); j += 1) {
        const handleObj = matched.handlers[j];
        if (event.rnamespace == null || handleObj.namespace && event.rnamespace.test(handleObj.namespace)) {
          event.handleObj = handleObj;
          event.data = handleObj.data;
          const hookHandle = EventHook.get(handleObj.originType).handle;
          const result2 = hookHandle ? hookHandle(matched.elem, event, ...args) : handleObj.handler.call(matched.elem, event, ...args);
          if (result2 !== void 0) {
            event.result = result2;
            if (result2 === false) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }
    if (hook.postDispatch) {
      hook.postDispatch(elem, event);
    }
    return event.result;
  }
  Core2.dispatch = dispatch;
  function trigger(event, eventArgs, elem, onlyHandlers) {
    let eventObj = event;
    let type = typeof event === "string" ? event : event.type;
    let namespaces = typeof event === "string" || eventObj.namespace == null ? [] : eventObj.namespace.split(".");
    const node = elem;
    if (node.nodeType === 3 || node.nodeType === 8) {
      return;
    }
    if (type.indexOf(".") > -1) {
      namespaces = type.split(".");
      type = namespaces.shift();
      namespaces.sort();
    }
    const ontype = type.indexOf(":") < 0 && `on${type}`;
    eventObj = event instanceof EventObject ? event : new EventObject(type, typeof event === "object" ? event : null);
    eventObj.namespace = namespaces.join(".");
    eventObj.rnamespace = eventObj.namespace ? new RegExp(`(^|\\.)${namespaces.join("\\.(?:.*\\.|)")}(\\.|$)`) : null;
    eventObj.result = void 0;
    if (!eventObj.target) {
      eventObj.target = node;
    }
    const args = [eventObj];
    if (Array.isArray(eventArgs)) {
      args.push(...eventArgs);
    } else {
      args.push(eventArgs);
    }
    const hook = EventHook.get(type);
    if (!onlyHandlers && hook.trigger && hook.trigger(node, eventObj, eventArgs) === false) {
      return;
    }
    let bubbleType;
    const eventPath = [node];
    if (!onlyHandlers && !hook.noBubble && !Util.isWindow(node)) {
      bubbleType = hook.delegateType || type;
      let last2 = node;
      let curr = node.parentNode;
      while (curr != null) {
        eventPath.push(curr);
        last2 = curr;
        curr = curr.parentNode;
      }
      const doc = node.ownerDocument || document;
      if (last2 === doc) {
        const win = last2.defaultView || last2.parentWindow || window;
        eventPath.push(win);
      }
    }
    let lastElement = node;
    for (let i = 0, l = eventPath.length; i < l && !eventObj.isPropagationStopped(); i += 1) {
      const currElement = eventPath[i];
      lastElement = currElement;
      eventObj.type = i > 1 ? bubbleType : hook.bindType || type;
      const store = Store.get(currElement);
      if (store) {
        if (store.events[eventObj.type] && store.handler) {
          store.handler.call(currElement, ...args);
        }
      }
      const handle = ontype && currElement[ontype] || null;
      if (handle && Util.isValidTarget(currElement)) {
        eventObj.result = handle.call(currElement, ...args);
        if (eventObj.result === false) {
          eventObj.preventDefault();
        }
      }
    }
    eventObj.type = type;
    if (!onlyHandlers && !eventObj.isDefaultPrevented()) {
      const preventDefault = hook.preventDefault;
      if ((preventDefault == null || preventDefault(eventPath.pop(), eventObj, eventArgs) === false) && Util.isValidTarget(node)) {
        if (ontype && typeof node[type] === "function" && !Util.isWindow(node)) {
          const tmp = node[ontype];
          if (tmp) {
            node[ontype] = null;
          }
          triggered = type;
          if (eventObj.isPropagationStopped()) {
            lastElement.addEventListener(type, Util.stopPropagationCallback);
          }
          node[type]();
          if (eventObj.isPropagationStopped()) {
            lastElement.removeEventListener(type, Util.stopPropagationCallback);
          }
          triggered = void 0;
          if (tmp) {
            node[ontype] = tmp;
          }
        }
      }
    }
    return eventObj.result;
  }
  Core2.trigger = trigger;
})(Core || (Core = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/event/main.js
var Event;
(function(Event2) {
  function on(elem, events, selector, data2, handler) {
    Private.on(elem, events, selector, data2, handler);
    return elem;
  }
  Event2.on = on;
  function once2(elem, events, selector, data2, handler) {
    Private.on(elem, events, selector, data2, handler, true);
    return elem;
  }
  Event2.once = once2;
  function off(elem, events, selector, handler) {
    Private.off(elem, events, selector, handler);
    return elem;
  }
  Event2.off = off;
  function trigger(elem, event, args, onlyHandlers) {
    Core.trigger(event, args, elem, onlyHandlers);
    return elem;
  }
  Event2.trigger = trigger;
})(Event || (Event = {}));
var Private;
(function(Private5) {
  function on(elem, types, selector, data2, fn, once2) {
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data2 = data2 || selector;
        selector = void 0;
      }
      Object.keys(types).forEach((type) => on(elem, type, selector, data2, types[type], once2));
      return;
    }
    if (data2 == null && fn == null) {
      fn = selector;
      data2 = selector = void 0;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data2;
        data2 = void 0;
      } else {
        fn = data2;
        data2 = selector;
        selector = void 0;
      }
    }
    if (fn === false) {
      fn = Util.returnFalse;
    } else if (!fn) {
      return;
    }
    if (once2) {
      const originHandler = fn;
      fn = function(event, ...args) {
        Private5.off(elem, event);
        return originHandler.call(this, event, ...args);
      };
      Util.setHandlerId(fn, Util.ensureHandlerId(originHandler));
    }
    Core.on(elem, types, fn, data2, selector);
  }
  Private5.on = on;
  function off(elem, events, selector, fn) {
    const evt = events;
    if (evt && evt.preventDefault != null && evt.handleObj != null) {
      const obj = evt.handleObj;
      off(evt.delegateTarget, obj.namespace ? `${obj.originType}.${obj.namespace}` : obj.originType, obj.selector, obj.handler);
      return;
    }
    if (typeof events === "object") {
      const types = events;
      Object.keys(types).forEach((type) => off(elem, type, selector, types[type]));
      return;
    }
    if (selector === false || typeof selector === "function") {
      fn = selector;
      selector = void 0;
    }
    if (fn === false) {
      fn = Util.returnFalse;
    }
    Core.off(elem, events, fn, selector);
  }
  Private5.off = off;
})(Private || (Private = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/mousewheel.js
var MouseWheelHandle = class {
  constructor(target, onWheelCallback, onWheelGuard) {
    this.animationFrameId = 0;
    this.deltaX = 0;
    this.deltaY = 0;
    this.eventName = Platform.isEventSupported("wheel") ? "wheel" : "mousewheel";
    this.target = target;
    this.onWheelCallback = onWheelCallback;
    this.onWheelGuard = onWheelGuard;
    this.onWheel = this.onWheel.bind(this);
    this.didWheel = this.didWheel.bind(this);
  }
  enable() {
    this.target.addEventListener(this.eventName, this.onWheel, {
      passive: false
    });
  }
  disable() {
    this.target.removeEventListener(this.eventName, this.onWheel);
  }
  onWheel(e) {
    if (this.onWheelGuard != null && !this.onWheelGuard(e)) {
      return;
    }
    this.deltaX += e.deltaX;
    this.deltaY += e.deltaY;
    e.preventDefault();
    let changed;
    if (this.deltaX !== 0 || this.deltaY !== 0) {
      e.stopPropagation();
      changed = true;
    }
    if (changed === true && this.animationFrameId === 0) {
      this.animationFrameId = requestAnimationFrame(() => {
        this.didWheel(e);
      });
    }
  }
  didWheel(e) {
    this.animationFrameId = 0;
    this.onWheelCallback(e, this.deltaX, this.deltaY);
    this.deltaX = 0;
    this.deltaY = 0;
  }
};

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dom/position.js
function offset(elem) {
  const rect2 = elem.getBoundingClientRect();
  const win = elem.ownerDocument.defaultView;
  return {
    top: rect2.top + win.pageYOffset,
    left: rect2.left + win.pageXOffset
  };
}
function width(elem) {
  const rect2 = elem.getBoundingClientRect();
  return rect2.width;
}
function height(elem) {
  const rect2 = elem.getBoundingClientRect();
  return rect2.height;
}
function position(elem) {
  const isFixed = computeStyle(elem, "position") === "fixed";
  let offsetValue;
  if (isFixed) {
    const rect2 = elem.getBoundingClientRect();
    offsetValue = { left: rect2.left, top: rect2.top };
  } else {
    offsetValue = offset(elem);
  }
  if (!isFixed) {
    const doc = elem.ownerDocument;
    let offsetParent = elem.offsetParent || doc.documentElement;
    while ((offsetParent === doc.body || offsetParent === doc.documentElement) && computeStyle(offsetParent, "position") === "static") {
      offsetParent = offsetParent.parentNode;
    }
    if (offsetParent !== elem && isElement2(offsetParent)) {
      const parentOffset = offset(offsetParent);
      offsetValue.top -= parentOffset.top + computeStyleInt(offsetParent, "borderTopWidth");
      offsetValue.left -= parentOffset.left + computeStyleInt(offsetParent, "borderLeftWidth");
    }
  }
  return {
    top: offsetValue.top - computeStyleInt(elem, "marginTop"),
    left: offsetValue.left - computeStyleInt(elem, "marginLeft")
  };
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/size-sensor/sensors/util.js
function debounce2(fn, delay2 = 60) {
  let timer = null;
  return (...args) => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = window.setTimeout(() => {
      fn.apply(this, args);
    }, delay2);
  };
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/size-sensor/sensors/object.js
function createSensor(element) {
  let sensor = null;
  let listeners = [];
  const create2 = () => {
    if (getComputedStyle(element).position === "static") {
      const style2 = element.style;
      style2.position = "relative";
    }
    const obj = document.createElement("object");
    obj.onload = () => {
      obj.contentDocument.defaultView.addEventListener("resize", trigger);
      trigger();
    };
    obj.style.display = "block";
    obj.style.position = "absolute";
    obj.style.top = "0";
    obj.style.left = "0";
    obj.style.height = "100%";
    obj.style.width = "100%";
    obj.style.overflow = "hidden";
    obj.style.pointerEvents = "none";
    obj.style.zIndex = "-1";
    obj.style.opacity = "0";
    obj.setAttribute("tabindex", "-1");
    obj.type = "text/html";
    element.appendChild(obj);
    obj.data = "about:blank";
    return obj;
  };
  const trigger = debounce2(() => {
    listeners.forEach((listener) => listener(element));
  });
  const bind2 = (listener) => {
    if (!sensor) {
      sensor = create2();
    }
    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };
  const destroy = () => {
    if (sensor && sensor.parentNode) {
      if (sensor.contentDocument) {
        sensor.contentDocument.defaultView.removeEventListener("resize", trigger);
      }
      sensor.parentNode.removeChild(sensor);
      sensor = null;
      listeners = [];
    }
  };
  const unbind = (listener) => {
    const idx = listeners.indexOf(listener);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };
  return {
    element,
    bind: bind2,
    destroy,
    unbind
  };
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/size-sensor/sensors/observer.js
function createSensor2(element) {
  let sensor = null;
  let listeners = [];
  const trigger = debounce2(() => {
    listeners.forEach((listener) => {
      listener(element);
    });
  });
  const create2 = () => {
    const s = new ResizeObserver(trigger);
    s.observe(element);
    trigger();
    return s;
  };
  const bind2 = (listener) => {
    if (!sensor) {
      sensor = create2();
    }
    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };
  const destroy = () => {
    if (sensor) {
      sensor.disconnect();
      listeners = [];
      sensor = null;
    }
  };
  const unbind = (listener) => {
    const idx = listeners.indexOf(listener);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };
  return {
    element,
    bind: bind2,
    destroy,
    unbind
  };
}

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/size-sensor/sensors/index.js
var createSensor3 = typeof ResizeObserver !== "undefined" ? createSensor2 : createSensor;

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/size-sensor/index.js
var SizeSensor;
(function(SizeSensor2) {
  const cache = /* @__PURE__ */ new WeakMap();
  function get2(element) {
    let sensor = cache.get(element);
    if (sensor) {
      return sensor;
    }
    sensor = createSensor3(element);
    cache.set(element, sensor);
    return sensor;
  }
  function remove3(sensor) {
    sensor.destroy();
    cache.delete(sensor.element);
  }
  SizeSensor2.bind = (element, cb) => {
    const sensor = get2(element);
    sensor.bind(cb);
    return () => sensor.unbind(cb);
  };
  SizeSensor2.clear = (element) => {
    const sensor = get2(element);
    remove3(sensor);
  };
})(SizeSensor || (SizeSensor = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/algorithm/priorityqueue.js
var PriorityQueue = class _PriorityQueue {
  constructor(options = {}) {
    this.comparator = options.comparator || _PriorityQueue.defaultComparator;
    this.index = {};
    this.data = options.data || [];
    this.heapify();
  }
  /**
   * Returns `true` if the priority queue is empty, `false` otherwise.
   */
  isEmpty() {
    return this.data.length === 0;
  }
  /**
   * Inserts a value with priority to the queue. Optionally pass a unique
   * id of this item. Passing unique IDs for each item you insert allows
   * you to use the `updatePriority()` operation.
   * @param priority
   * @param value
   * @param id
   */
  insert(priority, value, id) {
    const item = { priority, value };
    const index2 = this.data.length;
    if (id) {
      item.id = id;
      this.index[id] = index2;
    }
    this.data.push(item);
    this.bubbleUp(index2);
    return this;
  }
  /**
   * Returns the value of an item with the highest priority.
   */
  peek() {
    return this.data[0] ? this.data[0].value : null;
  }
  /**
   * Returns the highest priority in the queue.
   */
  peekPriority() {
    return this.data[0] ? this.data[0].priority : null;
  }
  updatePriority(id, priority) {
    const index2 = this.index[id];
    if (typeof index2 === "undefined") {
      throw new Error(`Node with id '${id}' was not found in the heap.`);
    }
    const data2 = this.data;
    const oldPriority = data2[index2].priority;
    const comp = this.comparator(priority, oldPriority);
    if (comp < 0) {
      data2[index2].priority = priority;
      this.bubbleUp(index2);
    } else if (comp > 0) {
      data2[index2].priority = priority;
      this.bubbleDown(index2);
    }
  }
  /**
   * Removes the item with the highest priority from the queue
   *
   * @returns The value of the removed item.
   */
  remove() {
    const data2 = this.data;
    const peek = data2[0];
    const last2 = data2.pop();
    if (peek.id) {
      delete this.index[peek.id];
    }
    if (data2.length > 0) {
      data2[0] = last2;
      if (last2.id) {
        this.index[last2.id] = 0;
      }
      this.bubbleDown(0);
    }
    return peek ? peek.value : null;
  }
  heapify() {
    for (let i = 0; i < this.data.length; i += 1) {
      this.bubbleUp(i);
    }
  }
  bubbleUp(index2) {
    const data2 = this.data;
    let tmp;
    let parent2;
    let current = index2;
    while (current > 0) {
      parent2 = current - 1 >>> 1;
      if (this.comparator(data2[current].priority, data2[parent2].priority) < 0) {
        tmp = data2[parent2];
        data2[parent2] = data2[current];
        let id = data2[current].id;
        if (id != null) {
          this.index[id] = parent2;
        }
        data2[current] = tmp;
        id = data2[current].id;
        if (id != null) {
          this.index[id] = current;
        }
        current = parent2;
      } else {
        break;
      }
    }
  }
  bubbleDown(index2) {
    const data2 = this.data;
    const last2 = data2.length - 1;
    let current = index2;
    while (true) {
      const left4 = (current << 1) + 1;
      const right4 = left4 + 1;
      let minIndex = current;
      if (left4 <= last2 && this.comparator(data2[left4].priority, data2[minIndex].priority) < 0) {
        minIndex = left4;
      }
      if (right4 <= last2 && this.comparator(data2[right4].priority, data2[minIndex].priority) < 0) {
        minIndex = right4;
      }
      if (minIndex !== current) {
        const tmp = data2[minIndex];
        data2[minIndex] = data2[current];
        let id = data2[current].id;
        if (id != null) {
          this.index[id] = minIndex;
        }
        data2[current] = tmp;
        id = data2[current].id;
        if (id != null) {
          this.index[id] = current;
        }
        current = minIndex;
      } else {
        break;
      }
    }
  }
};
(function(PriorityQueue2) {
  PriorityQueue2.defaultComparator = (a, b) => a - b;
})(PriorityQueue || (PriorityQueue = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/algorithm/dijkstra.js
var Dijkstra;
(function(Dijkstra2) {
  function run(adjacencyList, source, weight = (u, v) => 1) {
    const dist = {};
    const previous = {};
    const scanned = {};
    const queue = new PriorityQueue();
    dist[source] = 0;
    Object.keys(adjacencyList).forEach((v) => {
      if (v !== source) {
        dist[v] = Infinity;
      }
      queue.insert(dist[v], v, v);
    });
    while (!queue.isEmpty()) {
      const u = queue.remove();
      scanned[u] = true;
      const neighbours = adjacencyList[u] || [];
      for (let i = 0; i < neighbours.length; i += 1) {
        const v = neighbours[i];
        if (!scanned[v]) {
          const alt = dist[u] + weight(u, v);
          if (alt < dist[v]) {
            dist[v] = alt;
            previous[v] = u;
            queue.updatePriority(v, alt);
          }
        }
      }
    }
    return previous;
  }
  Dijkstra2.run = run;
})(Dijkstra || (Dijkstra = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/color/index.js
var Color = class _Color {
  constructor(color, g, b, a) {
    if (color == null) {
      return this.set(255, 255, 255, 1);
    }
    if (typeof color === "number") {
      return this.set(color, g, b, a);
    }
    if (typeof color === "string") {
      return _Color.fromString(color) || this;
    }
    if (Array.isArray(color)) {
      return this.set(color);
    }
    this.set(color.r, color.g, color.b, color.a == null ? 1 : color.a);
  }
  blend(start, end, weight) {
    this.set(start.r + (end.r - start.r) * weight, start.g + (end.g - start.g) * weight, start.b + (end.b - start.b) * weight, start.a + (end.a - start.a) * weight);
  }
  lighten(amount) {
    const rgba = _Color.lighten(this.toArray(), amount);
    this.r = rgba[0];
    this.g = rgba[1];
    this.b = rgba[2];
    this.a = rgba[3];
  }
  darken(amount) {
    this.lighten(-amount);
  }
  set(arg0, arg1, arg2, arg3) {
    const r = Array.isArray(arg0) ? arg0[0] : arg0;
    const g = Array.isArray(arg0) ? arg0[1] : arg1;
    const b = Array.isArray(arg0) ? arg0[2] : arg2;
    const a = Array.isArray(arg0) ? arg0[3] : arg3;
    this.r = Math.round(number_exports.clamp(r, 0, 255));
    this.g = Math.round(number_exports.clamp(g, 0, 255));
    this.b = Math.round(number_exports.clamp(b, 0, 255));
    this.a = a == null ? 1 : number_exports.clamp(a, 0, 1);
    return this;
  }
  toHex() {
    const hex = ["r", "g", "b"].map((key) => {
      const str = this[key].toString(16);
      return str.length < 2 ? `0${str}` : str;
    });
    return `#${hex.join("")}`;
  }
  toRGBA() {
    return this.toArray();
  }
  toHSLA() {
    return _Color.rgba2hsla(this.r, this.g, this.b, this.a);
  }
  toCSS(ignoreAlpha) {
    const rgb = `${this.r},${this.g},${this.b},`;
    return ignoreAlpha ? `rgb(${rgb})` : `rgba(${rgb},${this.a})`;
  }
  toGrey() {
    return _Color.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a);
  }
  toArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toString() {
    return this.toCSS();
  }
};
(function(Color2) {
  function fromArray(arr) {
    return new Color2(arr);
  }
  Color2.fromArray = fromArray;
  function fromHex(color) {
    return new Color2([...hex2rgb(color), 1]);
  }
  Color2.fromHex = fromHex;
  function fromRGBA(color) {
    const matches2 = color.toLowerCase().match(/^rgba?\(([\s.,0-9]+)\)/);
    if (matches2) {
      const arr = matches2[1].split(/\s*,\s*/).map((v) => parseInt(v, 10));
      return new Color2(arr);
    }
    return null;
  }
  Color2.fromRGBA = fromRGBA;
  function hue2rgb(m1, m2, h) {
    if (h < 0) {
      ++h;
    }
    if (h > 1) {
      --h;
    }
    const h6 = 6 * h;
    if (h6 < 1) {
      return m1 + (m2 - m1) * h6;
    }
    if (2 * h < 1) {
      return m2;
    }
    if (3 * h < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
  }
  function fromHSLA(color) {
    const matches2 = color.toLowerCase().match(/^hsla?\(([\s.,0-9]+)\)/);
    if (matches2) {
      const arr = matches2[2].split(/\s*,\s*/);
      const h = (parseFloat(arr[0]) % 360 + 360) % 360 / 360;
      const s = parseFloat(arr[1]) / 100;
      const l = parseFloat(arr[2]) / 100;
      const a = arr[3] == null ? 1 : parseInt(arr[3], 10);
      return new Color2(hsla2rgba(h, s, l, a));
    }
    return null;
  }
  Color2.fromHSLA = fromHSLA;
  function fromString(color) {
    if (color.startsWith("#")) {
      return fromHex(color);
    }
    if (color.startsWith("rgb")) {
      return fromRGBA(color);
    }
    const preset = Color2.named[color];
    if (preset) {
      return fromHex(preset);
    }
    return fromHSLA(color);
  }
  Color2.fromString = fromString;
  function makeGrey(g, a) {
    return Color2.fromArray([g, g, g, a]);
  }
  Color2.makeGrey = makeGrey;
  function rgba2hsla(arg0, arg1, arg2, arg3) {
    const r = Array.isArray(arg0) ? arg0[0] : arg0;
    const g = Array.isArray(arg0) ? arg0[1] : arg1;
    const b = Array.isArray(arg0) ? arg0[2] : arg2;
    const a = Array.isArray(arg0) ? arg0[3] : arg3;
    const max2 = Math.max(r, g, b);
    const min2 = Math.min(r, g, b);
    const l = (max2 + min2) / 2;
    let h = 0;
    let s = 0;
    if (min2 !== max2) {
      const d = max2 - min2;
      s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
      switch (max2) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          break;
      }
      h /= 6;
    }
    return [h, s, l, a == null ? 1 : a];
  }
  Color2.rgba2hsla = rgba2hsla;
  function hsla2rgba(arg0, arg1, arg2, arg3) {
    const h = Array.isArray(arg0) ? arg0[0] : arg0;
    const s = Array.isArray(arg0) ? arg0[1] : arg1;
    const l = Array.isArray(arg0) ? arg0[2] : arg2;
    const a = Array.isArray(arg0) ? arg0[3] : arg3;
    const m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    const m1 = 2 * l - m2;
    return [
      hue2rgb(m1, m2, h + 1 / 3) * 256,
      hue2rgb(m1, m2, h) * 256,
      hue2rgb(m1, m2, h - 1 / 3) * 256,
      a == null ? 1 : a
    ];
  }
  Color2.hsla2rgba = hsla2rgba;
  function random3(ignoreAlpha) {
    return new Color2(Math.round(Math.random() * 256), Math.round(Math.random() * 256), Math.round(Math.random() * 256), ignoreAlpha ? void 0 : parseFloat(Math.random().toFixed(2)));
  }
  Color2.random = random3;
  function randomHex() {
    const letters = "0123456789ABCDEF";
    let color = "#";
    for (let i = 0; i < 6; i += 1) {
      color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
  }
  Color2.randomHex = randomHex;
  function randomRGBA(ignoreAlpha) {
    return random3(ignoreAlpha).toString();
  }
  Color2.randomRGBA = randomRGBA;
  function invert3(color, bw) {
    if (typeof color === "string") {
      const pound = color[0] === "#";
      const [r2, g2, b2] = hex2rgb(color);
      if (bw) {
        return r2 * 0.299 + g2 * 0.587 + b2 * 0.114 > 186 ? "#000000" : "#ffffff";
      }
      return `${pound ? "#" : ""}${rgb2hex(255 - r2, 255 - g2, 255 - b2)}`;
    }
    const r = color[0];
    const g = color[1];
    const b = color[2];
    const a = color[3];
    if (bw) {
      return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? [0, 0, 0, a] : [255, 255, 255, a];
    }
    return [255 - r, 255 - g, 255 - b, a];
  }
  Color2.invert = invert3;
  function hex2rgb(hex) {
    const color = hex.indexOf("#") === 0 ? hex : `#${hex}`;
    let val = Number(`0x${color.substr(1)}`);
    if (!(color.length === 4 || color.length === 7) || Number.isNaN(val)) {
      throw new Error("Invalid hex color.");
    }
    const bits = color.length === 4 ? 4 : 8;
    const mask = (1 << bits) - 1;
    const bgr = ["b", "g", "r"].map(() => {
      const c = val & mask;
      val >>= bits;
      return bits === 4 ? 17 * c : c;
    });
    return [bgr[2], bgr[1], bgr[0]];
  }
  function rgb2hex(r, g, b) {
    const pad2 = (hex) => hex.length < 2 ? `0${hex}` : hex;
    return `${pad2(r.toString(16))}${pad2(g.toString(16))}${pad2(b.toString(16))}`;
  }
  function lighten(color, amt) {
    return lum(color, amt);
  }
  Color2.lighten = lighten;
  function darken(color, amt) {
    return lum(color, -amt);
  }
  Color2.darken = darken;
  function lum(color, amt) {
    if (typeof color === "string") {
      const pound = color[0] === "#";
      const num = parseInt(pound ? color.substr(1) : color, 16);
      const r = number_exports.clamp((num >> 16) + amt, 0, 255);
      const g = number_exports.clamp((num >> 8 & 255) + amt, 0, 255);
      const b = number_exports.clamp((num & 255) + amt, 0, 255);
      return `${pound ? "#" : ""}${(b | g << 8 | r << 16).toString(16)}`;
    }
    const hex = rgb2hex(color[0], color[1], color[2]);
    const arr = hex2rgb(lum(hex, amt));
    return [arr[0], arr[1], arr[2], color[3]];
  }
})(Color || (Color = {}));
(function(Color2) {
  Color2.named = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    burntsienna: "#ea7e5d",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
})(Color || (Color = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/dictionary/dictionary.js
var Dictionary = class {
  constructor() {
    this.clear();
  }
  clear() {
    this.map = /* @__PURE__ */ new WeakMap();
    this.arr = [];
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    return this.map.get(key);
  }
  set(key, value) {
    this.map.set(key, value);
    this.arr.push(key);
  }
  delete(key) {
    const index2 = this.arr.indexOf(key);
    if (index2 >= 0) {
      this.arr.splice(index2, 1);
    }
    const ret = this.map.get(key);
    this.map.delete(key);
    return ret;
  }
  each(iterator) {
    this.arr.forEach((key) => {
      const value = this.map.get(key);
      iterator(value, key);
    });
  }
  dispose() {
    this.clear();
  }
};

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/modifier/index.js
var ModifierKey;
(function(ModifierKey2) {
  function parse2(modifiers) {
    const or = [];
    const and = [];
    if (Array.isArray(modifiers)) {
      or.push(...modifiers);
    } else {
      modifiers.split("|").forEach((item) => {
        if (item.indexOf("&") === -1) {
          or.push(item);
        } else {
          and.push(...item.split("&"));
        }
      });
    }
    return { or, and };
  }
  ModifierKey2.parse = parse2;
  function equals(modifiers1, modifiers2) {
    if (modifiers1 != null && modifiers2 != null) {
      const m1 = parse2(modifiers1);
      const m2 = parse2(modifiers2);
      const or1 = m1.or.sort();
      const or2 = m2.or.sort();
      const and1 = m1.and.sort();
      const and2 = m2.and.sort();
      const equal = (a1, a2) => {
        return a1.length === a2.length && (a1.length === 0 || a1.every((a, i) => a === a2[i]));
      };
      return equal(or1, or2) && equal(and1, and2);
    }
    if (modifiers1 == null && modifiers2 == null) {
      return true;
    }
    return false;
  }
  ModifierKey2.equals = equals;
  function isMatch2(e, modifiers, strict) {
    if (modifiers == null || Array.isArray(modifiers) && modifiers.length === 0) {
      return strict ? e.altKey !== true && e.ctrlKey !== true && e.metaKey !== true && e.shiftKey !== true : true;
    }
    const { or, and } = parse2(modifiers);
    const match = (key) => {
      const name = `${key.toLowerCase()}Key`;
      return e[name] === true;
    };
    return or.some((key) => match(key)) && and.every((key) => match(key));
  }
  ModifierKey2.isMatch = isMatch2;
})(ModifierKey || (ModifierKey = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/animation/timing.js
var Timing;
(function(Timing2) {
  Timing2.linear = (t) => t;
  Timing2.quad = (t) => t * t;
  Timing2.cubic = (t) => t * t * t;
  Timing2.inout = (t) => {
    if (t <= 0) {
      return 0;
    }
    if (t >= 1) {
      return 1;
    }
    const t2 = t * t;
    const t3 = t2 * t;
    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
  };
  Timing2.exponential = (t) => {
    return Math.pow(2, 10 * (t - 1));
  };
  Timing2.bounce = (t) => {
    for (let a = 0, b = 1; 1; a += b, b /= 2) {
      if (t >= (7 - 4 * a) / 11) {
        const q = (11 - 6 * a - 11 * t) / 4;
        return -q * q + b * b;
      }
    }
  };
})(Timing || (Timing = {}));
(function(Timing2) {
  Timing2.decorators = {
    reverse(f) {
      return (t) => 1 - f(1 - t);
    },
    reflect(f) {
      return (t) => 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
    },
    clamp(f, n = 0, x = 1) {
      return (t) => {
        const r = f(t);
        return r < n ? n : r > x ? x : r;
      };
    },
    back(s = 1.70158) {
      return (t) => t * t * ((s + 1) * t - s);
    },
    elastic(x = 1.5) {
      return (t) => Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);
    }
  };
})(Timing || (Timing = {}));
(function(Timing2) {
  function easeInSine(t) {
    return -1 * Math.cos(t * (Math.PI / 2)) + 1;
  }
  Timing2.easeInSine = easeInSine;
  function easeOutSine(t) {
    return Math.sin(t * (Math.PI / 2));
  }
  Timing2.easeOutSine = easeOutSine;
  function easeInOutSine(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
  }
  Timing2.easeInOutSine = easeInOutSine;
  function easeInQuad(t) {
    return t * t;
  }
  Timing2.easeInQuad = easeInQuad;
  function easeOutQuad(t) {
    return t * (2 - t);
  }
  Timing2.easeOutQuad = easeOutQuad;
  function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
  Timing2.easeInOutQuad = easeInOutQuad;
  function easeInCubic(t) {
    return t * t * t;
  }
  Timing2.easeInCubic = easeInCubic;
  function easeOutCubic(t) {
    const t1 = t - 1;
    return t1 * t1 * t1 + 1;
  }
  Timing2.easeOutCubic = easeOutCubic;
  function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }
  Timing2.easeInOutCubic = easeInOutCubic;
  function easeInQuart(t) {
    return t * t * t * t;
  }
  Timing2.easeInQuart = easeInQuart;
  function easeOutQuart(t) {
    const t1 = t - 1;
    return 1 - t1 * t1 * t1 * t1;
  }
  Timing2.easeOutQuart = easeOutQuart;
  function easeInOutQuart(t) {
    const t1 = t - 1;
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * t1 * t1 * t1 * t1;
  }
  Timing2.easeInOutQuart = easeInOutQuart;
  function easeInQuint(t) {
    return t * t * t * t * t;
  }
  Timing2.easeInQuint = easeInQuint;
  function easeOutQuint(t) {
    const t1 = t - 1;
    return 1 + t1 * t1 * t1 * t1 * t1;
  }
  Timing2.easeOutQuint = easeOutQuint;
  function easeInOutQuint(t) {
    const t1 = t - 1;
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * t1 * t1 * t1 * t1 * t1;
  }
  Timing2.easeInOutQuint = easeInOutQuint;
  function easeInExpo(t) {
    if (t === 0) {
      return 0;
    }
    return Math.pow(2, 10 * (t - 1));
  }
  Timing2.easeInExpo = easeInExpo;
  function easeOutExpo(t) {
    if (t === 1) {
      return 1;
    }
    return -Math.pow(2, -10 * t) + 1;
  }
  Timing2.easeOutExpo = easeOutExpo;
  function easeInOutExpo(t) {
    if (t === 0 || t === 1) {
      return t;
    }
    const scaledTime = t * 2;
    const scaledTime1 = scaledTime - 1;
    if (scaledTime < 1) {
      return 0.5 * Math.pow(2, 10 * scaledTime1);
    }
    return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2);
  }
  Timing2.easeInOutExpo = easeInOutExpo;
  function easeInCirc(t) {
    const scaledTime = t / 1;
    return -1 * (Math.sqrt(1 - scaledTime * t) - 1);
  }
  Timing2.easeInCirc = easeInCirc;
  function easeOutCirc(t) {
    const t1 = t - 1;
    return Math.sqrt(1 - t1 * t1);
  }
  Timing2.easeOutCirc = easeOutCirc;
  function easeInOutCirc(t) {
    const scaledTime = t * 2;
    const scaledTime1 = scaledTime - 2;
    if (scaledTime < 1) {
      return -0.5 * (Math.sqrt(1 - scaledTime * scaledTime) - 1);
    }
    return 0.5 * (Math.sqrt(1 - scaledTime1 * scaledTime1) + 1);
  }
  Timing2.easeInOutCirc = easeInOutCirc;
  function easeInBack(t, magnitude = 1.70158) {
    return t * t * ((magnitude + 1) * t - magnitude);
  }
  Timing2.easeInBack = easeInBack;
  function easeOutBack(t, magnitude = 1.70158) {
    const scaledTime = t / 1 - 1;
    return scaledTime * scaledTime * ((magnitude + 1) * scaledTime + magnitude) + 1;
  }
  Timing2.easeOutBack = easeOutBack;
  function easeInOutBack(t, magnitude = 1.70158) {
    const scaledTime = t * 2;
    const scaledTime2 = scaledTime - 2;
    const s = magnitude * 1.525;
    if (scaledTime < 1) {
      return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s);
    }
    return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2);
  }
  Timing2.easeInOutBack = easeInOutBack;
  function easeInElastic(t, magnitude = 0.7) {
    if (t === 0 || t === 1) {
      return t;
    }
    const scaledTime = t / 1;
    const scaledTime1 = scaledTime - 1;
    const p = 1 - magnitude;
    const s = p / (2 * Math.PI) * Math.asin(1);
    return -(Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
    Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));
  }
  Timing2.easeInElastic = easeInElastic;
  function easeOutElastic(t, magnitude = 0.7) {
    const p = 1 - magnitude;
    const scaledTime = t * 2;
    if (t === 0 || t === 1) {
      return t;
    }
    const s = p / (2 * Math.PI) * Math.asin(1);
    return Math.pow(2, -10 * scaledTime) * // eslint-disable-line
    Math.sin((scaledTime - s) * (2 * Math.PI) / p) + 1;
  }
  Timing2.easeOutElastic = easeOutElastic;
  function easeInOutElastic(t, magnitude = 0.65) {
    const p = 1 - magnitude;
    if (t === 0 || t === 1) {
      return t;
    }
    const scaledTime = t * 2;
    const scaledTime1 = scaledTime - 1;
    const s = p / (2 * Math.PI) * Math.asin(1);
    if (scaledTime < 1) {
      return -0.5 * (Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
      Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));
    }
    return Math.pow(2, -10 * scaledTime1) * // eslint-disable-line
    Math.sin((scaledTime1 - s) * (2 * Math.PI) / p) * 0.5 + 1;
  }
  Timing2.easeInOutElastic = easeInOutElastic;
  function easeOutBounce(t) {
    const scaledTime = t / 1;
    if (scaledTime < 1 / 2.75) {
      return 7.5625 * scaledTime * scaledTime;
    }
    if (scaledTime < 2 / 2.75) {
      const scaledTime2 = scaledTime - 1.5 / 2.75;
      return 7.5625 * scaledTime2 * scaledTime2 + 0.75;
    }
    if (scaledTime < 2.5 / 2.75) {
      const scaledTime2 = scaledTime - 2.25 / 2.75;
      return 7.5625 * scaledTime2 * scaledTime2 + 0.9375;
    }
    {
      const scaledTime2 = scaledTime - 2.625 / 2.75;
      return 7.5625 * scaledTime2 * scaledTime2 + 0.984375;
    }
  }
  Timing2.easeOutBounce = easeOutBounce;
  function easeInBounce(t) {
    return 1 - easeOutBounce(1 - t);
  }
  Timing2.easeInBounce = easeInBounce;
  function easeInOutBounce(t) {
    if (t < 0.5) {
      return easeInBounce(t * 2) * 0.5;
    }
    return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
  }
  Timing2.easeInOutBounce = easeInOutBounce;
})(Timing || (Timing = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/animation/interp.js
var Interp;
(function(Interp2) {
  Interp2.number = (a, b) => {
    const d = b - a;
    return (t) => {
      return a + d * t;
    };
  };
  Interp2.object = (a, b) => {
    const keys2 = Object.keys(a);
    return (t) => {
      const ret = {};
      for (let i = keys2.length - 1; i !== -1; i -= 1) {
        const key = keys2[i];
        ret[key] = a[key] + (b[key] - a[key]) * t;
      }
      return ret;
    };
  };
  Interp2.unit = (a, b) => {
    const reg = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
    const ma = reg.exec(a);
    const mb = reg.exec(b);
    const pb = mb ? mb[1] : "";
    const aa = ma ? +ma[1] : 0;
    const bb = mb ? +mb[1] : 0;
    const index2 = pb.indexOf(".");
    const precision = index2 > 0 ? pb[1].length - index2 - 1 : 0;
    const d = bb - aa;
    const u = ma ? ma[2] : "";
    return (t) => {
      return (aa + d * t).toFixed(precision) + u;
    };
  };
  Interp2.color = (a, b) => {
    const ca = parseInt(a.slice(1), 16);
    const cb = parseInt(b.slice(1), 16);
    const ra = ca & 255;
    const rd = (cb & 255) - ra;
    const ga = ca & 65280;
    const gd = (cb & 65280) - ga;
    const ba = ca & 16711680;
    const bd = (cb & 16711680) - ba;
    return (t) => {
      const r = ra + rd * t & 255;
      const g = ga + gd * t & 65280;
      const b2 = ba + bd * t & 16711680;
      return `#${(1 << 24 | r | g | b2).toString(16).slice(1)}`;
    };
  };
})(Interp || (Interp = {}));

// ../node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/es/css-loader/loader.js
var loader_exports = {};
__export(loader_exports, {
  clean: () => clean,
  ensure: () => ensure2
});
var cssModules = [];
function ensure2(name, content2) {
  const cssModule = cssModules.find((m) => m.name === name);
  if (cssModule) {
    cssModule.loadTimes += 1;
    if (cssModule.loadTimes > 1) {
      return;
    }
  }
  if (!Platform.isApplyingHMR()) {
    const styleElement = document.createElement("style");
    styleElement.setAttribute("type", "text/css");
    styleElement.textContent = content2;
    const head2 = document.querySelector("head");
    if (head2) {
      head2.insertBefore(styleElement, head2.firstChild);
    }
    cssModules.push({
      name,
      loadTimes: 1,
      styleElement
    });
  }
}
function clean(name) {
  const index2 = cssModules.findIndex((m) => m.name === name);
  if (index2 > -1) {
    const cssModule = cssModules[index2];
    cssModule.loadTimes -= 1;
    if (cssModule.loadTimes > 0) {
      return;
    }
    let styleElement = cssModule.styleElement;
    if (styleElement && styleElement.parentNode) {
      styleElement.parentNode.removeChild(styleElement);
    }
    styleElement = null;
    cssModules.splice(index2, 1);
  }
}

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/angle.js
var Angle;
(function(Angle2) {
  function toDeg(rad) {
    return 180 * rad / Math.PI % 360;
  }
  Angle2.toDeg = toDeg;
  Angle2.toRad = function(deg, over360 = false) {
    const d = over360 ? deg : deg % 360;
    return d * Math.PI / 180;
  };
  function normalize3(angle) {
    return angle % 360 + (angle < 0 ? 360 : 0);
  }
  Angle2.normalize = normalize3;
})(Angle || (Angle = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/util.js
var GeometryUtil;
(function(GeometryUtil2) {
  function round3(num, precision = 0) {
    return Number.isInteger(num) ? num : +num.toFixed(precision);
  }
  GeometryUtil2.round = round3;
  function random3(min2, max2) {
    let mmin;
    let mmax;
    if (max2 == null) {
      mmax = min2 == null ? 1 : min2;
      mmin = 0;
    } else {
      mmax = max2;
      mmin = min2 == null ? 0 : min2;
    }
    if (mmax < mmin) {
      const temp = mmin;
      mmin = mmax;
      mmax = temp;
    }
    return Math.floor(Math.random() * (mmax - mmin + 1) + mmin);
  }
  GeometryUtil2.random = random3;
  function clamp2(value, min2, max2) {
    if (Number.isNaN(value)) {
      return NaN;
    }
    if (Number.isNaN(min2) || Number.isNaN(max2)) {
      return 0;
    }
    return min2 < max2 ? value < min2 ? min2 : value > max2 ? max2 : value : value < max2 ? max2 : value > min2 ? min2 : value;
  }
  GeometryUtil2.clamp = clamp2;
  function snapToGrid(value, gridSize) {
    return gridSize * Math.round(value / gridSize);
  }
  GeometryUtil2.snapToGrid = snapToGrid;
  function containsPoint(rect2, point) {
    return point != null && rect2 != null && point.x >= rect2.x && point.x <= rect2.x + rect2.width && point.y >= rect2.y && point.y <= rect2.y + rect2.height;
  }
  GeometryUtil2.containsPoint = containsPoint;
  function squaredLength(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return dx * dx + dy * dy;
  }
  GeometryUtil2.squaredLength = squaredLength;
})(GeometryUtil || (GeometryUtil = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/geometry.js
var Geometry = class {
  valueOf() {
    return this.toJSON();
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/point.js
var Point = class _Point extends Geometry {
  constructor(x, y) {
    super();
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
  }
  /**
   * Rounds the point to the given precision.
   */
  round(precision = 0) {
    this.x = GeometryUtil.round(this.x, precision);
    this.y = GeometryUtil.round(this.y, precision);
    return this;
  }
  add(x, y) {
    const p = _Point.create(x, y);
    this.x += p.x;
    this.y += p.y;
    return this;
  }
  update(x, y) {
    const p = _Point.create(x, y);
    this.x = p.x;
    this.y = p.y;
    return this;
  }
  translate(dx, dy) {
    const t = _Point.create(dx, dy);
    this.x += t.x;
    this.y += t.y;
    return this;
  }
  /**
   * Rotate the point by `degree` around `center`.
   */
  rotate(degree, center2) {
    const p = _Point.rotate(this, degree, center2);
    this.x = p.x;
    this.y = p.y;
    return this;
  }
  /**
   * Scale point by `sx` and `sy` around the given `origin`. If origin is
   * not specified, the point is scaled around `0, 0`.
   */
  scale(sx, sy, origin = new _Point()) {
    const ref2 = _Point.create(origin);
    this.x = ref2.x + sx * (this.x - ref2.x);
    this.y = ref2.y + sy * (this.y - ref2.y);
    return this;
  }
  /**
   * Chooses the point closest to this point from among `points`. If `points`
   * is an empty array, `null` is returned.
   */
  closest(points) {
    if (points.length === 1) {
      return _Point.create(points[0]);
    }
    let ret = null;
    let min2 = Infinity;
    points.forEach((p) => {
      const dist = this.squaredDistance(p);
      if (dist < min2) {
        ret = p;
        min2 = dist;
      }
    });
    return ret ? _Point.create(ret) : null;
  }
  /**
   * Returns the distance between the point and another point `p`.
   */
  distance(p) {
    return Math.sqrt(this.squaredDistance(p));
  }
  /**
   * Returns the squared distance between the point and another point `p`.
   *
   * Useful for distance comparisons in which real distance is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredDistance(p) {
    const ref2 = _Point.create(p);
    const dx = this.x - ref2.x;
    const dy = this.y - ref2.y;
    return dx * dx + dy * dy;
  }
  manhattanDistance(p) {
    const ref2 = _Point.create(p);
    return Math.abs(ref2.x - this.x) + Math.abs(ref2.y - this.y);
  }
  /**
   * Returns the magnitude of the point vector.
   *
   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
   */
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p` and
   * the x-axis.
   */
  theta(p = new _Point()) {
    const ref2 = _Point.create(p);
    const y = -(ref2.y - this.y);
    const x = ref2.x - this.x;
    let rad = Math.atan2(y, x);
    if (rad < 0) {
      rad = 2 * Math.PI + rad;
    }
    return 180 * rad / Math.PI;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p1` and
   * the vector from this point to `p2`.
   *
   * The ordering of points `p1` and `p2` is important.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from `p1` to `p2`) is clockwise, and a value between `180` and
   * `360` when the angle is counterclockwise.
   *
   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
   */
  angleBetween(p1, p2) {
    if (this.equals(p1) || this.equals(p2)) {
      return NaN;
    }
    let angle = this.theta(p2) - this.theta(p1);
    if (angle < 0) {
      angle += 360;
    }
    return angle;
  }
  /**
   * Returns the angle(in degrees) between the line from `(0,0)` and this point
   * and the line from `(0,0)` to `p`.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from this point to `p`) is clockwise, and a value between `180`
   * and `360` when the angle is counterclockwise. Returns `NaN` if called from
   * point `(0,0)` or if `p` is `(0,0)`.
   */
  vectorAngle(p) {
    const zero = new _Point(0, 0);
    return zero.angleBetween(this, p);
  }
  /**
   * Converts rectangular to polar coordinates.
   */
  toPolar(origin) {
    this.update(_Point.toPolar(this, origin));
    return this;
  }
  /**
   * Returns the change in angle(in degrees) that is the result of moving the
   * point from its previous position to its current position.
   *
   * More specifically, this function computes the angle between the line from
   * the ref point to the previous position of this point(i.e. current position
   * `-dx`, `-dy`) and the line from the `ref` point to the current position of
   * this point.
   *
   * The function returns a positive value between `0` and `180` when the angle
   * (in the direction from previous position of this point to its current
   * position) is clockwise, and a negative value between `0` and `-180` when
   * the angle is counterclockwise.
   *
   * The function returns `0` if the previous and current positions of this
   * point are the same (i.e. both `dx` and `dy` are `0`).
   */
  changeInAngle(dx, dy, ref2 = new _Point()) {
    return this.clone().translate(-dx, -dy).theta(ref2) - this.theta(ref2);
  }
  /**
   * If the point lies outside the rectangle `rect`, adjust the point so that
   * it becomes the nearest point on the boundary of `rect`.
   */
  adhereToRect(rect2) {
    if (!GeometryUtil.containsPoint(rect2, this)) {
      this.x = Math.min(Math.max(this.x, rect2.x), rect2.x + rect2.width);
      this.y = Math.min(Math.max(this.y, rect2.y), rect2.y + rect2.height);
    }
    return this;
  }
  /**
   * Returns the bearing(cardinal direction) between me and the given point.
   *
   * @see https://en.wikipedia.org/wiki/Cardinal_direction
   */
  bearing(p) {
    const ref2 = _Point.create(p);
    const lat1 = Angle.toRad(this.y);
    const lat2 = Angle.toRad(ref2.y);
    const lon1 = this.x;
    const lon2 = ref2.x;
    const dLon = Angle.toRad(lon2 - lon1);
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    const brng = Angle.toDeg(Math.atan2(y, x));
    const bearings = ["NE", "E", "SE", "S", "SW", "W", "NW", "N"];
    let index2 = brng - 22.5;
    if (index2 < 0) {
      index2 += 360;
    }
    index2 = parseInt(index2 / 45, 10);
    return bearings[index2];
  }
  /**
   * Returns the cross product of the vector from me to `p1` and the vector
   * from me to `p2`.
   *
   * The left-hand rule is used because the coordinate system is left-handed.
   */
  cross(p1, p2) {
    if (p1 != null && p2 != null) {
      const a = _Point.create(p1);
      const b = _Point.create(p2);
      return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);
    }
    return NaN;
  }
  /**
   * Returns the dot product of this point with given other point.
   */
  dot(p) {
    const ref2 = _Point.create(p);
    return this.x * ref2.x + this.y * ref2.y;
  }
  diff(dx, dy) {
    if (typeof dx === "number") {
      return new _Point(this.x - dx, this.y - dy);
    }
    const p = _Point.create(dx);
    return new _Point(this.x - p.x, this.y - p.y);
  }
  /**
   * Returns an interpolation between me and point `p` for a parametert in
   * the closed interval `[0, 1]`.
   */
  lerp(p, t) {
    const ref2 = _Point.create(p);
    return new _Point((1 - t) * this.x + t * ref2.x, (1 - t) * this.y + t * ref2.y);
  }
  /**
   * Normalize the point vector, scale the line segment between `(0, 0)`
   * and the point in order for it to have the given length. If length is
   * not specified, it is considered to be `1`; in that case, a unit vector
   * is computed.
   */
  normalize(length2 = 1) {
    const scale2 = length2 / this.magnitude();
    return this.scale(scale2, scale2);
  }
  /**
   * Moves this point along the line starting from `ref` to this point by a
   * certain `distance`.
   */
  move(ref2, distance) {
    const p = _Point.create(ref2);
    const rad = Angle.toRad(p.theta(this));
    return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);
  }
  /**
   * Returns a point that is the reflection of me with the center of inversion
   * in `ref` point.
   */
  reflection(ref2) {
    return _Point.create(ref2).move(this, this.distance(ref2));
  }
  snapToGrid(gx, gy) {
    this.x = GeometryUtil.snapToGrid(this.x, gx);
    this.y = GeometryUtil.snapToGrid(this.y, gy == null ? gx : gy);
    return this;
  }
  equals(p) {
    const ref2 = _Point.create(p);
    return ref2 != null && ref2.x === this.x && ref2.y === this.y;
  }
  clone() {
    return _Point.clone(this);
  }
  /**
   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
   */
  toJSON() {
    return _Point.toJSON(this);
  }
  serialize() {
    return `${this.x} ${this.y}`;
  }
};
(function(Point2) {
  function isPoint(instance) {
    return instance != null && instance instanceof Point2;
  }
  Point2.isPoint = isPoint;
})(Point || (Point = {}));
(function(Point2) {
  function isPointLike(p) {
    return p != null && typeof p === "object" && typeof p.x === "number" && typeof p.y === "number";
  }
  Point2.isPointLike = isPointLike;
  function isPointData(p) {
    return p != null && Array.isArray(p) && p.length === 2 && typeof p[0] === "number" && typeof p[1] === "number";
  }
  Point2.isPointData = isPointData;
})(Point || (Point = {}));
(function(Point2) {
  function create2(x, y) {
    if (x == null || typeof x === "number") {
      return new Point2(x, y);
    }
    return clone2(x);
  }
  Point2.create = create2;
  function clone2(p) {
    if (Point2.isPoint(p)) {
      return new Point2(p.x, p.y);
    }
    if (Array.isArray(p)) {
      return new Point2(p[0], p[1]);
    }
    return new Point2(p.x, p.y);
  }
  Point2.clone = clone2;
  function toJSON(p) {
    if (Point2.isPoint(p)) {
      return { x: p.x, y: p.y };
    }
    if (Array.isArray(p)) {
      return { x: p[0], y: p[1] };
    }
    return { x: p.x, y: p.y };
  }
  Point2.toJSON = toJSON;
  function fromPolar(r, rad, origin = new Point2()) {
    let x = Math.abs(r * Math.cos(rad));
    let y = Math.abs(r * Math.sin(rad));
    const org = clone2(origin);
    const deg = Angle.normalize(Angle.toDeg(rad));
    if (deg < 90) {
      y = -y;
    } else if (deg < 180) {
      x = -x;
      y = -y;
    } else if (deg < 270) {
      x = -x;
    }
    return new Point2(org.x + x, org.y + y);
  }
  Point2.fromPolar = fromPolar;
  function toPolar(point, origin = new Point2()) {
    const p = clone2(point);
    const o = clone2(origin);
    const dx = p.x - o.x;
    const dy = p.y - o.y;
    return new Point2(
      Math.sqrt(dx * dx + dy * dy),
      // r
      Angle.toRad(o.theta(p))
    );
  }
  Point2.toPolar = toPolar;
  function equals(p1, p2) {
    if (p1 === p2) {
      return true;
    }
    if (p1 != null && p2 != null) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    return false;
  }
  Point2.equals = equals;
  function equalPoints(p1, p2) {
    if (p1 == null && p2 != null || p1 != null && p2 == null || p1 != null && p2 != null && p1.length !== p2.length) {
      return false;
    }
    if (p1 != null && p2 != null) {
      for (let i = 0, ii = p1.length; i < ii; i += 1) {
        if (!equals(p1[i], p2[i])) {
          return false;
        }
      }
    }
    return true;
  }
  Point2.equalPoints = equalPoints;
  function random3(x1, x2, y1, y2) {
    return new Point2(GeometryUtil.random(x1, x2), GeometryUtil.random(y1, y2));
  }
  Point2.random = random3;
  function rotate3(point, angle, center2) {
    const rad = Angle.toRad(Angle.normalize(-angle));
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    return rotateEx(point, cos, sin, center2);
  }
  Point2.rotate = rotate3;
  function rotateEx(point, cos, sin, center2 = new Point2()) {
    const source = clone2(point);
    const origin = clone2(center2);
    const dx = source.x - origin.x;
    const dy = source.y - origin.y;
    const x1 = dx * cos - dy * sin;
    const y1 = dy * cos + dx * sin;
    return new Point2(x1 + origin.x, y1 + origin.y);
  }
  Point2.rotateEx = rotateEx;
})(Point || (Point = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/rectangle.js
var Rectangle = class _Rectangle extends Geometry {
  get left() {
    return this.x;
  }
  get top() {
    return this.y;
  }
  get right() {
    return this.x + this.width;
  }
  get bottom() {
    return this.y + this.height;
  }
  get origin() {
    return new Point(this.x, this.y);
  }
  get topLeft() {
    return new Point(this.x, this.y);
  }
  get topCenter() {
    return new Point(this.x + this.width / 2, this.y);
  }
  get topRight() {
    return new Point(this.x + this.width, this.y);
  }
  get center() {
    return new Point(this.x + this.width / 2, this.y + this.height / 2);
  }
  get bottomLeft() {
    return new Point(this.x, this.y + this.height);
  }
  get bottomCenter() {
    return new Point(this.x + this.width / 2, this.y + this.height);
  }
  get bottomRight() {
    return new Point(this.x + this.width, this.y + this.height);
  }
  get corner() {
    return new Point(this.x + this.width, this.y + this.height);
  }
  get rightMiddle() {
    return new Point(this.x + this.width, this.y + this.height / 2);
  }
  get leftMiddle() {
    return new Point(this.x, this.y + this.height / 2);
  }
  get topLine() {
    return new Line(this.topLeft, this.topRight);
  }
  get rightLine() {
    return new Line(this.topRight, this.bottomRight);
  }
  get bottomLine() {
    return new Line(this.bottomLeft, this.bottomRight);
  }
  get leftLine() {
    return new Line(this.topLeft, this.bottomLeft);
  }
  constructor(x, y, width2, height2) {
    super();
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
    this.width = width2 == null ? 0 : width2;
    this.height = height2 == null ? 0 : height2;
  }
  getOrigin() {
    return this.origin;
  }
  getTopLeft() {
    return this.topLeft;
  }
  getTopCenter() {
    return this.topCenter;
  }
  getTopRight() {
    return this.topRight;
  }
  getCenter() {
    return this.center;
  }
  getCenterX() {
    return this.x + this.width / 2;
  }
  getCenterY() {
    return this.y + this.height / 2;
  }
  getBottomLeft() {
    return this.bottomLeft;
  }
  getBottomCenter() {
    return this.bottomCenter;
  }
  getBottomRight() {
    return this.bottomRight;
  }
  getCorner() {
    return this.corner;
  }
  getRightMiddle() {
    return this.rightMiddle;
  }
  getLeftMiddle() {
    return this.leftMiddle;
  }
  getTopLine() {
    return this.topLine;
  }
  getRightLine() {
    return this.rightLine;
  }
  getBottomLine() {
    return this.bottomLine;
  }
  getLeftLine() {
    return this.leftLine;
  }
  /**
   * Returns a rectangle that is the bounding box of the rectangle.
   *
   * If `angle` is specified, the bounding box calculation will take into
   * account the rotation of the rectangle by angle degrees around its center.
   */
  bbox(angle) {
    if (!angle) {
      return this.clone();
    }
    const rad = Angle.toRad(angle);
    const st = Math.abs(Math.sin(rad));
    const ct = Math.abs(Math.cos(rad));
    const w = this.width * ct + this.height * st;
    const h = this.width * st + this.height * ct;
    return new _Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);
  }
  round(precision = 0) {
    this.x = GeometryUtil.round(this.x, precision);
    this.y = GeometryUtil.round(this.y, precision);
    this.width = GeometryUtil.round(this.width, precision);
    this.height = GeometryUtil.round(this.height, precision);
    return this;
  }
  add(x, y, width2, height2) {
    const rect2 = _Rectangle.create(x, y, width2, height2);
    const minX = Math.min(this.x, rect2.x);
    const minY = Math.min(this.y, rect2.y);
    const maxX = Math.max(this.x + this.width, rect2.x + rect2.width);
    const maxY = Math.max(this.y + this.height, rect2.y + rect2.height);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = maxY - minY;
    return this;
  }
  update(x, y, width2, height2) {
    const rect2 = _Rectangle.create(x, y, width2, height2);
    this.x = rect2.x;
    this.y = rect2.y;
    this.width = rect2.width;
    this.height = rect2.height;
    return this;
  }
  inflate(dx, dy) {
    const w = dx;
    const h = dy != null ? dy : dx;
    this.x -= w;
    this.y -= h;
    this.width += 2 * w;
    this.height += 2 * h;
    return this;
  }
  snapToGrid(gx, gy) {
    const origin = this.origin.snapToGrid(gx, gy);
    const corner = this.corner.snapToGrid(gx, gy);
    this.x = origin.x;
    this.y = origin.y;
    this.width = corner.x - origin.x;
    this.height = corner.y - origin.y;
    return this;
  }
  translate(tx, ty) {
    const p = Point.create(tx, ty);
    this.x += p.x;
    this.y += p.y;
    return this;
  }
  scale(sx, sy, origin = new Point()) {
    const pos = this.origin.scale(sx, sy, origin);
    this.x = pos.x;
    this.y = pos.y;
    this.width *= sx;
    this.height *= sy;
    return this;
  }
  rotate(degree, center2 = this.getCenter()) {
    if (degree !== 0) {
      const rad = Angle.toRad(degree);
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      let p1 = this.getOrigin();
      let p2 = this.getTopRight();
      let p3 = this.getBottomRight();
      let p4 = this.getBottomLeft();
      p1 = Point.rotateEx(p1, cos, sin, center2);
      p2 = Point.rotateEx(p2, cos, sin, center2);
      p3 = Point.rotateEx(p3, cos, sin, center2);
      p4 = Point.rotateEx(p4, cos, sin, center2);
      const rect2 = new _Rectangle(p1.x, p1.y, 0, 0);
      rect2.add(p2.x, p2.y, 0, 0);
      rect2.add(p3.x, p3.y, 0, 0);
      rect2.add(p4.x, p4.y, 0, 0);
      this.update(rect2);
    }
    return this;
  }
  rotate90() {
    const t = (this.width - this.height) / 2;
    this.x += t;
    this.y -= t;
    const tmp = this.width;
    this.width = this.height;
    this.height = tmp;
    return this;
  }
  /**
   * Translates the rectangle by `rect.x` and `rect.y` and expand it by
   * `rect.width` and `rect.height`.
   */
  moveAndExpand(rect2) {
    const ref2 = _Rectangle.clone(rect2);
    this.x += ref2.x || 0;
    this.y += ref2.y || 0;
    this.width += ref2.width || 0;
    this.height += ref2.height || 0;
    return this;
  }
  /**
   * Returns an object where `sx` and `sy` give the maximum scaling that can be
   * applied to the rectangle so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxScaleToFit(limit, origin = this.center) {
    const rect2 = _Rectangle.clone(limit);
    const ox = origin.x;
    const oy = origin.y;
    let sx1 = Infinity;
    let sx2 = Infinity;
    let sx3 = Infinity;
    let sx4 = Infinity;
    let sy1 = Infinity;
    let sy2 = Infinity;
    let sy3 = Infinity;
    let sy4 = Infinity;
    const p1 = rect2.topLeft;
    if (p1.x < ox) {
      sx1 = (this.x - ox) / (p1.x - ox);
    }
    if (p1.y < oy) {
      sy1 = (this.y - oy) / (p1.y - oy);
    }
    const p2 = rect2.bottomRight;
    if (p2.x > ox) {
      sx2 = (this.x + this.width - ox) / (p2.x - ox);
    }
    if (p2.y > oy) {
      sy2 = (this.y + this.height - oy) / (p2.y - oy);
    }
    const p3 = rect2.topRight;
    if (p3.x > ox) {
      sx3 = (this.x + this.width - ox) / (p3.x - ox);
    }
    if (p3.y < oy) {
      sy3 = (this.y - oy) / (p3.y - oy);
    }
    const p4 = rect2.bottomLeft;
    if (p4.x < ox) {
      sx4 = (this.x - ox) / (p4.x - ox);
    }
    if (p4.y > oy) {
      sy4 = (this.y + this.height - oy) / (p4.y - oy);
    }
    return {
      sx: Math.min(sx1, sx2, sx3, sx4),
      sy: Math.min(sy1, sy2, sy3, sy4)
    };
  }
  /**
   * Returns a number that specifies the maximum scaling that can be applied to
   * the rectangle along both axes so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxUniformScaleToFit(limit, origin = this.center) {
    const scale2 = this.getMaxScaleToFit(limit, origin);
    return Math.min(scale2.sx, scale2.sy);
  }
  containsPoint(x, y) {
    return GeometryUtil.containsPoint(this, Point.create(x, y));
  }
  containsRect(x, y, width2, height2) {
    const b = _Rectangle.create(x, y, width2, height2);
    const x1 = this.x;
    const y1 = this.y;
    const w1 = this.width;
    const h1 = this.height;
    const x2 = b.x;
    const y2 = b.y;
    const w2 = b.width;
    const h2 = b.height;
    if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {
      return false;
    }
    return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;
  }
  /**
   * Returns an array of the intersection points of the rectangle and the line.
   * Return `null` if no intersection exists.
   */
  intersectsWithLine(line2) {
    const rectLines = [
      this.topLine,
      this.rightLine,
      this.bottomLine,
      this.leftLine
    ];
    const points = [];
    const dedupeArr = [];
    rectLines.forEach((l) => {
      const p = line2.intersectsWithLine(l);
      if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {
        points.push(p);
        dedupeArr.push(p.toString());
      }
    });
    return points.length > 0 ? points : null;
  }
  /**
   * Returns the point on the boundary of the rectangle that is the intersection
   * of the rectangle with a line starting in the center the rectangle ending in
   * the point `p`.
   *
   * If `angle` is specified, the intersection will take into account the
   * rotation of the rectangle by `angle` degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(p, angle) {
    const ref2 = Point.clone(p);
    const center2 = this.center;
    let result2 = null;
    if (angle != null && angle !== 0) {
      ref2.rotate(angle, center2);
    }
    const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];
    const connector = new Line(center2, ref2);
    for (let i = sides.length - 1; i >= 0; i -= 1) {
      const intersection2 = sides[i].intersectsWithLine(connector);
      if (intersection2 !== null) {
        result2 = intersection2;
        break;
      }
    }
    if (result2 && angle != null && angle !== 0) {
      result2.rotate(-angle, center2);
    }
    return result2;
  }
  intersectsWithRect(x, y, width2, height2) {
    const ref2 = _Rectangle.create(x, y, width2, height2);
    if (!this.isIntersectWithRect(ref2)) {
      return null;
    }
    const myOrigin = this.origin;
    const myCorner = this.corner;
    const rOrigin = ref2.origin;
    const rCorner = ref2.corner;
    const xx = Math.max(myOrigin.x, rOrigin.x);
    const yy = Math.max(myOrigin.y, rOrigin.y);
    return new _Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);
  }
  isIntersectWithRect(x, y, width2, height2) {
    const ref2 = _Rectangle.create(x, y, width2, height2);
    const myOrigin = this.origin;
    const myCorner = this.corner;
    const rOrigin = ref2.origin;
    const rCorner = ref2.corner;
    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) {
      return false;
    }
    return true;
  }
  /**
   * Normalize the rectangle, i.e. make it so that it has non-negative
   * width and height. If width is less than `0`, the function swaps left and
   * right corners and if height is less than `0`, the top and bottom corners
   * are swapped.
   */
  normalize() {
    let newx = this.x;
    let newy = this.y;
    let newwidth = this.width;
    let newheight = this.height;
    if (this.width < 0) {
      newx = this.x + this.width;
      newwidth = -this.width;
    }
    if (this.height < 0) {
      newy = this.y + this.height;
      newheight = -this.height;
    }
    this.x = newx;
    this.y = newy;
    this.width = newwidth;
    this.height = newheight;
    return this;
  }
  /**
   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
   */
  union(rect2) {
    const ref2 = _Rectangle.clone(rect2);
    const myOrigin = this.origin;
    const myCorner = this.corner;
    const rOrigin = ref2.origin;
    const rCorner = ref2.corner;
    const originX = Math.min(myOrigin.x, rOrigin.x);
    const originY = Math.min(myOrigin.y, rOrigin.y);
    const cornerX = Math.max(myCorner.x, rCorner.x);
    const cornerY = Math.max(myCorner.y, rCorner.y);
    return new _Rectangle(originX, originY, cornerX - originX, cornerY - originY);
  }
  /**
   * Returns a string ("top", "left", "right" or "bottom") denoting the side of
   * the rectangle which is nearest to the point `p`.
   */
  getNearestSideToPoint(p) {
    const ref2 = Point.clone(p);
    const distLeft = ref2.x - this.x;
    const distRight = this.x + this.width - ref2.x;
    const distTop = ref2.y - this.y;
    const distBottom = this.y + this.height - ref2.y;
    let closest2 = distLeft;
    let side = "left";
    if (distRight < closest2) {
      closest2 = distRight;
      side = "right";
    }
    if (distTop < closest2) {
      closest2 = distTop;
      side = "top";
    }
    if (distBottom < closest2) {
      side = "bottom";
    }
    return side;
  }
  /**
   * Returns a point on the boundary of the rectangle nearest to the point `p`.
   */
  getNearestPointToPoint(p) {
    const ref2 = Point.clone(p);
    if (this.containsPoint(ref2)) {
      const side = this.getNearestSideToPoint(ref2);
      if (side === "left") {
        return new Point(this.x, ref2.y);
      }
      if (side === "top") {
        return new Point(ref2.x, this.y);
      }
      if (side === "right") {
        return new Point(this.x + this.width, ref2.y);
      }
      if (side === "bottom") {
        return new Point(ref2.x, this.y + this.height);
      }
    }
    return ref2.adhereToRect(this);
  }
  equals(rect2) {
    return rect2 != null && rect2.x === this.x && rect2.y === this.y && rect2.width === this.width && rect2.height === this.height;
  }
  clone() {
    return new _Rectangle(this.x, this.y, this.width, this.height);
  }
  toJSON() {
    return { x: this.x, y: this.y, width: this.width, height: this.height };
  }
  serialize() {
    return `${this.x} ${this.y} ${this.width} ${this.height}`;
  }
};
(function(Rectangle2) {
  function isRectangle(instance) {
    return instance != null && instance instanceof Rectangle2;
  }
  Rectangle2.isRectangle = isRectangle;
})(Rectangle || (Rectangle = {}));
(function(Rectangle2) {
  function isRectangleLike(o) {
    return o != null && typeof o === "object" && typeof o.x === "number" && typeof o.y === "number" && typeof o.width === "number" && typeof o.height === "number";
  }
  Rectangle2.isRectangleLike = isRectangleLike;
})(Rectangle || (Rectangle = {}));
(function(Rectangle2) {
  function create2(x, y, width2, height2) {
    if (x == null || typeof x === "number") {
      return new Rectangle2(x, y, width2, height2);
    }
    return clone2(x);
  }
  Rectangle2.create = create2;
  function clone2(rect2) {
    if (Rectangle2.isRectangle(rect2)) {
      return rect2.clone();
    }
    if (Array.isArray(rect2)) {
      return new Rectangle2(rect2[0], rect2[1], rect2[2], rect2[3]);
    }
    return new Rectangle2(rect2.x, rect2.y, rect2.width, rect2.height);
  }
  Rectangle2.clone = clone2;
  function fromEllipse(ellipse3) {
    return new Rectangle2(ellipse3.x - ellipse3.a, ellipse3.y - ellipse3.b, 2 * ellipse3.a, 2 * ellipse3.b);
  }
  Rectangle2.fromEllipse = fromEllipse;
  function fromSize(size2) {
    return new Rectangle2(0, 0, size2.width, size2.height);
  }
  Rectangle2.fromSize = fromSize;
  function fromPositionAndSize(pos, size2) {
    return new Rectangle2(pos.x, pos.y, size2.width, size2.height);
  }
  Rectangle2.fromPositionAndSize = fromPositionAndSize;
})(Rectangle || (Rectangle = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/line.js
var Line = class _Line extends Geometry {
  get center() {
    return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
  }
  constructor(x1, y1, x2, y2) {
    super();
    if (typeof x1 === "number" && typeof y1 === "number") {
      this.start = new Point(x1, y1);
      this.end = new Point(x2, y2);
    } else {
      this.start = Point.create(x1);
      this.end = Point.create(y1);
    }
  }
  getCenter() {
    return this.center;
  }
  /**
   * Rounds the line to the given `precision`.
   */
  round(precision = 0) {
    this.start.round(precision);
    this.end.round(precision);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.start.translate(tx, ty);
      this.end.translate(tx, ty);
    } else {
      this.start.translate(tx);
      this.end.translate(tx);
    }
    return this;
  }
  /**
   * Rotate the line by `angle` around `origin`.
   */
  rotate(angle, origin) {
    this.start.rotate(angle, origin);
    this.end.rotate(angle, origin);
    return this;
  }
  /**
   * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
   * specified, the line is scaled around `0,0`.
   */
  scale(sx, sy, origin) {
    this.start.scale(sx, sy, origin);
    this.end.scale(sx, sy, origin);
    return this;
  }
  /**
   * Returns the length of the line.
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Useful for distance comparisons in which real length is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredLength() {
    const dx = this.start.x - this.end.x;
    const dy = this.start.y - this.end.y;
    return dx * dx + dy * dy;
  }
  /**
   * Scale the line so that it has the requested length. The start point of
   * the line is preserved.
   */
  setLength(length2) {
    const total = this.length();
    if (!total) {
      return this;
    }
    const scale2 = length2 / total;
    return this.scale(scale2, scale2, this.start);
  }
  parallel(distance) {
    const line2 = this.clone();
    if (!line2.isDifferentiable()) {
      return line2;
    }
    const { start, end } = line2;
    const eRef = start.clone().rotate(270, end);
    const sRef = end.clone().rotate(90, start);
    start.move(sRef, distance);
    end.move(eRef, distance);
    return line2;
  }
  /**
   * Returns the vector of the line with length equal to length of the line.
   */
  vector() {
    return new Point(this.end.x - this.start.x, this.end.y - this.start.y);
  }
  /**
   * Returns the angle of incline of the line.
   *
   * The function returns `NaN` if the start and end endpoints of the line
   * both lie at the same coordinates(it is impossible to determine the angle
   * of incline of a line that appears to be a point). The
   * `line.isDifferentiable()` function may be used in advance to determine
   * whether the angle of incline can be computed for a given line.
   */
  angle() {
    const ref2 = new Point(this.start.x + 1, this.start.y);
    return this.start.angleBetween(this.end, ref2);
  }
  /**
   * Returns a rectangle that is the bounding box of the line.
   */
  bbox() {
    const left4 = Math.min(this.start.x, this.end.x);
    const top4 = Math.min(this.start.y, this.end.y);
    const right4 = Math.max(this.start.x, this.end.x);
    const bottom4 = Math.max(this.start.y, this.end.y);
    return new Rectangle(left4, top4, right4 - left4, bottom4 - top4);
  }
  /**
   * Returns the bearing (cardinal direction) of the line.
   *
   * The return value is one of the following strings:
   * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
   *
   * The function returns 'N' if the two endpoints of the line are coincident.
   */
  bearing() {
    return this.start.bearing(this.end);
  }
  /**
   * Returns the point on the line that lies closest to point `p`.
   */
  closestPoint(p) {
    return this.pointAt(this.closestPointNormalizedLength(p));
  }
  /**
   * Returns the length of the line up to the point that lies closest to point `p`.
   */
  closestPointLength(p) {
    return this.closestPointNormalizedLength(p) * this.length();
  }
  /**
   * Returns a line that is tangent to the line at the point that lies closest
   * to point `p`.
   */
  closestPointTangent(p) {
    return this.tangentAt(this.closestPointNormalizedLength(p));
  }
  /**
   * Returns the normalized length (distance from the start of the line / total
   * line length) of the line up to the point that lies closest to point.
   */
  closestPointNormalizedLength(p) {
    const product = this.vector().dot(new _Line(this.start, p).vector());
    const normalized = Math.min(1, Math.max(0, product / this.squaredLength()));
    if (Number.isNaN(normalized)) {
      return 0;
    }
    return normalized;
  }
  /**
   * Returns a point on the line that lies `rate` (normalized length) away from
   * the beginning of the line.
   */
  pointAt(ratio2) {
    const start = this.start;
    const end = this.end;
    if (ratio2 <= 0) {
      return start.clone();
    }
    if (ratio2 >= 1) {
      return end.clone();
    }
    return start.lerp(end, ratio2);
  }
  /**
   * Returns a point on the line that lies length away from the beginning of
   * the line.
   */
  pointAtLength(length2) {
    const start = this.start;
    const end = this.end;
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const total = this.length();
    if (length2 >= total) {
      return fromStart ? end.clone() : start.clone();
    }
    const rate = (fromStart ? length2 : total - length2) / total;
    return this.pointAt(rate);
  }
  /**
   * Divides the line into two lines at the point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  divideAt(ratio2) {
    const dividerPoint = this.pointAt(ratio2);
    return [
      new _Line(this.start, dividerPoint),
      new _Line(dividerPoint, this.end)
    ];
  }
  /**
   * Divides the line into two lines at the point that lies length away from
   * the beginning of the line.
   */
  divideAtLength(length2) {
    const dividerPoint = this.pointAtLength(length2);
    return [
      new _Line(this.start, dividerPoint),
      new _Line(dividerPoint, this.end)
    ];
  }
  /**
   * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
   */
  containsPoint(p) {
    const start = this.start;
    const end = this.end;
    if (start.cross(p, end) !== 0) {
      return false;
    }
    const length2 = this.length();
    if (new _Line(start, p).length() > length2) {
      return false;
    }
    if (new _Line(p, end).length() > length2) {
      return false;
    }
    return true;
  }
  intersect(shape, options) {
    const ret = shape.intersectsWithLine(this, options);
    if (ret) {
      return Array.isArray(ret) ? ret : [ret];
    }
    return null;
  }
  /**
   * Returns the intersection point of the line with another line. Returns
   * `null` if no intersection exists.
   */
  intersectsWithLine(line2) {
    const pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);
    const pt2Dir = new Point(line2.end.x - line2.start.x, line2.end.y - line2.start.y);
    const det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
    const deltaPt = new Point(line2.start.x - this.start.x, line2.start.y - this.start.y);
    const alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
    const beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;
    if (det === 0 || alpha * det < 0 || beta * det < 0) {
      return null;
    }
    if (det > 0) {
      if (alpha > det || beta > det) {
        return null;
      }
    } else if (alpha < det || beta < det) {
      return null;
    }
    return new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det);
  }
  /**
   * Returns `true` if a tangent line can be found for the line.
   *
   * Tangents cannot be found if both of the line endpoints are coincident
   * (the line appears to be a point).
   */
  isDifferentiable() {
    return !this.start.equals(this.end);
  }
  /**
   * Returns the perpendicular distance between the line and point. The
   * distance is positive if the point lies to the right of the line, negative
   * if the point lies to the left of the line, and `0` if the point lies on
   * the line.
   */
  pointOffset(p) {
    const ref2 = Point.clone(p);
    const start = this.start;
    const end = this.end;
    const determinant = (end.x - start.x) * (ref2.y - start.y) - (end.y - start.y) * (ref2.x - start.x);
    return determinant / this.length();
  }
  pointSquaredDistance(x, y) {
    const p = Point.create(x, y);
    return this.closestPoint(p).squaredDistance(p);
  }
  pointDistance(x, y) {
    const p = Point.create(x, y);
    return this.closestPoint(p).distance(p);
  }
  /**
   * Returns a line tangent to the line at point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  tangentAt(ratio2) {
    if (!this.isDifferentiable()) {
      return null;
    }
    const start = this.start;
    const end = this.end;
    const tangentStart = this.pointAt(ratio2);
    const tangentLine = new _Line(start, end);
    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
    return tangentLine;
  }
  /**
   * Returns a line tangent to the line at point that lies `length` away from
   * the beginning of the line.
   */
  tangentAtLength(length2) {
    if (!this.isDifferentiable()) {
      return null;
    }
    const start = this.start;
    const end = this.end;
    const tangentStart = this.pointAtLength(length2);
    const tangentLine = new _Line(start, end);
    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
    return tangentLine;
  }
  relativeCcw(x, y) {
    const ref2 = Point.create(x, y);
    let dx1 = ref2.x - this.start.x;
    let dy1 = ref2.y - this.start.y;
    const dx2 = this.end.x - this.start.x;
    const dy2 = this.end.y - this.start.y;
    let ccw = dx1 * dy2 - dy1 * dx2;
    if (ccw === 0) {
      ccw = dx1 * dx2 + dy1 * dy2;
      if (ccw > 0) {
        dx1 -= dx2;
        dy1 -= dy2;
        ccw = dx1 * dx2 + dy1 * dy2;
        if (ccw < 0) {
          ccw = 0;
        }
      }
    }
    return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
  }
  /**
   * Return `true` if the line equals the other line.
   */
  equals(l) {
    return l != null && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;
  }
  /**
   * Returns another line which is a clone of the line.
   */
  clone() {
    return new _Line(this.start, this.end);
  }
  toJSON() {
    return { start: this.start.toJSON(), end: this.end.toJSON() };
  }
  serialize() {
    return [this.start.serialize(), this.end.serialize()].join(" ");
  }
};
(function(Line2) {
  function isLine(instance) {
    return instance != null && instance instanceof Line2;
  }
  Line2.isLine = isLine;
})(Line || (Line = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/ellipse.js
var Ellipse = class _Ellipse extends Geometry {
  get center() {
    return new Point(this.x, this.y);
  }
  constructor(x, y, a, b) {
    super();
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
    this.a = a == null ? 0 : a;
    this.b = b == null ? 0 : b;
  }
  /**
   * Returns a rectangle that is the bounding box of the ellipse.
   */
  bbox() {
    return Rectangle.fromEllipse(this);
  }
  /**
   * Returns a point that is the center of the ellipse.
   */
  getCenter() {
    return this.center;
  }
  inflate(dx, dy) {
    const w = dx;
    const h = dy != null ? dy : dx;
    this.a += 2 * w;
    this.b += 2 * h;
    return this;
  }
  normalizedDistance(x, y) {
    const ref2 = Point.create(x, y);
    const dx = ref2.x - this.x;
    const dy = ref2.y - this.y;
    const a = this.a;
    const b = this.b;
    return dx * dx / (a * a) + dy * dy / (b * b);
  }
  containsPoint(x, y) {
    return this.normalizedDistance(x, y) <= 1;
  }
  /**
   * Returns an array of the intersection points of the ellipse and the line.
   * Returns `null` if no intersection exists.
   */
  intersectsWithLine(line2) {
    const intersections = [];
    const rx = this.a;
    const ry = this.b;
    const a1 = line2.start;
    const a2 = line2.end;
    const dir = line2.vector();
    const diff = a1.diff(new Point(this.x, this.y));
    const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));
    const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));
    const a = dir.dot(mDir);
    const b = dir.dot(mDiff);
    const c = diff.dot(mDiff) - 1;
    const d = b * b - a * c;
    if (d < 0) {
      return null;
    }
    if (d > 0) {
      const root2 = Math.sqrt(d);
      const ta = (-b - root2) / a;
      const tb = (-b + root2) / a;
      if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {
        return null;
      }
      if (ta >= 0 && ta <= 1) {
        intersections.push(a1.lerp(a2, ta));
      }
      if (tb >= 0 && tb <= 1) {
        intersections.push(a1.lerp(a2, tb));
      }
    } else {
      const t = -b / a;
      if (t >= 0 && t <= 1) {
        intersections.push(a1.lerp(a2, t));
      } else {
        return null;
      }
    }
    return intersections;
  }
  /**
   * Returns the point on the boundary of the ellipse that is the
   * intersection of the ellipse with a line starting in the center
   * of the ellipse ending in the point `p`.
   *
   * If angle is specified, the intersection will take into account
   * the rotation of the ellipse by angle degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(p, angle = 0) {
    const ref2 = Point.clone(p);
    if (angle) {
      ref2.rotate(angle, this.getCenter());
    }
    const dx = ref2.x - this.x;
    const dy = ref2.y - this.y;
    let result2;
    if (dx === 0) {
      result2 = this.bbox().getNearestPointToPoint(ref2);
      if (angle) {
        return result2.rotate(-angle, this.getCenter());
      }
      return result2;
    }
    const m = dy / dx;
    const mSquared = m * m;
    const aSquared = this.a * this.a;
    const bSquared = this.b * this.b;
    let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));
    x = dx < 0 ? -x : x;
    const y = m * x;
    result2 = new Point(this.x + x, this.y + y);
    if (angle) {
      return result2.rotate(-angle, this.getCenter());
    }
    return result2;
  }
  /**
   * Returns the angle between the x-axis and the tangent from a point. It is
   * valid for points lying on the ellipse boundary only.
   */
  tangentTheta(p) {
    const ref2 = Point.clone(p);
    const x0 = ref2.x;
    const y0 = ref2.y;
    const a = this.a;
    const b = this.b;
    const center2 = this.bbox().center;
    const cx = center2.x;
    const cy = center2.y;
    const refPointDelta = 30;
    const q1 = x0 > center2.x + a / 2;
    const q3 = x0 < center2.x - a / 2;
    let x;
    let y;
    if (q1 || q3) {
      y = x0 > center2.x ? y0 - refPointDelta : y0 + refPointDelta;
      x = a * a / (x0 - cx) - a * a * (y0 - cy) * (y - cy) / (b * b * (x0 - cx)) + cx;
    } else {
      x = y0 > center2.y ? x0 + refPointDelta : x0 - refPointDelta;
      y = b * b / (y0 - cy) - b * b * (x0 - cx) * (x - cx) / (a * a * (y0 - cy)) + cy;
    }
    return new Point(x, y).theta(ref2);
  }
  scale(sx, sy) {
    this.a *= sx;
    this.b *= sy;
    return this;
  }
  rotate(angle, origin) {
    const rect2 = Rectangle.fromEllipse(this);
    rect2.rotate(angle, origin);
    const ellipse3 = _Ellipse.fromRect(rect2);
    this.a = ellipse3.a;
    this.b = ellipse3.b;
    this.x = ellipse3.x;
    this.y = ellipse3.y;
    return this;
  }
  translate(dx, dy) {
    const p = Point.create(dx, dy);
    this.x += p.x;
    this.y += p.y;
    return this;
  }
  equals(ellipse3) {
    return ellipse3 != null && ellipse3.x === this.x && ellipse3.y === this.y && ellipse3.a === this.a && ellipse3.b === this.b;
  }
  clone() {
    return new _Ellipse(this.x, this.y, this.a, this.b);
  }
  toJSON() {
    return { x: this.x, y: this.y, a: this.a, b: this.b };
  }
  serialize() {
    return `${this.x} ${this.y} ${this.a} ${this.b}`;
  }
};
(function(Ellipse3) {
  function isEllipse(instance) {
    return instance != null && instance instanceof Ellipse3;
  }
  Ellipse3.isEllipse = isEllipse;
})(Ellipse || (Ellipse = {}));
(function(Ellipse3) {
  function create2(x, y, a, b) {
    if (x == null || typeof x === "number") {
      return new Ellipse3(x, y, a, b);
    }
    return parse2(x);
  }
  Ellipse3.create = create2;
  function parse2(e) {
    if (Ellipse3.isEllipse(e)) {
      return e.clone();
    }
    if (Array.isArray(e)) {
      return new Ellipse3(e[0], e[1], e[2], e[3]);
    }
    return new Ellipse3(e.x, e.y, e.a, e.b);
  }
  Ellipse3.parse = parse2;
  function fromRect(rect2) {
    const center2 = rect2.center;
    return new Ellipse3(center2.x, center2.y, rect2.width / 2, rect2.height / 2);
  }
  Ellipse3.fromRect = fromRect;
})(Ellipse || (Ellipse = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/path/util.js
var regexSupportedData = new RegExp(`^[\\s\\dLMCZz,.]*$`);
function isValid(data2) {
  if (typeof data2 !== "string") {
    return false;
  }
  return regexSupportedData.test(data2);
}
function mod2(n, m) {
  return (n % m + m) % m;
}
function draw(points, round3, initialMove, close, exclude) {
  const data2 = [];
  const end = points[points.length - 1];
  const rounded2 = round3 != null && round3 > 0;
  const arcSize = round3 || 0;
  if (close && rounded2) {
    points = points.slice();
    const p0 = points[0];
    const wp = new Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);
    points.splice(0, 0, wp);
  }
  let pt = points[0];
  let i = 1;
  if (initialMove) {
    data2.push("M", pt.x, pt.y);
  } else {
    data2.push("L", pt.x, pt.y);
  }
  while (i < (close ? points.length : points.length - 1)) {
    let tmp = points[mod2(i, points.length)];
    let dx = pt.x - tmp.x;
    let dy = pt.y - tmp.y;
    if (rounded2 && (dx !== 0 || dy !== 0) && (exclude == null || exclude.indexOf(i - 1) < 0)) {
      let dist = Math.sqrt(dx * dx + dy * dy);
      const nx1 = dx * Math.min(arcSize, dist / 2) / dist;
      const ny1 = dy * Math.min(arcSize, dist / 2) / dist;
      const x1 = tmp.x + nx1;
      const y1 = tmp.y + ny1;
      data2.push("L", x1, y1);
      let next = points[mod2(i + 1, points.length)];
      while (i < points.length - 2 && Math.round(next.x - tmp.x) === 0 && Math.round(next.y - tmp.y) === 0) {
        next = points[mod2(i + 2, points.length)];
        i += 1;
      }
      dx = next.x - tmp.x;
      dy = next.y - tmp.y;
      dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
      const nx2 = dx * Math.min(arcSize, dist / 2) / dist;
      const ny2 = dy * Math.min(arcSize, dist / 2) / dist;
      const x2 = tmp.x + nx2;
      const y2 = tmp.y + ny2;
      data2.push("Q", tmp.x, tmp.y, x2, y2);
      tmp = new Point(x2, y2);
    } else {
      data2.push("L", tmp.x, tmp.y);
    }
    pt = tmp;
    i += 1;
  }
  if (close) {
    data2.push("Z");
  } else {
    data2.push("L", end.x, end.y);
  }
  return data2.map((v) => typeof v === "string" ? v : +v.toFixed(3)).join(" ");
}
function drawPoints(points, options = {}) {
  const pts = [];
  if (points && points.length) {
    points.forEach((p) => {
      if (Array.isArray(p)) {
        pts.push({ x: p[0], y: p[1] });
      } else {
        pts.push({ x: p.x, y: p.y });
      }
    });
  }
  return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);
}
function arcToCurves(x0, y0, r1, r2, angle = 0, largeArcFlag = 0, sweepFlag = 0, x, y) {
  if (r1 === 0 || r2 === 0) {
    return [];
  }
  x -= x0;
  y -= y0;
  r1 = Math.abs(r1);
  r2 = Math.abs(r2);
  const ctx = -x / 2;
  const cty = -y / 2;
  const cpsi = Math.cos(angle * Math.PI / 180);
  const spsi = Math.sin(angle * Math.PI / 180);
  const rxd = cpsi * ctx + spsi * cty;
  const ryd = -1 * spsi * ctx + cpsi * cty;
  const rxdd = rxd * rxd;
  const rydd = ryd * ryd;
  const r1x = r1 * r1;
  const r2y = r2 * r2;
  const lamda = rxdd / r1x + rydd / r2y;
  let sds;
  if (lamda > 1) {
    r1 = Math.sqrt(lamda) * r1;
    r2 = Math.sqrt(lamda) * r2;
    sds = 0;
  } else {
    let seif = 1;
    if (largeArcFlag === sweepFlag) {
      seif = -1;
    }
    sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
  }
  const txd = sds * r1 * ryd / r2;
  const tyd = -1 * sds * r2 * rxd / r1;
  const tx = cpsi * txd - spsi * tyd + x / 2;
  const ty = spsi * txd + cpsi * tyd + y / 2;
  let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
  let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
  rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
  let dr = rad >= 0 ? rad : 2 * Math.PI + rad;
  if (sweepFlag === 0 && dr > 0) {
    dr -= 2 * Math.PI;
  } else if (sweepFlag !== 0 && dr < 0) {
    dr += 2 * Math.PI;
  }
  const sse = dr * 2 / Math.PI;
  const seg = Math.ceil(sse < 0 ? -1 * sse : sse);
  const segr = dr / seg;
  const t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);
  const cpsir1 = cpsi * r1;
  const cpsir2 = cpsi * r2;
  const spsir1 = spsi * r1;
  const spsir2 = spsi * r2;
  let mc = Math.cos(s1);
  let ms = Math.sin(s1);
  let x2 = -t * (cpsir1 * ms + spsir2 * mc);
  let y2 = -t * (spsir1 * ms - cpsir2 * mc);
  let x3 = 0;
  let y3 = 0;
  const result2 = [];
  for (let n = 0; n < seg; n += 1) {
    s1 += segr;
    mc = Math.cos(s1);
    ms = Math.sin(s1);
    x3 = cpsir1 * mc - spsir2 * ms + tx;
    y3 = spsir1 * mc + cpsir2 * ms + ty;
    const dx = -t * (cpsir1 * ms + spsir2 * mc);
    const dy = -t * (spsir1 * ms - cpsir2 * mc);
    const index2 = n * 6;
    result2[index2] = Number(x2 + x0);
    result2[index2 + 1] = Number(y2 + y0);
    result2[index2 + 2] = Number(x3 - dx + x0);
    result2[index2 + 3] = Number(y3 - dy + y0);
    result2[index2 + 4] = Number(x3 + x0);
    result2[index2 + 5] = Number(y3 + y0);
    x2 = x3 + dx;
    y2 = y3 + dy;
  }
  return result2.map((num) => +num.toFixed(2));
}
function drawArc(startX, startY, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0, stopX, stopY) {
  const data2 = [];
  const points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);
  if (points != null) {
    for (let i = 0, ii = points.length; i < ii; i += 6) {
      data2.push("C", points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
    }
  }
  return data2.join(" ");
}

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/polyline.js
var Polyline = class _Polyline extends Geometry {
  get start() {
    return this.points[0] || null;
  }
  get end() {
    return this.points[this.points.length - 1] || null;
  }
  constructor(points) {
    super();
    if (points != null) {
      if (typeof points === "string") {
        return _Polyline.parse(points);
      }
      this.points = points.map((p) => Point.create(p));
    } else {
      this.points = [];
    }
  }
  scale(sx, sy, origin = new Point()) {
    this.points.forEach((p) => p.scale(sx, sy, origin));
    return this;
  }
  rotate(angle, origin) {
    this.points.forEach((p) => p.rotate(angle, origin));
    return this;
  }
  translate(dx, dy) {
    const t = Point.create(dx, dy);
    this.points.forEach((p) => p.translate(t.x, t.y));
    return this;
  }
  round(precision = 0) {
    this.points.forEach((p) => p.round(precision));
    return this;
  }
  bbox() {
    if (this.points.length === 0) {
      return new Rectangle();
    }
    let x1 = Infinity;
    let x2 = -Infinity;
    let y1 = Infinity;
    let y2 = -Infinity;
    const points = this.points;
    for (let i = 0, ii = points.length; i < ii; i += 1) {
      const point = points[i];
      const x = point.x;
      const y = point.y;
      if (x < x1)
        x1 = x;
      if (x > x2)
        x2 = x;
      if (y < y1)
        y1 = y;
      if (y > y2)
        y2 = y;
    }
    return new Rectangle(x1, y1, x2 - x1, y2 - y1);
  }
  closestPoint(p) {
    const cpLength = this.closestPointLength(p);
    return this.pointAtLength(cpLength);
  }
  closestPointLength(p) {
    const points = this.points;
    const count = points.length;
    if (count === 0 || count === 1) {
      return 0;
    }
    let length2 = 0;
    let cpLength = 0;
    let minSqrDistance = Infinity;
    for (let i = 0, ii = count - 1; i < ii; i += 1) {
      const line2 = new Line(points[i], points[i + 1]);
      const lineLength = line2.length();
      const cpNormalizedLength = line2.closestPointNormalizedLength(p);
      const cp = line2.pointAt(cpNormalizedLength);
      const sqrDistance = cp.squaredDistance(p);
      if (sqrDistance < minSqrDistance) {
        minSqrDistance = sqrDistance;
        cpLength = length2 + cpNormalizedLength * lineLength;
      }
      length2 += lineLength;
    }
    return cpLength;
  }
  closestPointNormalizedLength(p) {
    const length2 = this.length();
    if (length2 === 0) {
      return 0;
    }
    const cpLength = this.closestPointLength(p);
    return cpLength / length2;
  }
  closestPointTangent(p) {
    const cpLength = this.closestPointLength(p);
    return this.tangentAtLength(cpLength);
  }
  containsPoint(p) {
    if (this.points.length === 0) {
      return false;
    }
    const ref2 = Point.clone(p);
    const x = ref2.x;
    const y = ref2.y;
    const points = this.points;
    const count = points.length;
    let startIndex = count - 1;
    let intersectionCount = 0;
    for (let endIndex = 0; endIndex < count; endIndex += 1) {
      const start = points[startIndex];
      const end = points[endIndex];
      if (ref2.equals(start)) {
        return true;
      }
      const segment = new Line(start, end);
      if (segment.containsPoint(p)) {
        return true;
      }
      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {
        const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;
        if (xDifference >= 0) {
          const rayEnd = new Point(x + xDifference, y);
          const ray = new Line(p, rayEnd);
          if (segment.intersectsWithLine(ray)) {
            intersectionCount += 1;
          }
        }
      }
      startIndex = endIndex;
    }
    return intersectionCount % 2 === 1;
  }
  intersectsWithLine(line2) {
    const intersections = [];
    for (let i = 0, n = this.points.length - 1; i < n; i += 1) {
      const a = this.points[i];
      const b = this.points[i + 1];
      const int = line2.intersectsWithLine(new Line(a, b));
      if (int) {
        intersections.push(int);
      }
    }
    return intersections.length > 0 ? intersections : null;
  }
  isDifferentiable() {
    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
      const a = this.points[i];
      const b = this.points[i + 1];
      const line2 = new Line(a, b);
      if (line2.isDifferentiable()) {
        return true;
      }
    }
    return false;
  }
  length() {
    let len = 0;
    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
      const a = this.points[i];
      const b = this.points[i + 1];
      len += a.distance(b);
    }
    return len;
  }
  pointAt(ratio2) {
    const points = this.points;
    const count = points.length;
    if (count === 0) {
      return null;
    }
    if (count === 1) {
      return points[0].clone();
    }
    if (ratio2 <= 0) {
      return points[0].clone();
    }
    if (ratio2 >= 1) {
      return points[count - 1].clone();
    }
    const total = this.length();
    const length2 = total * ratio2;
    return this.pointAtLength(length2);
  }
  pointAtLength(length2) {
    const points = this.points;
    const count = points.length;
    if (count === 0) {
      return null;
    }
    if (count === 1) {
      return points[0].clone();
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    let tmp = 0;
    for (let i = 0, ii = count - 1; i < ii; i += 1) {
      const index2 = fromStart ? i : ii - 1 - i;
      const a = points[index2];
      const b = points[index2 + 1];
      const l = new Line(a, b);
      const d = a.distance(b);
      if (length2 <= tmp + d) {
        return l.pointAtLength((fromStart ? 1 : -1) * (length2 - tmp));
      }
      tmp += d;
    }
    const lastPoint = fromStart ? points[count - 1] : points[0];
    return lastPoint.clone();
  }
  tangentAt(ratio2) {
    const points = this.points;
    const count = points.length;
    if (count === 0 || count === 1) {
      return null;
    }
    if (ratio2 < 0) {
      ratio2 = 0;
    }
    if (ratio2 > 1) {
      ratio2 = 1;
    }
    const total = this.length();
    const length2 = total * ratio2;
    return this.tangentAtLength(length2);
  }
  tangentAtLength(length2) {
    const points = this.points;
    const count = points.length;
    if (count === 0 || count === 1) {
      return null;
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    let lastValidLine;
    let tmp = 0;
    for (let i = 0, ii = count - 1; i < ii; i += 1) {
      const index2 = fromStart ? i : ii - 1 - i;
      const a = points[index2];
      const b = points[index2 + 1];
      const l = new Line(a, b);
      const d = a.distance(b);
      if (l.isDifferentiable()) {
        if (length2 <= tmp + d) {
          return l.tangentAtLength((fromStart ? 1 : -1) * (length2 - tmp));
        }
        lastValidLine = l;
      }
      tmp += d;
    }
    if (lastValidLine) {
      const ratio2 = fromStart ? 1 : 0;
      return lastValidLine.tangentAt(ratio2);
    }
    return null;
  }
  simplify(options = {}) {
    const points = this.points;
    if (points.length < 3) {
      return this;
    }
    const threshold = options.threshold || 0;
    let currentIndex = 0;
    while (points[currentIndex + 2]) {
      const firstIndex = currentIndex;
      const middleIndex = currentIndex + 1;
      const lastIndex = currentIndex + 2;
      const firstPoint = points[firstIndex];
      const middlePoint = points[middleIndex];
      const lastPoint = points[lastIndex];
      const chord = new Line(firstPoint, lastPoint);
      const closestPoint = chord.closestPoint(middlePoint);
      const closestPointDistance = closestPoint.distance(middlePoint);
      if (closestPointDistance <= threshold) {
        points.splice(middleIndex, 1);
      } else {
        currentIndex += 1;
      }
    }
    return this;
  }
  toHull() {
    const points = this.points;
    const count = points.length;
    if (count === 0) {
      return new _Polyline();
    }
    let startPoint = points[0];
    for (let i = 1; i < count; i += 1) {
      if (points[i].y < startPoint.y) {
        startPoint = points[i];
      } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {
        startPoint = points[i];
      }
    }
    const sortedRecords = [];
    for (let i = 0; i < count; i += 1) {
      let angle = startPoint.theta(points[i]);
      if (angle === 0) {
        angle = 360;
      }
      sortedRecords.push([points[i], i, angle]);
    }
    sortedRecords.sort((record1, record2) => {
      let ret = record1[2] - record2[2];
      if (ret === 0) {
        ret = record2[1] - record1[1];
      }
      return ret;
    });
    if (sortedRecords.length > 2) {
      const startPoint2 = sortedRecords[sortedRecords.length - 1];
      sortedRecords.unshift(startPoint2);
    }
    const insidePoints = {};
    const hullRecords = [];
    const getKey2 = (record) => `${record[0].toString()}@${record[1]}`;
    while (sortedRecords.length !== 0) {
      const currentRecord = sortedRecords.pop();
      const currentPoint = currentRecord[0];
      if (insidePoints[getKey2(currentRecord)]) {
        continue;
      }
      let correctTurnFound = false;
      while (!correctTurnFound) {
        if (hullRecords.length < 2) {
          hullRecords.push(currentRecord);
          correctTurnFound = true;
        } else {
          const lastHullRecord = hullRecords.pop();
          const lastHullPoint = lastHullRecord[0];
          const secondLastHullRecord = hullRecords.pop();
          const secondLastHullPoint = secondLastHullRecord[0];
          const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);
          if (crossProduct < 0) {
            hullRecords.push(secondLastHullRecord);
            hullRecords.push(lastHullRecord);
            hullRecords.push(currentRecord);
            correctTurnFound = true;
          } else if (crossProduct === 0) {
            const THRESHOLD = 1e-10;
            const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);
            if (Math.abs(angleBetween - 180) < THRESHOLD) {
              insidePoints[getKey2(lastHullRecord)] = lastHullPoint;
              hullRecords.push(secondLastHullRecord);
            } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {
              insidePoints[getKey2(lastHullRecord)] = lastHullPoint;
              hullRecords.push(secondLastHullRecord);
            } else if (Math.abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {
              hullRecords.push(secondLastHullRecord);
              sortedRecords.push(lastHullRecord);
            }
          } else {
            insidePoints[getKey2(lastHullRecord)] = lastHullPoint;
            hullRecords.push(secondLastHullRecord);
          }
        }
      }
    }
    if (hullRecords.length > 2) {
      hullRecords.pop();
    }
    let lowestHullIndex;
    let indexOfLowestHullIndexRecord = -1;
    for (let i = 0, n = hullRecords.length; i < n; i += 1) {
      const currentHullIndex = hullRecords[i][1];
      if (lowestHullIndex === void 0 || currentHullIndex < lowestHullIndex) {
        lowestHullIndex = currentHullIndex;
        indexOfLowestHullIndexRecord = i;
      }
    }
    let hullPointRecordsReordered = [];
    if (indexOfLowestHullIndexRecord > 0) {
      const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);
      const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);
      hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
    } else {
      hullPointRecordsReordered = hullRecords;
    }
    const hullPoints = [];
    for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {
      hullPoints.push(hullPointRecordsReordered[i][0]);
    }
    return new _Polyline(hullPoints);
  }
  equals(p) {
    if (p == null) {
      return false;
    }
    if (p.points.length !== this.points.length) {
      return false;
    }
    return p.points.every((a, i) => a.equals(this.points[i]));
  }
  clone() {
    return new _Polyline(this.points.map((p) => p.clone()));
  }
  toJSON() {
    return this.points.map((p) => p.toJSON());
  }
  serialize() {
    return this.points.map((p) => `${p.serialize()}`).join(" ");
  }
};
(function(Polyline3) {
  function isPolyline(instance) {
    return instance != null && instance instanceof Polyline3;
  }
  Polyline3.isPolyline = isPolyline;
})(Polyline || (Polyline = {}));
(function(Polyline3) {
  function parse2(svgString) {
    const str = svgString.trim();
    if (str === "") {
      return new Polyline3();
    }
    const points = [];
    const coords = str.split(/\s*,\s*|\s+/);
    for (let i = 0, ii = coords.length; i < ii; i += 2) {
      points.push({ x: +coords[i], y: +coords[i + 1] });
    }
    return new Polyline3(points);
  }
  Polyline3.parse = parse2;
})(Polyline || (Polyline = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/curve.js
var Curve = class _Curve extends Geometry {
  constructor(start, controlPoint1, controlPoint2, end) {
    super();
    this.PRECISION = 3;
    this.start = Point.create(start);
    this.controlPoint1 = Point.create(controlPoint1);
    this.controlPoint2 = Point.create(controlPoint2);
    this.end = Point.create(end);
  }
  bbox() {
    const start = this.start;
    const controlPoint1 = this.controlPoint1;
    const controlPoint2 = this.controlPoint2;
    const end = this.end;
    const x0 = start.x;
    const y0 = start.y;
    const x1 = controlPoint1.x;
    const y1 = controlPoint1.y;
    const x2 = controlPoint2.x;
    const y2 = controlPoint2.y;
    const x3 = end.x;
    const y3 = end.y;
    const points = [];
    const tvalues = [];
    const bounds = [[], []];
    let a;
    let b;
    let c;
    let t;
    let t1;
    let t2;
    let b2ac;
    let sqrtb2ac;
    for (let i = 0; i < 2; i += 1) {
      if (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }
      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (t > 0 && t < 1)
          tvalues.push(t);
        continue;
      }
      b2ac = b * b - 4 * c * a;
      sqrtb2ac = Math.sqrt(b2ac);
      if (b2ac < 0)
        continue;
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (t1 > 0 && t1 < 1)
        tvalues.push(t1);
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (t2 > 0 && t2 < 1)
        tvalues.push(t2);
    }
    let x;
    let y;
    let mt;
    let j = tvalues.length;
    const jlen = j;
    while (j) {
      j -= 1;
      t = tvalues[j];
      mt = 1 - t;
      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[0][j] = x;
      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
      bounds[1][j] = y;
      points[j] = { X: x, Y: y };
    }
    tvalues[jlen] = 0;
    tvalues[jlen + 1] = 1;
    points[jlen] = { X: x0, Y: y0 };
    points[jlen + 1] = { X: x3, Y: y3 };
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    tvalues.length = jlen + 2;
    bounds[0].length = jlen + 2;
    bounds[1].length = jlen + 2;
    points.length = jlen + 2;
    const left4 = Math.min.apply(null, bounds[0]);
    const top4 = Math.min.apply(null, bounds[1]);
    const right4 = Math.max.apply(null, bounds[0]);
    const bottom4 = Math.max.apply(null, bounds[1]);
    return new Rectangle(left4, top4, right4 - left4, bottom4 - top4);
  }
  closestPoint(p, options = {}) {
    return this.pointAtT(this.closestPointT(p, options));
  }
  closestPointLength(p, options = {}) {
    const opts = this.getOptions(options);
    return this.lengthAtT(this.closestPointT(p, opts), opts);
  }
  closestPointNormalizedLength(p, options = {}) {
    const opts = this.getOptions(options);
    const cpLength = this.closestPointLength(p, opts);
    if (!cpLength) {
      return 0;
    }
    const length2 = this.length(opts);
    if (length2 === 0) {
      return 0;
    }
    return cpLength / length2;
  }
  closestPointT(p, options = {}) {
    const precision = this.getPrecision(options);
    const subdivisions = this.getDivisions(options);
    const precisionRatio = Math.pow(10, -precision);
    let investigatedSubdivision = null;
    let investigatedSubdivisionStartT = 0;
    let investigatedSubdivisionEndT = 0;
    let distFromStart = 0;
    let distFromEnd = 0;
    let chordLength = 0;
    let minSumDist = null;
    const count = subdivisions.length;
    let piece = count > 0 ? 1 / count : 0;
    subdivisions.forEach((division, i) => {
      const startDist = division.start.distance(p);
      const endDist = division.end.distance(p);
      const sumDist = startDist + endDist;
      if (minSumDist == null || sumDist < minSumDist) {
        investigatedSubdivision = division;
        investigatedSubdivisionStartT = i * piece;
        investigatedSubdivisionEndT = (i + 1) * piece;
        distFromStart = startDist;
        distFromEnd = endDist;
        minSumDist = sumDist;
        chordLength = division.endpointDistance();
      }
    });
    while (true) {
      const startPrecisionRatio = distFromStart ? Math.abs(distFromStart - distFromEnd) / distFromStart : 0;
      const endPrecisionRatio = distFromEnd != null ? Math.abs(distFromStart - distFromEnd) / distFromEnd : 0;
      const hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;
      const hasMiniStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;
      const hasMiniEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;
      const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;
      if (hasRequiredPrecision || hasMiniDistance) {
        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;
      }
      const divided = investigatedSubdivision.divide(0.5);
      piece /= 2;
      const startDist1 = divided[0].start.distance(p);
      const endDist1 = divided[0].end.distance(p);
      const sumDist1 = startDist1 + endDist1;
      const startDist2 = divided[1].start.distance(p);
      const endDist2 = divided[1].end.distance(p);
      const sumDist2 = startDist2 + endDist2;
      if (sumDist1 <= sumDist2) {
        investigatedSubdivision = divided[0];
        investigatedSubdivisionEndT -= piece;
        distFromStart = startDist1;
        distFromEnd = endDist1;
      } else {
        investigatedSubdivision = divided[1];
        investigatedSubdivisionStartT += piece;
        distFromStart = startDist2;
        distFromEnd = endDist2;
      }
    }
  }
  closestPointTangent(p, options = {}) {
    return this.tangentAtT(this.closestPointT(p, options));
  }
  containsPoint(p, options = {}) {
    const polyline = this.toPolyline(options);
    return polyline.containsPoint(p);
  }
  divideAt(ratio2, options = {}) {
    if (ratio2 <= 0) {
      return this.divideAtT(0);
    }
    if (ratio2 >= 1) {
      return this.divideAtT(1);
    }
    const t = this.tAt(ratio2, options);
    return this.divideAtT(t);
  }
  divideAtLength(length2, options = {}) {
    const t = this.tAtLength(length2, options);
    return this.divideAtT(t);
  }
  divide(t) {
    return this.divideAtT(t);
  }
  divideAtT(t) {
    const start = this.start;
    const controlPoint1 = this.controlPoint1;
    const controlPoint2 = this.controlPoint2;
    const end = this.end;
    if (t <= 0) {
      return [
        new _Curve(start, start, start, start),
        new _Curve(start, controlPoint1, controlPoint2, end)
      ];
    }
    if (t >= 1) {
      return [
        new _Curve(start, controlPoint1, controlPoint2, end),
        new _Curve(end, end, end, end)
      ];
    }
    const dividerPoints = this.getSkeletonPoints(t);
    const startControl1 = dividerPoints.startControlPoint1;
    const startControl2 = dividerPoints.startControlPoint2;
    const divider = dividerPoints.divider;
    const dividerControl1 = dividerPoints.dividerControlPoint1;
    const dividerControl2 = dividerPoints.dividerControlPoint2;
    return [
      new _Curve(start, startControl1, startControl2, divider),
      new _Curve(divider, dividerControl1, dividerControl2, end)
    ];
  }
  endpointDistance() {
    return this.start.distance(this.end);
  }
  getSkeletonPoints(t) {
    const start = this.start;
    const control1 = this.controlPoint1;
    const control2 = this.controlPoint2;
    const end = this.end;
    if (t <= 0) {
      return {
        startControlPoint1: start.clone(),
        startControlPoint2: start.clone(),
        divider: start.clone(),
        dividerControlPoint1: control1.clone(),
        dividerControlPoint2: control2.clone()
      };
    }
    if (t >= 1) {
      return {
        startControlPoint1: control1.clone(),
        startControlPoint2: control2.clone(),
        divider: end.clone(),
        dividerControlPoint1: end.clone(),
        dividerControlPoint2: end.clone()
      };
    }
    const midpoint1 = new Line(start, control1).pointAt(t);
    const midpoint2 = new Line(control1, control2).pointAt(t);
    const midpoint3 = new Line(control2, end).pointAt(t);
    const subControl1 = new Line(midpoint1, midpoint2).pointAt(t);
    const subControl2 = new Line(midpoint2, midpoint3).pointAt(t);
    const divideLine = new Line(subControl1, subControl2).pointAt(t);
    return {
      startControlPoint1: midpoint1,
      startControlPoint2: subControl1,
      divider: divideLine,
      dividerControlPoint1: subControl2,
      dividerControlPoint2: midpoint3
    };
  }
  getSubdivisions(options = {}) {
    const precision = this.getPrecision(options);
    let subdivisions = [
      new _Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)
    ];
    if (precision === 0) {
      return subdivisions;
    }
    let previousLength = this.endpointDistance();
    const precisionRatio = Math.pow(10, -precision);
    let iteration = 0;
    while (true) {
      iteration += 1;
      const divisions = [];
      subdivisions.forEach((c) => {
        const divided = c.divide(0.5);
        divisions.push(divided[0], divided[1]);
      });
      const length2 = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0);
      const ratio2 = length2 !== 0 ? (length2 - previousLength) / length2 : 0;
      if (iteration > 1 && ratio2 < precisionRatio) {
        return divisions;
      }
      subdivisions = divisions;
      previousLength = length2;
    }
  }
  length(options = {}) {
    const divisions = this.getDivisions(options);
    return divisions.reduce((memo, c) => {
      return memo + c.endpointDistance();
    }, 0);
  }
  lengthAtT(t, options = {}) {
    if (t <= 0) {
      return 0;
    }
    const precision = options.precision === void 0 ? this.PRECISION : options.precision;
    const subCurve = this.divide(t)[0];
    return subCurve.length({ precision });
  }
  pointAt(ratio2, options = {}) {
    if (ratio2 <= 0) {
      return this.start.clone();
    }
    if (ratio2 >= 1) {
      return this.end.clone();
    }
    const t = this.tAt(ratio2, options);
    return this.pointAtT(t);
  }
  pointAtLength(length2, options = {}) {
    const t = this.tAtLength(length2, options);
    return this.pointAtT(t);
  }
  pointAtT(t) {
    if (t <= 0) {
      return this.start.clone();
    }
    if (t >= 1) {
      return this.end.clone();
    }
    return this.getSkeletonPoints(t).divider;
  }
  isDifferentiable() {
    const start = this.start;
    const control1 = this.controlPoint1;
    const control2 = this.controlPoint2;
    const end = this.end;
    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
  }
  tangentAt(ratio2, options = {}) {
    if (!this.isDifferentiable())
      return null;
    if (ratio2 < 0) {
      ratio2 = 0;
    } else if (ratio2 > 1) {
      ratio2 = 1;
    }
    const t = this.tAt(ratio2, options);
    return this.tangentAtT(t);
  }
  tangentAtLength(length2, options = {}) {
    if (!this.isDifferentiable()) {
      return null;
    }
    const t = this.tAtLength(length2, options);
    return this.tangentAtT(t);
  }
  tangentAtT(t) {
    if (!this.isDifferentiable()) {
      return null;
    }
    if (t < 0) {
      t = 0;
    }
    if (t > 1) {
      t = 1;
    }
    const skeletonPoints = this.getSkeletonPoints(t);
    const p1 = skeletonPoints.startControlPoint2;
    const p2 = skeletonPoints.dividerControlPoint1;
    const tangentStart = skeletonPoints.divider;
    const tangentLine = new Line(p1, p2);
    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);
    return tangentLine;
  }
  getPrecision(options = {}) {
    return options.precision == null ? this.PRECISION : options.precision;
  }
  getDivisions(options = {}) {
    if (options.subdivisions != null) {
      return options.subdivisions;
    }
    const precision = this.getPrecision(options);
    return this.getSubdivisions({ precision });
  }
  getOptions(options = {}) {
    const precision = this.getPrecision(options);
    const subdivisions = this.getDivisions(options);
    return { precision, subdivisions };
  }
  tAt(ratio2, options = {}) {
    if (ratio2 <= 0) {
      return 0;
    }
    if (ratio2 >= 1) {
      return 1;
    }
    const opts = this.getOptions(options);
    const total = this.length(opts);
    const length2 = total * ratio2;
    return this.tAtLength(length2, opts);
  }
  tAtLength(length2, options = {}) {
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const precision = this.getPrecision(options);
    const subdivisions = this.getDivisions(options);
    const opts = { precision, subdivisions };
    let investigatedSubdivision = null;
    let investigatedSubdivisionStartT;
    let investigatedSubdivisionEndT;
    let baselinePointDistFromStart = 0;
    let baselinePointDistFromEnd = 0;
    let memo = 0;
    const count = subdivisions.length;
    let piece = count > 0 ? 1 / count : 0;
    for (let i = 0; i < count; i += 1) {
      const index2 = fromStart ? i : count - 1 - i;
      const division = subdivisions[i];
      const dist = division.endpointDistance();
      if (length2 <= memo + dist) {
        investigatedSubdivision = division;
        investigatedSubdivisionStartT = index2 * piece;
        investigatedSubdivisionEndT = (index2 + 1) * piece;
        baselinePointDistFromStart = fromStart ? length2 - memo : dist + memo - length2;
        baselinePointDistFromEnd = fromStart ? dist + memo - length2 : length2 - memo;
        break;
      }
      memo += dist;
    }
    if (investigatedSubdivision == null) {
      return fromStart ? 1 : 0;
    }
    const total = this.length(opts);
    const precisionRatio = Math.pow(10, -precision);
    while (true) {
      let ratio2;
      ratio2 = total !== 0 ? baselinePointDistFromStart / total : 0;
      if (ratio2 < precisionRatio) {
        return investigatedSubdivisionStartT;
      }
      ratio2 = total !== 0 ? baselinePointDistFromEnd / total : 0;
      if (ratio2 < precisionRatio) {
        return investigatedSubdivisionEndT;
      }
      let newBaselinePointDistFromStart;
      let newBaselinePointDistFromEnd;
      const divided = investigatedSubdivision.divide(0.5);
      piece /= 2;
      const baseline1Length = divided[0].endpointDistance();
      const baseline2Length = divided[1].endpointDistance();
      if (baselinePointDistFromStart <= baseline1Length) {
        investigatedSubdivision = divided[0];
        investigatedSubdivisionEndT -= piece;
        newBaselinePointDistFromStart = baselinePointDistFromStart;
        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;
      } else {
        investigatedSubdivision = divided[1];
        investigatedSubdivisionStartT += piece;
        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;
        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;
      }
      baselinePointDistFromStart = newBaselinePointDistFromStart;
      baselinePointDistFromEnd = newBaselinePointDistFromEnd;
    }
  }
  toPoints(options = {}) {
    const subdivisions = this.getDivisions(options);
    const points = [subdivisions[0].start.clone()];
    subdivisions.forEach((c) => points.push(c.end.clone()));
    return points;
  }
  toPolyline(options = {}) {
    return new Polyline(this.toPoints(options));
  }
  scale(sx, sy, origin) {
    this.start.scale(sx, sy, origin);
    this.controlPoint1.scale(sx, sy, origin);
    this.controlPoint2.scale(sx, sy, origin);
    this.end.scale(sx, sy, origin);
    return this;
  }
  rotate(angle, origin) {
    this.start.rotate(angle, origin);
    this.controlPoint1.rotate(angle, origin);
    this.controlPoint2.rotate(angle, origin);
    this.end.rotate(angle, origin);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.start.translate(tx, ty);
      this.controlPoint1.translate(tx, ty);
      this.controlPoint2.translate(tx, ty);
      this.end.translate(tx, ty);
    } else {
      this.start.translate(tx);
      this.controlPoint1.translate(tx);
      this.controlPoint2.translate(tx);
      this.end.translate(tx);
    }
    return this;
  }
  equals(c) {
    return c != null && this.start.equals(c.start) && this.controlPoint1.equals(c.controlPoint1) && this.controlPoint2.equals(c.controlPoint2) && this.end.equals(c.end);
  }
  clone() {
    return new _Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return [
      this.start.serialize(),
      this.controlPoint1.serialize(),
      this.controlPoint2.serialize(),
      this.end.serialize()
    ].join(" ");
  }
};
(function(Curve2) {
  function isCurve(instance) {
    return instance != null && instance instanceof Curve2;
  }
  Curve2.isCurve = isCurve;
})(Curve || (Curve = {}));
(function(Curve2) {
  function getFirstControlPoints(rhs) {
    const n = rhs.length;
    const x = [];
    const tmp = [];
    let b = 2;
    x[0] = rhs[0] / b;
    for (let i = 1; i < n; i += 1) {
      tmp[i] = 1 / b;
      b = (i < n - 1 ? 4 : 3.5) - tmp[i];
      x[i] = (rhs[i] - x[i - 1]) / b;
    }
    for (let i = 1; i < n; i += 1) {
      x[n - i - 1] -= tmp[n - i] * x[n - i];
    }
    return x;
  }
  function getCurveControlPoints(points) {
    const knots = points.map((p) => Point.clone(p));
    const firstControlPoints = [];
    const secondControlPoints = [];
    const n = knots.length - 1;
    if (n === 1) {
      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
      return [firstControlPoints, secondControlPoints];
    }
    const rhs = [];
    for (let i = 1; i < n - 1; i += 1) {
      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
    }
    rhs[0] = knots[0].x + 2 * knots[1].x;
    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2;
    const x = getFirstControlPoints(rhs);
    for (let i = 1; i < n - 1; i += 1) {
      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
    }
    rhs[0] = knots[0].y + 2 * knots[1].y;
    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2;
    const y = getFirstControlPoints(rhs);
    for (let i = 0; i < n; i += 1) {
      firstControlPoints.push(new Point(x[i], y[i]));
      if (i < n - 1) {
        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
      } else {
        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
      }
    }
    return [firstControlPoints, secondControlPoints];
  }
  function throughPoints(points) {
    if (points == null || Array.isArray(points) && points.length < 2) {
      throw new Error("At least 2 points are required");
    }
    const controlPoints = getCurveControlPoints(points);
    const curves = [];
    for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {
      const controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);
      const controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);
      curves.push(new Curve2(points[i], controlPoint1, controlPoint2, points[i + 1]));
    }
    return curves;
  }
  Curve2.throughPoints = throughPoints;
})(Curve || (Curve = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/path/segment.js
var Segment = class extends Geometry {
  constructor() {
    super(...arguments);
    this.isVisible = true;
    this.isSegment = true;
    this.isSubpathStart = false;
  }
  get end() {
    return this.endPoint;
  }
  get start() {
    if (this.previousSegment == null) {
      throw new Error("Missing previous segment. (This segment cannot be the first segment of a path, or segment has not yet been added to a path.)");
    }
    return this.previousSegment.end;
  }
  closestPointT(p, options) {
    if (this.closestPointNormalizedLength) {
      return this.closestPointNormalizedLength(p);
    }
    throw new Error("Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.");
  }
  // eslint-disable-next-line
  lengthAtT(t, options) {
    if (t <= 0) {
      return 0;
    }
    const length2 = this.length();
    if (t >= 1) {
      return length2;
    }
    return length2 * t;
  }
  divideAtT(t) {
    if (this.divideAt) {
      return this.divideAt(t);
    }
    throw new Error("Neither `divideAtT` nor `divideAt` method is implemented.");
  }
  pointAtT(t) {
    if (this.pointAt) {
      return this.pointAt(t);
    }
    throw new Error("Neither `pointAtT` nor `pointAt` method is implemented.");
  }
  tangentAtT(t) {
    if (this.tangentAt) {
      return this.tangentAt(t);
    }
    throw new Error("Neither `tangentAtT` nor `tangentAt` method is implemented.");
  }
};

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/path/lineto.js
var LineTo = class _LineTo extends Segment {
  constructor(x, y) {
    super();
    if (Line.isLine(x)) {
      this.endPoint = x.end.clone().round(2);
    } else {
      this.endPoint = Point.create(x, y).round(2);
    }
  }
  get type() {
    return "L";
  }
  get line() {
    return new Line(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(p) {
    return this.line.closestPoint(p);
  }
  closestPointLength(p) {
    return this.line.closestPointLength(p);
  }
  closestPointNormalizedLength(p) {
    return this.line.closestPointNormalizedLength(p);
  }
  closestPointTangent(p) {
    return this.line.closestPointTangent(p);
  }
  length() {
    return this.line.length();
  }
  divideAt(ratio2) {
    const divided = this.line.divideAt(ratio2);
    return [new _LineTo(divided[0]), new _LineTo(divided[1])];
  }
  divideAtLength(length2) {
    const divided = this.line.divideAtLength(length2);
    return [new _LineTo(divided[0]), new _LineTo(divided[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(ratio2) {
    return this.line.pointAt(ratio2);
  }
  pointAtLength(length2) {
    return this.line.pointAtLength(length2);
  }
  tangentAt(ratio2) {
    return this.line.tangentAt(ratio2);
  }
  tangentAtLength(length2) {
    return this.line.tangentAtLength(length2);
  }
  isDifferentiable() {
    if (this.previousSegment == null) {
      return false;
    }
    return !this.start.equals(this.end);
  }
  clone() {
    return new _LineTo(this.end);
  }
  scale(sx, sy, origin) {
    this.end.scale(sx, sy, origin);
    return this;
  }
  rotate(angle, origin) {
    this.end.rotate(angle, origin);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.end.translate(tx, ty);
    } else {
      this.end.translate(tx);
    }
    return this;
  }
  equals(s) {
    return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const end = this.end;
    return `${this.type} ${end.x} ${end.y}`;
  }
};
(function(LineTo2) {
  function create2(...args) {
    const len = args.length;
    const arg0 = args[0];
    if (Line.isLine(arg0)) {
      return new LineTo2(arg0);
    }
    if (Point.isPointLike(arg0)) {
      if (len === 1) {
        return new LineTo2(arg0);
      }
      return args.map((arg) => new LineTo2(arg));
    }
    if (len === 2) {
      return new LineTo2(+args[0], +args[1]);
    }
    const segments = [];
    for (let i = 0; i < len; i += 2) {
      const x = +args[i];
      const y = +args[i + 1];
      segments.push(new LineTo2(x, y));
    }
    return segments;
  }
  LineTo2.create = create2;
})(LineTo || (LineTo = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/path/close.js
var Close = class _Close extends Segment {
  get end() {
    if (!this.subpathStartSegment) {
      throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. MoveTo), or segment has not yet been added to a path.)");
    }
    return this.subpathStartSegment.end;
  }
  get type() {
    return "Z";
  }
  get line() {
    return new Line(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(p) {
    return this.line.closestPoint(p);
  }
  closestPointLength(p) {
    return this.line.closestPointLength(p);
  }
  closestPointNormalizedLength(p) {
    return this.line.closestPointNormalizedLength(p);
  }
  closestPointTangent(p) {
    return this.line.closestPointTangent(p);
  }
  length() {
    return this.line.length();
  }
  divideAt(ratio2) {
    const divided = this.line.divideAt(ratio2);
    return [
      // do not actually cut into the segment, first divided part can stay as Z
      divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(),
      new LineTo(divided[1])
    ];
  }
  divideAtLength(length2) {
    const divided = this.line.divideAtLength(length2);
    return [
      divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(),
      new LineTo(divided[1])
    ];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(ratio2) {
    return this.line.pointAt(ratio2);
  }
  pointAtLength(length2) {
    return this.line.pointAtLength(length2);
  }
  tangentAt(ratio2) {
    return this.line.tangentAt(ratio2);
  }
  tangentAtLength(length2) {
    return this.line.tangentAtLength(length2);
  }
  isDifferentiable() {
    if (!this.previousSegment || !this.subpathStartSegment) {
      return false;
    }
    return !this.start.equals(this.end);
  }
  scale() {
    return this;
  }
  rotate() {
    return this;
  }
  translate() {
    return this;
  }
  equals(s) {
    return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);
  }
  clone() {
    return new _Close();
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return this.type;
  }
};
(function(Close2) {
  function create2() {
    return new Close2();
  }
  Close2.create = create2;
})(Close || (Close = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/path/moveto.js
var MoveTo = class _MoveTo extends Segment {
  constructor(x, y) {
    super();
    this.isVisible = false;
    this.isSubpathStart = true;
    if (Line.isLine(x) || Curve.isCurve(x)) {
      this.endPoint = x.end.clone().round(2);
    } else {
      this.endPoint = Point.create(x, y).round(2);
    }
  }
  get start() {
    throw new Error("Illegal access. Moveto segments should not need a start property.");
  }
  get type() {
    return "M";
  }
  bbox() {
    return null;
  }
  closestPoint() {
    return this.end.clone();
  }
  closestPointLength() {
    return 0;
  }
  closestPointNormalizedLength() {
    return 0;
  }
  closestPointT() {
    return 1;
  }
  closestPointTangent() {
    return null;
  }
  length() {
    return 0;
  }
  lengthAtT() {
    return 0;
  }
  divideAt() {
    return [this.clone(), this.clone()];
  }
  divideAtLength() {
    return [this.clone(), this.clone()];
  }
  getSubdivisions() {
    return [];
  }
  pointAt() {
    return this.end.clone();
  }
  pointAtLength() {
    return this.end.clone();
  }
  pointAtT() {
    return this.end.clone();
  }
  tangentAt() {
    return null;
  }
  tangentAtLength() {
    return null;
  }
  tangentAtT() {
    return null;
  }
  isDifferentiable() {
    return false;
  }
  scale(sx, sy, origin) {
    this.end.scale(sx, sy, origin);
    return this;
  }
  rotate(angle, origin) {
    this.end.rotate(angle, origin);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.end.translate(tx, ty);
    } else {
      this.end.translate(tx);
    }
    return this;
  }
  clone() {
    return new _MoveTo(this.end);
  }
  equals(s) {
    return this.type === s.type && this.end.equals(s.end);
  }
  toJSON() {
    return {
      type: this.type,
      end: this.end.toJSON()
    };
  }
  serialize() {
    const end = this.end;
    return `${this.type} ${end.x} ${end.y}`;
  }
};
(function(MoveTo2) {
  function create2(...args) {
    const len = args.length;
    const arg0 = args[0];
    if (Line.isLine(arg0)) {
      return new MoveTo2(arg0);
    }
    if (Curve.isCurve(arg0)) {
      return new MoveTo2(arg0);
    }
    if (Point.isPointLike(arg0)) {
      if (len === 1) {
        return new MoveTo2(arg0);
      }
      const segments2 = [];
      for (let i = 0; i < len; i += 1) {
        if (i === 0) {
          segments2.push(new MoveTo2(args[i]));
        } else {
          segments2.push(new LineTo(args[i]));
        }
      }
      return segments2;
    }
    if (len === 2) {
      return new MoveTo2(+args[0], +args[1]);
    }
    const segments = [];
    for (let i = 0; i < len; i += 2) {
      const x = +args[i];
      const y = +args[i + 1];
      if (i === 0) {
        segments.push(new MoveTo2(x, y));
      } else {
        segments.push(new LineTo(x, y));
      }
    }
    return segments;
  }
  MoveTo2.create = create2;
})(MoveTo || (MoveTo = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/path/curveto.js
var CurveTo = class _CurveTo extends Segment {
  constructor(arg0, arg1, arg2, arg3, arg4, arg5) {
    super();
    if (Curve.isCurve(arg0)) {
      this.controlPoint1 = arg0.controlPoint1.clone().round(2);
      this.controlPoint2 = arg0.controlPoint2.clone().round(2);
      this.endPoint = arg0.end.clone().round(2);
    } else if (typeof arg0 === "number") {
      this.controlPoint1 = new Point(arg0, arg1).round(2);
      this.controlPoint2 = new Point(arg2, arg3).round(2);
      this.endPoint = new Point(arg4, arg5).round(2);
    } else {
      this.controlPoint1 = Point.create(arg0).round(2);
      this.controlPoint2 = Point.create(arg1).round(2);
      this.endPoint = Point.create(arg2).round(2);
    }
  }
  get type() {
    return "C";
  }
  get curve() {
    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  bbox() {
    return this.curve.bbox();
  }
  closestPoint(p) {
    return this.curve.closestPoint(p);
  }
  closestPointLength(p) {
    return this.curve.closestPointLength(p);
  }
  closestPointNormalizedLength(p) {
    return this.curve.closestPointNormalizedLength(p);
  }
  closestPointTangent(p) {
    return this.curve.closestPointTangent(p);
  }
  length() {
    return this.curve.length();
  }
  divideAt(ratio2, options = {}) {
    const divided = this.curve.divideAt(ratio2, options);
    return [new _CurveTo(divided[0]), new _CurveTo(divided[1])];
  }
  divideAtLength(length2, options = {}) {
    const divided = this.curve.divideAtLength(length2, options);
    return [new _CurveTo(divided[0]), new _CurveTo(divided[1])];
  }
  divideAtT(t) {
    const divided = this.curve.divideAtT(t);
    return [new _CurveTo(divided[0]), new _CurveTo(divided[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(ratio2) {
    return this.curve.pointAt(ratio2);
  }
  pointAtLength(length2) {
    return this.curve.pointAtLength(length2);
  }
  tangentAt(ratio2) {
    return this.curve.tangentAt(ratio2);
  }
  tangentAtLength(length2) {
    return this.curve.tangentAtLength(length2);
  }
  isDifferentiable() {
    if (!this.previousSegment) {
      return false;
    }
    const start = this.start;
    const control1 = this.controlPoint1;
    const control2 = this.controlPoint2;
    const end = this.end;
    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
  }
  scale(sx, sy, origin) {
    this.controlPoint1.scale(sx, sy, origin);
    this.controlPoint2.scale(sx, sy, origin);
    this.end.scale(sx, sy, origin);
    return this;
  }
  rotate(angle, origin) {
    this.controlPoint1.rotate(angle, origin);
    this.controlPoint2.rotate(angle, origin);
    this.end.rotate(angle, origin);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.controlPoint1.translate(tx, ty);
      this.controlPoint2.translate(tx, ty);
      this.end.translate(tx, ty);
    } else {
      this.controlPoint1.translate(tx);
      this.controlPoint2.translate(tx);
      this.end.translate(tx);
    }
    return this;
  }
  equals(s) {
    return this.start.equals(s.start) && this.end.equals(s.end) && this.controlPoint1.equals(s.controlPoint1) && this.controlPoint2.equals(s.controlPoint2);
  }
  clone() {
    return new _CurveTo(this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const c1 = this.controlPoint1;
    const c2 = this.controlPoint2;
    const end = this.end;
    return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(" ");
  }
};
(function(CurveTo2) {
  function create2(...args) {
    const len = args.length;
    const arg0 = args[0];
    if (Curve.isCurve(arg0)) {
      return new CurveTo2(arg0);
    }
    if (Point.isPointLike(arg0)) {
      if (len === 3) {
        return new CurveTo2(args[0], args[1], args[2]);
      }
      const segments2 = [];
      for (let i = 0; i < len; i += 3) {
        segments2.push(new CurveTo2(args[i], args[i + 1], args[i + 2]));
      }
      return segments2;
    }
    if (len === 6) {
      return new CurveTo2(args[0], args[1], args[2], args[3], args[4], args[5]);
    }
    const segments = [];
    for (let i = 0; i < len; i += 6) {
      segments.push(new CurveTo2(args[i], args[i + 1], args[i + 2], args[i + 3], args[i + 4], args[i + 5]));
    }
    return segments;
  }
  CurveTo2.create = create2;
})(CurveTo || (CurveTo = {}));

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/path/normalize.js
function rotate2(x, y, rad) {
  return {
    x: x * Math.cos(rad) - y * Math.sin(rad),
    y: x * Math.sin(rad) + y * Math.cos(rad)
  };
}
function q2c(x1, y1, ax, ay, x2, y2) {
  const v13 = 1 / 3;
  const v23 = 2 / 3;
  return [
    v13 * x1 + v23 * ax,
    v13 * y1 + v23 * ay,
    v13 * x2 + v23 * ax,
    v13 * y2 + v23 * ay,
    x2,
    y2
  ];
}
function a2c(x1, y1, rx, ry, angle, largeArcFlag, sweepFlag, x2, y2, recursive) {
  const v120 = Math.PI * 120 / 180;
  const rad = Math.PI / 180 * (+angle || 0);
  let res = [];
  let xy;
  let f1;
  let f2;
  let cx;
  let cy;
  if (!recursive) {
    xy = rotate2(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate2(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    const x = (x1 - x2) / 2;
    const y = (y1 - y2) / 2;
    let h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    const rx2 = rx * rx;
    const ry2 = ry * ry;
    const k = (largeArcFlag === sweepFlag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin((y1 - cy) / ry);
    f2 = Math.asin((y2 - cy) / ry);
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    if (f1 < 0) {
      f1 = Math.PI * 2 + f1;
    }
    if (f2 < 0) {
      f2 = Math.PI * 2 + f2;
    }
    if (sweepFlag && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!sweepFlag && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  let df = f2 - f1;
  if (Math.abs(df) > v120) {
    const f2old = f2;
    const x2old = x2;
    const y2old = y2;
    f2 = f1 + v120 * (sweepFlag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweepFlag, x2old, y2old, [
      f2,
      f2old,
      cx,
      cy
    ]);
  }
  df = f2 - f1;
  const c1 = Math.cos(f1);
  const s1 = Math.sin(f1);
  const c2 = Math.cos(f2);
  const s2 = Math.sin(f2);
  const t = Math.tan(df / 4);
  const hx = 4 / 3 * (rx * t);
  const hy = 4 / 3 * (ry * t);
  const m1 = [x1, y1];
  const m2 = [x1 + hx * s1, y1 - hy * c1];
  const m3 = [x2 + hx * s2, y2 - hy * c2];
  const m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  {
    res = [m2, m3, m4].concat(res).join().split(",");
    const newres = [];
    const ii = res.length;
    for (let i = 0; i < ii; i += 1) {
      newres[i] = i % 2 ? rotate2(+res[i - 1], +res[i], rad).y : rotate2(+res[i], +res[i + 1], rad).x;
    }
    return newres;
  }
}
function parse(pathData) {
  if (!pathData) {
    return null;
  }
  const spaces = "	\n\v\f\r \u2028\u2029";
  const segmentReg = new RegExp(
    `([a-z])[${spaces},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${spaces}]*,?[${spaces}]*)+)`,
    // eslint-disable-line
    "ig"
  );
  const commandParamReg = new RegExp(
    // eslint-disable-next-line
    `(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${spaces}]*,?[${spaces}]*`,
    "ig"
  );
  const paramsCount = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  };
  const segmetns = [];
  pathData.replace(segmentReg, (input, cmd, args) => {
    const params = [];
    let command = cmd.toLowerCase();
    args.replace(commandParamReg, (a, b) => {
      if (b) {
        params.push(+b);
      }
      return a;
    });
    if (command === "m" && params.length > 2) {
      segmetns.push([cmd, ...params.splice(0, 2)]);
      command = "l";
      cmd = cmd === "m" ? "l" : "L";
    }
    const count = paramsCount[command];
    while (params.length >= count) {
      segmetns.push([cmd, ...params.splice(0, count)]);
      if (!count) {
        break;
      }
    }
    return input;
  });
  return segmetns;
}
function abs(pathString) {
  const pathArray = parse(pathString);
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  let x = 0;
  let y = 0;
  let mx = 0;
  let my = 0;
  const segments = [];
  for (let i = 0, ii = pathArray.length; i < ii; i += 1) {
    const r = [];
    segments.push(r);
    const segment = pathArray[i];
    const command = segment[0];
    if (command !== command.toUpperCase()) {
      r[0] = command.toUpperCase();
      switch (r[0]) {
        case "A":
          r[1] = segment[1];
          r[2] = segment[2];
          r[3] = segment[3];
          r[4] = segment[4];
          r[5] = segment[5];
          r[6] = +segment[6] + x;
          r[7] = +segment[7] + y;
          break;
        case "V":
          r[1] = +segment[1] + y;
          break;
        case "H":
          r[1] = +segment[1] + x;
          break;
        case "M":
          mx = +segment[1] + x;
          my = +segment[2] + y;
          for (let j = 1, jj = segment.length; j < jj; j += 1) {
            r[j] = +segment[j] + (j % 2 ? x : y);
          }
          break;
        default:
          for (let j = 1, jj = segment.length; j < jj; j += 1) {
            r[j] = +segment[j] + (j % 2 ? x : y);
          }
          break;
      }
    } else {
      for (let j = 0, jj = segment.length; j < jj; j += 1) {
        r[j] = segment[j];
      }
    }
    switch (r[0]) {
      case "Z":
        x = +mx;
        y = +my;
        break;
      case "H":
        x = r[1];
        break;
      case "V":
        y = r[1];
        break;
      case "M":
        mx = r[r.length - 2];
        my = r[r.length - 1];
        x = r[r.length - 2];
        y = r[r.length - 1];
        break;
      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
        break;
    }
  }
  return segments;
}
function normalize(path2) {
  const pathArray = abs(path2);
  const attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
  function processPath(path3, d, pcom) {
    let nx;
    let ny;
    if (!path3) {
      return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
    }
    if (!(path3[0] in { T: 1, Q: 1 })) {
      d.qx = null;
      d.qy = null;
    }
    switch (path3[0]) {
      case "M":
        d.X = path3[1];
        d.Y = path3[2];
        break;
      case "A":
        if (parseFloat(path3[1]) === 0 || parseFloat(path3[2]) === 0) {
          return ["L", path3[6], path3[7]];
        }
        return ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path3.slice(1))));
      case "S":
        if (pcom === "C" || pcom === "S") {
          nx = d.x * 2 - d.bx;
          ny = d.y * 2 - d.by;
        } else {
          nx = d.x;
          ny = d.y;
        }
        return ["C", nx, ny].concat(path3.slice(1));
      case "T":
        if (pcom === "Q" || pcom === "T") {
          d.qx = d.x * 2 - d.qx;
          d.qy = d.y * 2 - d.qy;
        } else {
          d.qx = d.x;
          d.qy = d.y;
        }
        return ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path3[1], path3[2]));
      case "Q":
        d.qx = path3[1];
        d.qy = path3[2];
        return ["C"].concat(q2c(d.x, d.y, path3[1], path3[2], path3[3], path3[4]));
      case "H":
        return ["L"].concat(path3[1], d.y);
      case "V":
        return ["L"].concat(d.x, path3[1]);
      case "L":
        break;
      case "Z":
        break;
      default:
        break;
    }
    return path3;
  }
  function fixArc(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      const pi = pp[i];
      while (pi.length) {
        commands[i] = "A";
        i += 1;
        pp.splice(i, 0, ["C"].concat(pi.splice(0, 6)));
      }
      pp.splice(i, 1);
      ii = pathArray.length;
    }
  }
  const commands = [];
  let prevCommand = "";
  let ii = pathArray.length;
  for (let i = 0; i < ii; i += 1) {
    let command = "";
    if (pathArray[i]) {
      command = pathArray[i][0];
    }
    if (command !== "C") {
      commands[i] = command;
      if (i > 0) {
        prevCommand = commands[i - 1];
      }
    }
    pathArray[i] = processPath(pathArray[i], attrs, prevCommand);
    if (commands[i] !== "A" && command === "C") {
      commands[i] = "C";
    }
    fixArc(pathArray, i);
    const seg = pathArray[i];
    const seglen = seg.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
  }
  if (!pathArray[0][0] || pathArray[0][0] !== "M") {
    pathArray.unshift(["M", 0, 0]);
  }
  return pathArray;
}
function normalizePathData(pathData) {
  return normalize(pathData).map((segment) => segment.map((item) => typeof item === "string" ? item : GeometryUtil.round(item, 2))).join(",").split(",").join(" ");
}

// ../node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/path/path.js
var Path = class _Path extends Geometry {
  constructor(args) {
    super();
    this.PRECISION = 3;
    this.segments = [];
    if (Array.isArray(args)) {
      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {
        let previousObj = null;
        const arr = args;
        arr.forEach((o, i) => {
          if (i === 0) {
            this.appendSegment(_Path.createSegment("M", o.start));
          }
          if (previousObj != null && !previousObj.end.equals(o.start)) {
            this.appendSegment(_Path.createSegment("M", o.start));
          }
          if (Line.isLine(o)) {
            this.appendSegment(_Path.createSegment("L", o.end));
          } else if (Curve.isCurve(o)) {
            this.appendSegment(_Path.createSegment("C", o.controlPoint1, o.controlPoint2, o.end));
          }
          previousObj = o;
        });
      } else {
        const arr = args;
        arr.forEach((s) => {
          if (s.isSegment) {
            this.appendSegment(s);
          }
        });
      }
    } else if (args != null) {
      if (Line.isLine(args)) {
        this.appendSegment(_Path.createSegment("M", args.start));
        this.appendSegment(_Path.createSegment("L", args.end));
      } else if (Curve.isCurve(args)) {
        this.appendSegment(_Path.createSegment("M", args.start));
        this.appendSegment(_Path.createSegment("C", args.controlPoint1, args.controlPoint2, args.end));
      } else if (Polyline.isPolyline(args)) {
        if (args.points && args.points.length) {
          args.points.forEach((point, index2) => {
            const segment = index2 === 0 ? _Path.createSegment("M", point) : _Path.createSegment("L", point);
            this.appendSegment(segment);
          });
        }
      } else if (args.isSegment) {
        this.appendSegment(args);
      }
    }
  }
  get start() {
    const segments = this.segments;
    const count = segments.length;
    if (count === 0) {
      return null;
    }
    for (let i = 0; i < count; i += 1) {
      const segment = segments[i];
      if (segment.isVisible) {
        return segment.start;
      }
    }
    return segments[count - 1].end;
  }
  get end() {
    const segments = this.segments;
    const count = segments.length;
    if (count === 0) {
      return null;
    }
    for (let i = count - 1; i >= 0; i -= 1) {
      const segment = segments[i];
      if (segment.isVisible) {
        return segment.end;
      }
    }
    return segments[count - 1].end;
  }
  moveTo(...args) {
    return this.appendSegment(MoveTo.create.call(null, ...args));
  }
  lineTo(...args) {
    return this.appendSegment(LineTo.create.call(null, ...args));
  }
  curveTo(...args) {
    return this.appendSegment(CurveTo.create.call(null, ...args));
  }
  arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {
    const start = this.end || new Point();
    const points = typeof endX === "number" ? arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) : arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);
    if (points != null) {
      for (let i = 0, ii = points.length; i < ii; i += 6) {
        this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
      }
    }
    return this;
  }
  quadTo(x1, y1, x, y) {
    const start = this.end || new Point();
    const data2 = ["M", start.x, start.y];
    if (typeof x1 === "number") {
      data2.push("Q", x1, y1, x, y);
    } else {
      const p = y1;
      data2.push(`Q`, x1.x, x1.y, p.x, p.y);
    }
    const path2 = _Path.parse(data2.join(" "));
    this.appendSegment(path2.segments.slice(1));
    return this;
  }
  close() {
    return this.appendSegment(Close.create());
  }
  drawPoints(points, options = {}) {
    const raw2 = drawPoints(points, options);
    const sub = _Path.parse(raw2);
    if (sub && sub.segments) {
      this.appendSegment(sub.segments);
    }
  }
  bbox() {
    const segments = this.segments;
    const count = segments.length;
    if (count === 0) {
      return null;
    }
    let bbox2;
    for (let i = 0; i < count; i += 1) {
      const segment = segments[i];
      if (segment.isVisible) {
        const segmentBBox = segment.bbox();
        if (segmentBBox != null) {
          bbox2 = bbox2 ? bbox2.union(segmentBBox) : segmentBBox;
        }
      }
    }
    if (bbox2 != null) {
      return bbox2;
    }
    const lastSegment = segments[count - 1];
    return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);
  }
  appendSegment(seg) {
    const count = this.segments.length;
    let previousSegment = count !== 0 ? this.segments[count - 1] : null;
    let currentSegment;
    const nextSegment = null;
    if (Array.isArray(seg)) {
      for (let i = 0, ii = seg.length; i < ii; i += 1) {
        const segment = seg[i];
        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
        this.segments.push(currentSegment);
        previousSegment = currentSegment;
      }
    } else if (seg != null && seg.isSegment) {
      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
      this.segments.push(currentSegment);
    }
    return this;
  }
  insertSegment(index2, seg) {
    const count = this.segments.length;
    if (index2 < 0) {
      index2 = count + index2 + 1;
    }
    if (index2 > count || index2 < 0) {
      throw new Error("Index out of range.");
    }
    let currentSegment;
    let previousSegment = null;
    let nextSegment = null;
    if (count !== 0) {
      if (index2 >= 1) {
        previousSegment = this.segments[index2 - 1];
        nextSegment = previousSegment.nextSegment;
      } else {
        previousSegment = null;
        nextSegment = this.segments[0];
      }
    }
    if (!Array.isArray(seg)) {
      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
      this.segments.splice(index2, 0, currentSegment);
    } else {
      for (let i = 0, ii = seg.length; i < ii; i += 1) {
        const segment = seg[i];
        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
        this.segments.splice(index2 + i, 0, currentSegment);
        previousSegment = currentSegment;
      }
    }
    return this;
  }
  removeSegment(index2) {
    const idx = this.fixIndex(index2);
    const removedSegment = this.segments.splice(idx, 1)[0];
    const previousSegment = removedSegment.previousSegment;
    const nextSegment = removedSegment.nextSegment;
    if (previousSegment) {
      previousSegment.nextSegment = nextSegment;
    }
    if (nextSegment) {
      nextSegment.previousSegment = previousSegment;
    }
    if (removedSegment.isSubpathStart && nextSegment) {
      this.updateSubpathStartSegment(nextSegment);
    }
    return removedSegment;
  }
  replaceSegment(index2, seg) {
    const idx = this.fixIndex(index2);
    let currentSegment;
    const replacedSegment = this.segments[idx];
    let previousSegment = replacedSegment.previousSegment;
    const nextSegment = replacedSegment.nextSegment;
    let updateSubpathStart = replacedSegment.isSubpathStart;
    if (!Array.isArray(seg)) {
      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
      this.segments.splice(idx, 1, currentSegment);
      if (updateSubpathStart && currentSegment.isSubpathStart) {
        updateSubpathStart = false;
      }
    } else {
      this.segments.splice(index2, 1);
      for (let i = 0, ii = seg.length; i < ii; i += 1) {
        const segment = seg[i];
        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
        this.segments.splice(index2 + i, 0, currentSegment);
        previousSegment = currentSegment;
        if (updateSubpathStart && currentSegment.isSubpathStart) {
          updateSubpathStart = false;
        }
      }
    }
    if (updateSubpathStart && nextSegment) {
      this.updateSubpathStartSegment(nextSegment);
    }
  }
  getSegment(index2) {
    const idx = this.fixIndex(index2);
    return this.segments[idx];
  }
  fixIndex(index2) {
    const length2 = this.segments.length;
    if (length2 === 0) {
      throw new Error("Path has no segments.");
    }
    let i = index2;
    while (i < 0) {
      i = length2 + i;
    }
    if (i >= length2 || i < 0) {
      throw new Error("Index out of range.");
    }
    return i;
  }
  segmentAt(ratio2, options = {}) {
    const index2 = this.segmentIndexAt(ratio2, options);
    if (!index2) {
      return null;
    }
    return this.getSegment(index2);
  }
  segmentAtLength(length2, options = {}) {
    const index2 = this.segmentIndexAtLength(length2, options);
    if (!index2)
      return null;
    return this.getSegment(index2);
  }
  segmentIndexAt(ratio2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    const rate = GeometryUtil.clamp(ratio2, 0, 1);
    const opt = this.getOptions(options);
    const len = this.length(opt);
    const length2 = len * rate;
    return this.segmentIndexAtLength(length2, opt);
  }
  segmentIndexAtLength(length2, options = {}) {
    const count = this.segments.length;
    if (count === 0) {
      return null;
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let memo = 0;
    let lastVisibleIndex = null;
    for (let i = 0; i < count; i += 1) {
      const index2 = fromStart ? i : count - 1 - i;
      const segment = this.segments[index2];
      const subdivisions = segmentSubdivisions[index2];
      const len = segment.length({ precision, subdivisions });
      if (segment.isVisible) {
        if (length2 <= memo + len) {
          return index2;
        }
        lastVisibleIndex = index2;
      }
      memo += len;
    }
    return lastVisibleIndex;
  }
  getSegmentSubdivisions(options = {}) {
    const precision = this.getPrecision(options);
    const segmentSubdivisions = [];
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segment.getSubdivisions({ precision });
      segmentSubdivisions.push(subdivisions);
    }
    return segmentSubdivisions;
  }
  updateSubpathStartSegment(segment) {
    let previous = segment.previousSegment;
    let current = segment;
    while (current && !current.isSubpathStart) {
      if (previous != null) {
        current.subpathStartSegment = previous.subpathStartSegment;
      } else {
        current.subpathStartSegment = null;
      }
      previous = current;
      current = current.nextSegment;
    }
  }
  prepareSegment(segment, previousSegment, nextSegment) {
    segment.previousSegment = previousSegment;
    segment.nextSegment = nextSegment;
    if (previousSegment != null) {
      previousSegment.nextSegment = segment;
    }
    if (nextSegment != null) {
      nextSegment.previousSegment = segment;
    }
    let updateSubpathStart = segment;
    if (segment.isSubpathStart) {
      segment.subpathStartSegment = segment;
      updateSubpathStart = nextSegment;
    }
    if (updateSubpathStart != null) {
      this.updateSubpathStartSegment(updateSubpathStart);
    }
    return segment;
  }
  closestPoint(p, options = {}) {
    const t = this.closestPointT(p, options);
    if (!t) {
      return null;
    }
    return this.pointAtT(t);
  }
  closestPointLength(p, options = {}) {
    const opts = this.getOptions(options);
    const t = this.closestPointT(p, opts);
    if (!t) {
      return 0;
    }
    return this.lengthAtT(t, opts);
  }
  closestPointNormalizedLength(p, options = {}) {
    const opts = this.getOptions(options);
    const cpLength = this.closestPointLength(p, opts);
    if (cpLength === 0) {
      return 0;
    }
    const length2 = this.length(opts);
    if (length2 === 0) {
      return 0;
    }
    return cpLength / length2;
  }
  closestPointT(p, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let closestPointT;
    let minSquaredDistance = Infinity;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segmentSubdivisions[i];
      if (segment.isVisible) {
        const segmentClosestPointT = segment.closestPointT(p, {
          precision,
          subdivisions
        });
        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
        const squaredDistance = GeometryUtil.squaredLength(segmentClosestPoint, p);
        if (squaredDistance < minSquaredDistance) {
          closestPointT = { segmentIndex: i, value: segmentClosestPointT };
          minSquaredDistance = squaredDistance;
        }
      }
    }
    if (closestPointT) {
      return closestPointT;
    }
    return { segmentIndex: this.segments.length - 1, value: 1 };
  }
  closestPointTangent(p, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let closestPointTangent;
    let minSquaredDistance = Infinity;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segmentSubdivisions[i];
      if (segment.isDifferentiable()) {
        const segmentClosestPointT = segment.closestPointT(p, {
          precision,
          subdivisions
        });
        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
        const squaredDistance = GeometryUtil.squaredLength(segmentClosestPoint, p);
        if (squaredDistance < minSquaredDistance) {
          closestPointTangent = segment.tangentAtT(segmentClosestPointT);
          minSquaredDistance = squaredDistance;
        }
      }
    }
    if (closestPointTangent) {
      return closestPointTangent;
    }
    return null;
  }
  containsPoint(p, options = {}) {
    const polylines = this.toPolylines(options);
    if (!polylines) {
      return false;
    }
    let numIntersections = 0;
    for (let i = 0, ii = polylines.length; i < ii; i += 1) {
      const polyline = polylines[i];
      if (polyline.containsPoint(p)) {
        numIntersections += 1;
      }
    }
    return numIntersections % 2 === 1;
  }
  pointAt(ratio2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    if (ratio2 <= 0) {
      return this.start.clone();
    }
    if (ratio2 >= 1) {
      return this.end.clone();
    }
    const opts = this.getOptions(options);
    const pathLength = this.length(opts);
    const length2 = pathLength * ratio2;
    return this.pointAtLength(length2, opts);
  }
  pointAtLength(length2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    if (length2 === 0) {
      return this.start.clone();
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let lastVisibleSegment;
    let memo = 0;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const index2 = fromStart ? i : ii - 1 - i;
      const segment = this.segments[index2];
      const subdivisions = segmentSubdivisions[index2];
      const d = segment.length({
        precision,
        subdivisions
      });
      if (segment.isVisible) {
        if (length2 <= memo + d) {
          return segment.pointAtLength((fromStart ? 1 : -1) * (length2 - memo), {
            precision,
            subdivisions
          });
        }
        lastVisibleSegment = segment;
      }
      memo += d;
    }
    if (lastVisibleSegment) {
      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;
    }
    const lastSegment = this.segments[this.segments.length - 1];
    return lastSegment.end.clone();
  }
  pointAtT(t) {
    const segments = this.segments;
    const numSegments = segments.length;
    if (numSegments === 0)
      return null;
    const segmentIndex = t.segmentIndex;
    if (segmentIndex < 0)
      return segments[0].pointAtT(0);
    if (segmentIndex >= numSegments) {
      return segments[numSegments - 1].pointAtT(1);
    }
    const tValue = GeometryUtil.clamp(t.value, 0, 1);
    return segments[segmentIndex].pointAtT(tValue);
  }
  divideAt(ratio2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    const rate = GeometryUtil.clamp(ratio2, 0, 1);
    const opts = this.getOptions(options);
    const len = this.length(opts);
    const length2 = len * rate;
    return this.divideAtLength(length2, opts);
  }
  divideAtLength(length2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let memo = 0;
    let divided;
    let dividedSegmentIndex;
    let lastValidSegment;
    let lastValidSegmentIndex;
    let t;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const index3 = fromStart ? i : ii - 1 - i;
      const segment = this.getSegment(index3);
      const subdivisions = segmentSubdivisions[index3];
      const opts = { precision, subdivisions };
      const len = segment.length(opts);
      if (segment.isDifferentiable()) {
        lastValidSegment = segment;
        lastValidSegmentIndex = index3;
        if (length2 <= memo + len) {
          dividedSegmentIndex = index3;
          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length2 - memo), opts);
          break;
        }
      }
      memo += len;
    }
    if (!lastValidSegment) {
      return null;
    }
    if (!divided) {
      dividedSegmentIndex = lastValidSegmentIndex;
      t = fromStart ? 1 : 0;
      divided = lastValidSegment.divideAtT(t);
    }
    const pathCopy = this.clone();
    const index2 = dividedSegmentIndex;
    pathCopy.replaceSegment(index2, divided);
    const divisionStartIndex = index2;
    let divisionMidIndex = index2 + 1;
    let divisionEndIndex = index2 + 2;
    if (!divided[0].isDifferentiable()) {
      pathCopy.removeSegment(divisionStartIndex);
      divisionMidIndex -= 1;
      divisionEndIndex -= 1;
    }
    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
    pathCopy.insertSegment(divisionMidIndex, _Path.createSegment("M", movetoEnd));
    divisionEndIndex += 1;
    if (!divided[1].isDifferentiable()) {
      pathCopy.removeSegment(divisionEndIndex - 1);
      divisionEndIndex -= 1;
    }
    const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;
    for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {
      const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);
      const segment = pathCopy.getSegment(i);
      if (segment.type === "Z" && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {
        const convertedSegment = _Path.createSegment("L", originalSegment.end);
        pathCopy.replaceSegment(i, convertedSegment);
      }
    }
    const firstPath = new _Path(pathCopy.segments.slice(0, divisionMidIndex));
    const secondPath = new _Path(pathCopy.segments.slice(divisionMidIndex));
    return [firstPath, secondPath];
  }
  intersectsWithLine(line2, options = {}) {
    const polylines = this.toPolylines(options);
    if (polylines == null) {
      return null;
    }
    let intersections = null;
    for (let i = 0, ii = polylines.length; i < ii; i += 1) {
      const polyline = polylines[i];
      const intersection2 = line2.intersect(polyline);
      if (intersection2) {
        if (intersections == null) {
          intersections = [];
        }
        if (Array.isArray(intersection2)) {
          intersections.push(...intersection2);
        } else {
          intersections.push(intersection2);
        }
      }
    }
    return intersections;
  }
  isDifferentiable() {
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      if (segment.isDifferentiable()) {
        return true;
      }
    }
    return false;
  }
  isValid() {
    const segments = this.segments;
    const isValid2 = segments.length === 0 || segments[0].type === "M";
    return isValid2;
  }
  length(options = {}) {
    if (this.segments.length === 0) {
      return 0;
    }
    const segmentSubdivisions = this.getSubdivisions(options);
    let length2 = 0;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segmentSubdivisions[i];
      length2 += segment.length({ subdivisions });
    }
    return length2;
  }
  lengthAtT(t, options = {}) {
    const count = this.segments.length;
    if (count === 0) {
      return 0;
    }
    let segmentIndex = t.segmentIndex;
    if (segmentIndex < 0) {
      return 0;
    }
    let tValue = GeometryUtil.clamp(t.value, 0, 1);
    if (segmentIndex >= count) {
      segmentIndex = count - 1;
      tValue = 1;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let length2 = 0;
    for (let i = 0; i < segmentIndex; i += 1) {
      const segment2 = this.segments[i];
      const subdivisions2 = segmentSubdivisions[i];
      length2 += segment2.length({ precision, subdivisions: subdivisions2 });
    }
    const segment = this.segments[segmentIndex];
    const subdivisions = segmentSubdivisions[segmentIndex];
    length2 += segment.lengthAtT(tValue, { precision, subdivisions });
    return length2;
  }
  tangentAt(ratio2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    const rate = GeometryUtil.clamp(ratio2, 0, 1);
    const opts = this.getOptions(options);
    const len = this.length(opts);
    const length2 = len * rate;
    return this.tangentAtLength(length2, opts);
  }
  tangentAtLength(length2, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }
    let fromStart = true;
    if (length2 < 0) {
      fromStart = false;
      length2 = -length2;
    }
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let lastValidSegment;
    let memo = 0;
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const index2 = fromStart ? i : ii - 1 - i;
      const segment = this.segments[index2];
      const subdivisions = segmentSubdivisions[index2];
      const len = segment.length({ precision, subdivisions });
      if (segment.isDifferentiable()) {
        if (length2 <= memo + len) {
          return segment.tangentAtLength((fromStart ? 1 : -1) * (length2 - memo), {
            precision,
            subdivisions
          });
        }
        lastValidSegment = segment;
      }
      memo += len;
    }
    if (lastValidSegment) {
      const t = fromStart ? 1 : 0;
      return lastValidSegment.tangentAtT(t);
    }
    return null;
  }
  tangentAtT(t) {
    const count = this.segments.length;
    if (count === 0) {
      return null;
    }
    const segmentIndex = t.segmentIndex;
    if (segmentIndex < 0) {
      return this.segments[0].tangentAtT(0);
    }
    if (segmentIndex >= count) {
      return this.segments[count - 1].tangentAtT(1);
    }
    const tValue = GeometryUtil.clamp(t.value, 0, 1);
    return this.segments[segmentIndex].tangentAtT(tValue);
  }
  getPrecision(options = {}) {
    return options.precision == null ? this.PRECISION : options.precision;
  }
  getSubdivisions(options = {}) {
    if (options.segmentSubdivisions == null) {
      const precision = this.getPrecision(options);
      return this.getSegmentSubdivisions({ precision });
    }
    return options.segmentSubdivisions;
  }
  getOptions(options = {}) {
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    return { precision, segmentSubdivisions };
  }
  toPoints(options = {}) {
    const segments = this.segments;
    const count = segments.length;
    if (count === 0) {
      return null;
    }
    const segmentSubdivisions = this.getSubdivisions(options);
    const points = [];
    let partialPoints = [];
    for (let i = 0; i < count; i += 1) {
      const segment = segments[i];
      if (segment.isVisible) {
        const divisions = segmentSubdivisions[i];
        if (divisions.length > 0) {
          divisions.forEach((c) => partialPoints.push(c.start));
        } else {
          partialPoints.push(segment.start);
        }
      } else if (partialPoints.length > 0) {
        partialPoints.push(segments[i - 1].end);
        points.push(partialPoints);
        partialPoints = [];
      }
    }
    if (partialPoints.length > 0) {
      partialPoints.push(this.end);
      points.push(partialPoints);
    }
    return points;
  }
  toPolylines(options = {}) {
    const points = this.toPoints(options);
    if (!points) {
      return null;
    }
    return points.map((arr) => new Polyline(arr));
  }
  scale(sx, sy, origin) {
    this.segments.forEach((s) => s.scale(sx, sy, origin));
    return this;
  }
  rotate(angle, origin) {
    this.segments.forEach((segment) => segment.rotate(angle, origin));
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "number") {
      this.segments.forEach((s) => s.translate(tx, ty));
    } else {
      this.segments.forEach((s) => s.translate(tx));
    }
    return this;
  }
  clone() {
    const path2 = new _Path();
    this.segments.forEach((s) => path2.appendSegment(s.clone()));
    return path2;
  }
  equals(p) {
    if (p == null) {
      return false;
    }
    const segments = this.segments;
    const otherSegments = p.segments;
    const count = segments.length;
    if (otherSegments.length !== count) {
      return false;
    }
    for (let i = 0; i < count; i += 1) {
      const a = segments[i];
      const b = otherSegments[i];
      if (a.type !== b.type || !a.equals(b)) {
        return false;
      }
    }
    return true;
  }
  toJSON() {
    return this.segments.map((s) => s.toJSON());
  }
  serialize() {
    if (!this.isValid()) {
      throw new Error("Invalid path segments.");
    }
    return this.segments.map((s) => s.serialize()).join(" ");
  }
  toString() {
    return this.serialize();
  }
};
(function(Path3) {
  function isPath(instance) {
    return instance != null && instance instanceof Path3;
  }
  Path3.isPath = isPath;
})(Path || (Path = {}));
(function(Path3) {
  function parse2(pathData) {
    if (!pathData) {
      return new Path3();
    }
    const path2 = new Path3();
    const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
    const commands = Path3.normalize(pathData).match(commandRe);
    if (commands != null) {
      for (let i = 0, ii = commands.length; i < ii; i += 1) {
        const command = commands[i];
        const argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g;
        const args = command.match(argRe);
        if (args != null) {
          const type = args[0];
          const coords = args.slice(1).map((a) => +a);
          const segment = createSegment.call(null, type, ...coords);
          path2.appendSegment(segment);
        }
      }
    }
    return path2;
  }
  Path3.parse = parse2;
  function createSegment(type, ...args) {
    if (type === "M") {
      return MoveTo.create.call(null, ...args);
    }
    if (type === "L") {
      return LineTo.create.call(null, ...args);
    }
    if (type === "C") {
      return CurveTo.create.call(null, ...args);
    }
    if (type === "z" || type === "Z") {
      return Close.create();
    }
    throw new Error(`Invalid path segment type "${type}"`);
  }
  Path3.createSegment = createSegment;
})(Path || (Path = {}));
(function(Path3) {
  Path3.normalize = normalizePathData;
  Path3.isValid = isValid;
  Path3.drawArc = drawArc;
  Path3.drawPoints = drawPoints;
  Path3.arcToCurves = arcToCurves;
})(Path || (Path = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/index.js
var registry_exports = {};
__export(registry_exports, {
  Attr: () => Attr,
  Background: () => Background,
  ConnectionPoint: () => ConnectionPoint,
  Connector: () => Connector,
  EdgeAnchor: () => EdgeAnchor,
  EdgeTool: () => EdgeTool,
  Filter: () => Filter,
  Grid: () => Grid,
  Highlighter: () => Highlighter,
  Marker: () => Marker,
  NodeAnchor: () => NodeAnchor,
  NodeTool: () => NodeTool,
  PortLabelLayout: () => PortLabelLayout,
  PortLayout: () => PortLayout,
  Registry: () => Registry,
  Router: () => Router
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/registry.js
var Registry = class {
  constructor(options) {
    this.options = Object.assign({}, options);
    this.data = this.options.data || {};
    this.register = this.register.bind(this);
    this.unregister = this.unregister.bind(this);
  }
  get names() {
    return Object.keys(this.data);
  }
  register(name, options, force = false) {
    if (typeof name === "object") {
      Object.entries(name).forEach(([key, val]) => {
        this.register(key, val, options);
      });
      return;
    }
    if (this.exist(name) && !force && !Platform.isApplyingHMR()) {
      this.onDuplicated(name);
    }
    const process = this.options.process;
    const entity = process ? main_exports.call(process, this, name, options) : options;
    this.data[name] = entity;
    return entity;
  }
  unregister(name) {
    const entity = name ? this.data[name] : null;
    delete this.data[name];
    return entity;
  }
  get(name) {
    return name ? this.data[name] : null;
  }
  exist(name) {
    return name ? this.data[name] != null : false;
  }
  onDuplicated(name) {
    try {
      if (this.options.onConflict) {
        main_exports.call(this.options.onConflict, this, name);
      }
      throw new Error(`${string_exports.upperFirst(this.options.type)} with name '${name}' already registered.`);
    } catch (err) {
      throw err;
    }
  }
  onNotFound(name, prefix) {
    throw new Error(this.getSpellingSuggestion(name, prefix));
  }
  getSpellingSuggestion(name, prefix) {
    const suggestion = this.getSpellingSuggestionForName(name);
    const prefixed = prefix ? `${prefix} ${string_exports.lowerFirst(this.options.type)}` : this.options.type;
    return (
      // eslint-disable-next-line
      `${string_exports.upperFirst(prefixed)} with name '${name}' does not exist.${suggestion ? ` Did you mean '${suggestion}'?` : ""}`
    );
  }
  getSpellingSuggestionForName(name) {
    return string_exports.getSpellingSuggestion(name, Object.keys(this.data), (candidate) => candidate);
  }
};
(function(Registry2) {
  function create2(options) {
    return new Registry2(options);
  }
  Registry2.create = create2;
})(Registry || (Registry = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/grid/main.js
var main_exports4 = {};
__export(main_exports4, {
  dot: () => dot,
  doubleMesh: () => doubleMesh,
  fixedDot: () => fixedDot,
  mesh: () => mesh
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/grid/dot.js
var dot = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(elem, options) {
    const width2 = options.thickness * options.sx;
    const height2 = options.thickness * options.sy;
    main_exports3.attr(elem, {
      width: width2,
      height: height2,
      rx: width2,
      ry: height2,
      fill: options.color
    });
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/grid/fixed-dot.js
var fixedDot = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(elem, options) {
    const size2 = options.sx <= 1 ? options.thickness * options.sx : options.thickness;
    main_exports3.attr(elem, {
      width: size2,
      height: size2,
      rx: size2,
      ry: size2,
      fill: options.color
    });
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/grid/mesh.js
var mesh = {
  color: "rgba(224,224,224,1)",
  thickness: 1,
  markup: "path",
  update(elem, options) {
    let d;
    const width2 = options.width;
    const height2 = options.height;
    const thickness = options.thickness;
    if (width2 - thickness >= 0 && height2 - thickness >= 0) {
      d = ["M", width2, 0, "H0 M0 0 V0", height2].join(" ");
    } else {
      d = "M 0 0 0 0";
    }
    main_exports3.attr(elem, {
      d,
      stroke: options.color,
      "stroke-width": options.thickness
    });
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/grid/double-mesh.js
var doubleMesh = [
  {
    color: "rgba(224,224,224,1)",
    thickness: 1,
    markup: "path",
    update(elem, options) {
      let d;
      const width2 = options.width;
      const height2 = options.height;
      const thickness = options.thickness;
      if (width2 - thickness >= 0 && height2 - thickness >= 0) {
        d = ["M", width2, 0, "H0 M0 0 V0", height2].join(" ");
      } else {
        d = "M 0 0 0 0";
      }
      main_exports3.attr(elem, {
        d,
        stroke: options.color,
        "stroke-width": options.thickness
      });
    }
  },
  {
    color: "rgba(224,224,224,0.2)",
    thickness: 3,
    factor: 4,
    markup: "path",
    update(elem, options) {
      let d;
      const factor = options.factor || 1;
      const width2 = options.width * factor;
      const height2 = options.height * factor;
      const thickness = options.thickness;
      if (width2 - thickness >= 0 && height2 - thickness >= 0) {
        d = ["M", width2, 0, "H0 M0 0 V0", height2].join(" ");
      } else {
        d = "M 0 0 0 0";
      }
      options.width = width2;
      options.height = height2;
      main_exports3.attr(elem, {
        d,
        stroke: options.color,
        "stroke-width": options.thickness
      });
    }
  }
];

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/grid/index.js
var Grid = class {
  constructor() {
    this.patterns = {};
    this.root = Vector.create(main_exports3.createSvgDocument(), {
      width: "100%",
      height: "100%"
    }, [main_exports3.createSvgElement("defs")]).node;
  }
  add(id, elem) {
    const firstChild = this.root.childNodes[0];
    if (firstChild) {
      firstChild.appendChild(elem);
    }
    this.patterns[id] = elem;
    Vector.create("rect", {
      width: "100%",
      height: "100%",
      fill: `url(#${id})`
    }).appendTo(this.root);
  }
  get(id) {
    return this.patterns[id];
  }
  has(id) {
    return this.patterns[id] != null;
  }
};
(function(Grid2) {
  Grid2.presets = main_exports4;
  Grid2.registry = Registry.create({
    type: "grid"
  });
  Grid2.registry.register(Grid2.presets, true);
})(Grid || (Grid = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/background/main.js
var main_exports5 = {};
__export(main_exports5, {
  flipX: () => flipX,
  flipXY: () => flipXY,
  flipY: () => flipY,
  watermark: () => watermark
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/background/flip-x.js
var flipX = function(img) {
  const canvas = document.createElement("canvas");
  const width2 = img.width;
  const height2 = img.height;
  canvas.width = width2 * 2;
  canvas.height = height2;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, width2, height2);
  ctx.translate(2 * width2, 0);
  ctx.scale(-1, 1);
  ctx.drawImage(img, 0, 0, width2, height2);
  return canvas;
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/background/flip-y.js
var flipY = function(img) {
  const canvas = document.createElement("canvas");
  const width2 = img.width;
  const height2 = img.height;
  canvas.width = width2;
  canvas.height = height2 * 2;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, width2, height2);
  ctx.translate(0, 2 * height2);
  ctx.scale(1, -1);
  ctx.drawImage(img, 0, 0, width2, height2);
  return canvas;
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/background/flip-xy.js
var flipXY = function(img) {
  const canvas = document.createElement("canvas");
  const width2 = img.width;
  const height2 = img.height;
  canvas.width = 2 * width2;
  canvas.height = 2 * height2;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, width2, height2);
  ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0, width2, height2);
  ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
  ctx.drawImage(img, 0, 0, width2, height2);
  ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
  ctx.drawImage(img, 0, 0, width2, height2);
  return canvas;
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/background/watermark.js
var watermark = function(img, options) {
  const width2 = img.width;
  const height2 = img.height;
  const canvas = document.createElement("canvas");
  canvas.width = width2 * 3;
  canvas.height = height2 * 3;
  const ctx = canvas.getContext("2d");
  const angle = options.angle != null ? -options.angle : -20;
  const radians = Angle.toRad(angle);
  const stepX = canvas.width / 4;
  const stepY = canvas.height / 4;
  for (let i = 0; i < 4; i += 1) {
    for (let j = 0; j < 4; j += 1) {
      if ((i + j) % 2 > 0) {
        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
        ctx.rotate(radians);
        ctx.drawImage(img, -width2 / 2, -height2 / 2, width2, height2);
      }
    }
  }
  return canvas;
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/background/index.js
var Background;
(function(Background2) {
  Background2.presets = Object.assign({}, main_exports5);
  Background2.presets["flip-x"] = flipX;
  Background2.presets["flip-y"] = flipY;
  Background2.presets["flip-xy"] = flipXY;
  Background2.registry = Registry.create({
    type: "background pattern"
  });
  Background2.registry.register(Background2.presets, true);
})(Background || (Background = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/main.js
var main_exports6 = {};
__export(main_exports6, {
  blur: () => blur,
  brightness: () => brightness,
  contrast: () => contrast,
  dropShadow: () => dropShadow,
  grayScale: () => grayScale,
  highlight: () => highlight,
  hueRotate: () => hueRotate,
  invert: () => invert2,
  outline: () => outline,
  saturate: () => saturate,
  sepia: () => sepia
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/util.js
function getString(value, defaultValue) {
  return value != null ? value : defaultValue;
}
function getNumber2(num, defaultValue) {
  return num != null && Number.isFinite(num) ? num : defaultValue;
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/outline.js
function outline(args = {}) {
  const color = getString(args.color, "blue");
  const width2 = getNumber2(args.width, 1);
  const margin = getNumber2(args.margin, 2);
  const opacity2 = getNumber2(args.opacity, 1);
  const innerRadius = margin;
  const outerRadius = margin + width2;
  return `
    <filter>
      <feFlood flood-color="${color}" flood-opacity="${opacity2}" result="colored"/>
      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" />
      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" />
      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>
      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>
      <feMerge>
        <feMergeNode in="outline"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/highlight.js
function highlight(args = {}) {
  const color = getString(args.color, "red");
  const blur2 = getNumber2(args.blur, 0);
  const width2 = getNumber2(args.width, 1);
  const opacity2 = getNumber2(args.opacity, 1);
  return `
      <filter>
        <feFlood flood-color="${color}" flood-opacity="${opacity2}" result="colored"/>
        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width2}"/>
        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>
        <feGaussianBlur result="blured" in="composed" stdDeviation="${blur2}"/>
        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>
      </filter>
    `.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/blur.js
function blur(args = {}) {
  const x = getNumber2(args.x, 2);
  const stdDeviation = args.y != null && Number.isFinite(args.y) ? [x, args.y] : x;
  return `
    <filter>
      <feGaussianBlur stdDeviation="${stdDeviation}"/>
    </filter>
  `.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/drop-shadow.js
function dropShadow(args = {}) {
  const dx = getNumber2(args.dx, 0);
  const dy = getNumber2(args.dy, 0);
  const color = getString(args.color, "black");
  const blur2 = getNumber2(args.blur, 4);
  const opacity2 = getNumber2(args.opacity, 1);
  return "SVGFEDropShadowElement" in window ? `<filter>
         <feDropShadow stdDeviation="${blur2}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity2}" />
       </filter>`.trim() : `<filter>
         <feGaussianBlur in="SourceAlpha" stdDeviation="${blur2}" />
         <feOffset dx="${dx}" dy="${dy}" result="offsetblur" />
         <feFlood flood-color="${color}" />
         <feComposite in2="offsetblur" operator="in" />
         <feComponentTransfer>
           <feFuncA type="linear" slope="${opacity2}" />
         </feComponentTransfer>
         <feMerge>
           <feMergeNode/>
           <feMergeNode in="SourceGraphic"/>
         </feMerge>
       </filter>`.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/gray-scale.js
function grayScale(args = {}) {
  const amount = getNumber2(args.amount, 1);
  const a = 0.2126 + 0.7874 * (1 - amount);
  const b = 0.7152 - 0.7152 * (1 - amount);
  const c = 0.0722 - 0.0722 * (1 - amount);
  const d = 0.2126 - 0.2126 * (1 - amount);
  const e = 0.7152 + 0.2848 * (1 - amount);
  const f = 0.0722 - 0.0722 * (1 - amount);
  const g = 0.2126 - 0.2126 * (1 - amount);
  const h = 0.0722 + 0.9278 * (1 - amount);
  return `
    <filter>
      <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/>
    </filter>
  `.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/sepia.js
function sepia(args = {}) {
  const amount = getNumber2(args.amount, 1);
  const a = 0.393 + 0.607 * (1 - amount);
  const b = 0.769 - 0.769 * (1 - amount);
  const c = 0.189 - 0.189 * (1 - amount);
  const d = 0.349 - 0.349 * (1 - amount);
  const e = 0.686 + 0.314 * (1 - amount);
  const f = 0.168 - 0.168 * (1 - amount);
  const g = 0.272 - 0.272 * (1 - amount);
  const h = 0.534 - 0.534 * (1 - amount);
  const i = 0.131 + 0.869 * (1 - amount);
  return `
      <filter>
        <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/>
      </filter>
    `.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/saturate.js
function saturate(args = {}) {
  const amount = getNumber2(args.amount, 1);
  return `
      <filter>
        <feColorMatrix type="saturate" values="${1 - amount}"/>
      </filter>
    `.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/hue-rotate.js
function hueRotate(args = {}) {
  const angle = getNumber2(args.angle, 0);
  return `
      <filter>
        <feColorMatrix type="hueRotate" values="${angle}"/>
      </filter>
    `.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/invert.js
function invert2(args = {}) {
  const amount = getNumber2(args.amount, 1);
  const amount2 = 1 - amount;
  return `
      <filter>
        <feComponentTransfer>
          <feFuncR type="table" tableValues="${amount} ${amount2}"/>
          <feFuncG type="table" tableValues="${amount} ${amount2}"/>
          <feFuncB type="table" tableValues="${amount} ${amount2}"/>
        </feComponentTransfer>
      </filter>
    `.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/brightness.js
function brightness(args = {}) {
  const amount = getNumber2(args.amount, 1);
  return `
    <filter>
      <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}"/>
        <feFuncG type="linear" slope="${amount}"/>
        <feFuncB type="linear" slope="${amount}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/contrast.js
function contrast(args = {}) {
  const amount = getNumber2(args.amount, 1);
  const amount2 = 0.5 - amount / 2;
  return `
    <filter>
     <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncG type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncB type="linear" slope="${amount}" intercept="${amount2}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/filter/index.js
var Filter;
(function(Filter2) {
  Filter2.presets = main_exports6;
  Filter2.registry = Registry.create({
    type: "filter"
  });
  Filter2.registry.register(Filter2.presets, true);
})(Filter || (Filter = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/raw.js
var raw = {
  xlinkHref: "xlink:href",
  xlinkShow: "xlink:show",
  xlinkRole: "xlink:role",
  xlinkType: "xlink:type",
  xlinkArcrole: "xlink:arcrole",
  xlinkTitle: "xlink:title",
  xlinkActuate: "xlink:actuate",
  xmlSpace: "xml:space",
  xmlBase: "xml:base",
  xmlLang: "xml:lang",
  preserveAspectRatio: "preserveAspectRatio",
  requiredExtension: "requiredExtension",
  requiredFeatures: "requiredFeatures",
  systemLanguage: "systemLanguage",
  externalResourcesRequired: "externalResourceRequired"
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/main.js
var main_exports8 = {};
__export(main_exports8, {
  annotations: () => annotations,
  atConnectionLength: () => atConnectionLength,
  atConnectionLengthIgnoreGradient: () => atConnectionLengthIgnoreGradient,
  atConnectionLengthKeepGradient: () => atConnectionLengthKeepGradient,
  atConnectionRatio: () => atConnectionRatio,
  atConnectionRatioIgnoreGradient: () => atConnectionRatioIgnoreGradient,
  atConnectionRatioKeepGradient: () => atConnectionRatioKeepGradient,
  connection: () => connection,
  displayEmpty: () => displayEmpty,
  eol: () => eol,
  fill: () => fill2,
  filter: () => filter2,
  html: () => html,
  lineHeight: () => lineHeight,
  port: () => port,
  ref: () => ref,
  refCx: () => refCx,
  refCy: () => refCy,
  refD: () => refD,
  refDKeepOffset: () => refDKeepOffset,
  refDResetOffset: () => refDResetOffset,
  refDx: () => refDx,
  refDy: () => refDy,
  refHeight: () => refHeight,
  refHeight2: () => refHeight2,
  refPoints: () => refPoints,
  refPointsKeepOffset: () => refPointsKeepOffset,
  refPointsResetOffset: () => refPointsResetOffset,
  refR: () => refR,
  refRCircumscribed: () => refRCircumscribed,
  refRInscribed: () => refRInscribed,
  refRx: () => refRx,
  refRy: () => refRy,
  refWidth: () => refWidth,
  refWidth2: () => refWidth2,
  refX: () => refX,
  refX2: () => refX2,
  refY: () => refY,
  refY2: () => refY2,
  resetOffset: () => resetOffset,
  sourceMarker: () => sourceMarker,
  stroke: () => stroke,
  style: () => style,
  targetMarker: () => targetMarker,
  text: () => text2,
  textPath: () => textPath,
  textVerticalAnchor: () => textVerticalAnchor,
  textWrap: () => textWrap,
  title: () => title,
  vertexMarker: () => vertexMarker,
  xAlign: () => xAlign,
  yAlign: () => yAlign
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/ref.js
var ref = {
  // We do not set `ref` attribute directly on an element.
  // The attribute itself does not qualify for relative positioning.
};
var refX = {
  position: positionWrapper("x", "width", "origin")
};
var refY = {
  position: positionWrapper("y", "height", "origin")
};
var refDx = {
  position: positionWrapper("x", "width", "corner")
};
var refDy = {
  position: positionWrapper("y", "height", "corner")
};
var refWidth = {
  set: setWrapper("width", "width")
};
var refHeight = {
  set: setWrapper("height", "height")
};
var refRx = {
  set: setWrapper("rx", "width")
};
var refRy = {
  set: setWrapper("ry", "height")
};
var refRInscribed = {
  set: ((attrName) => {
    const widthFn = setWrapper(attrName, "width");
    const heightFn = setWrapper(attrName, "height");
    return function(value, options) {
      const refBBox = options.refBBox;
      const fn = refBBox.height > refBBox.width ? widthFn : heightFn;
      return main_exports.call(fn, this, value, options);
    };
  })("r")
};
var refRCircumscribed = {
  set(val, { refBBox }) {
    let value = parseFloat(val);
    const percentage = number_exports.isPercentage(val);
    if (percentage) {
      value /= 100;
    }
    const diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
    let rValue;
    if (Number.isFinite(value)) {
      if (percentage || value >= 0 && value <= 1) {
        rValue = value * diagonalLength;
      } else {
        rValue = Math.max(value + diagonalLength, 0);
      }
    }
    return { r: rValue };
  }
};
var refCx = {
  set: setWrapper("cx", "width")
};
var refCy = {
  set: setWrapper("cy", "height")
};
var refDResetOffset = {
  set: dWrapper({ resetOffset: true })
};
var refDKeepOffset = {
  set: dWrapper({ resetOffset: false })
};
var refPointsResetOffset = {
  set: pointsWrapper({ resetOffset: true })
};
var refPointsKeepOffset = {
  set: pointsWrapper({ resetOffset: false })
};
var refR = refRInscribed;
var refD = refDResetOffset;
var refPoints = refPointsResetOffset;
var refX2 = refX;
var refY2 = refY;
var refWidth2 = refWidth;
var refHeight2 = refHeight;
function positionWrapper(axis, dimension, origin) {
  return (val, { refBBox }) => {
    if (val == null) {
      return null;
    }
    let value = parseFloat(val);
    const percentage = number_exports.isPercentage(val);
    if (percentage) {
      value /= 100;
    }
    let delta;
    if (Number.isFinite(value)) {
      const refOrigin = refBBox[origin];
      if (percentage || value > 0 && value < 1) {
        delta = refOrigin[axis] + refBBox[dimension] * value;
      } else {
        delta = refOrigin[axis] + value;
      }
    }
    const point = new Point();
    point[axis] = delta || 0;
    return point;
  };
}
function setWrapper(attrName, dimension) {
  return function(val, { refBBox }) {
    let value = parseFloat(val);
    const percentage = number_exports.isPercentage(val);
    if (percentage) {
      value /= 100;
    }
    const attrs = {};
    if (Number.isFinite(value)) {
      const attrValue = percentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);
      attrs[attrName] = attrValue;
    }
    return attrs;
  };
}
function shapeWrapper(shapeConstructor, options) {
  const cacheName = "x6-shape";
  const resetOffset2 = options && options.resetOffset;
  return function(value, { elem, refBBox }) {
    let cache = main_exports3.data(elem, cacheName);
    if (!cache || cache.value !== value) {
      const cachedShape = shapeConstructor(value);
      cache = {
        value,
        shape: cachedShape,
        shapeBBox: cachedShape.bbox()
      };
      main_exports3.data(elem, cacheName, cache);
    }
    const shape = cache.shape.clone();
    const shapeBBox = cache.shapeBBox.clone();
    const shapeOrigin = shapeBBox.getOrigin();
    const refOrigin = refBBox.getOrigin();
    shapeBBox.x = refOrigin.x;
    shapeBBox.y = refOrigin.y;
    const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin);
    const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
    const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
    shape.scale(sx, sy, shapeOrigin);
    if (resetOffset2) {
      shape.translate(-shapeOrigin.x, -shapeOrigin.y);
    }
    return shape;
  };
}
function dWrapper(options) {
  function pathConstructor(value) {
    return Path.parse(value);
  }
  const shape = shapeWrapper(pathConstructor, options);
  return (value, args) => {
    const path2 = shape(value, args);
    return {
      d: path2.serialize()
    };
  };
}
function pointsWrapper(options) {
  const shape = shapeWrapper((points) => new Polyline(points), options);
  return (value, args) => {
    const polyline = shape(value, args);
    return {
      points: polyline.serialize()
    };
  };
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/fill.js
var fill2 = {
  qualify: object_exports.isPlainObject,
  set(fill3, { view }) {
    return `url(#${view.graph.defineGradient(fill3)})`;
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/stroke.js
var stroke = {
  qualify: object_exports.isPlainObject,
  set(stroke3, { view }) {
    const cell = view.cell;
    const options = Object.assign({}, stroke3);
    if (cell.isEdge() && options.type === "linearGradient") {
      const edgeView = view;
      const source = edgeView.sourcePoint;
      const target = edgeView.targetPoint;
      options.id = `gradient-${options.type}-${cell.id}`;
      options.attrs = Object.assign(Object.assign({}, options.attrs), { x1: source.x, y1: source.y, x2: target.x, y2: target.y, gradientUnits: "userSpaceOnUse" });
      view.graph.defs.remove(options.id);
    }
    return `url(#${view.graph.defineGradient(options)})`;
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/text.js
var text2 = {
  qualify(text3, { attrs }) {
    return attrs.textWrap == null || !object_exports.isPlainObject(attrs.textWrap);
  },
  set(text3, { view, elem, attrs }) {
    const cacheName = "x6-text";
    const cache = main_exports3.data(elem, cacheName);
    const json = (str) => {
      try {
        return JSON.parse(str);
      } catch (error) {
        return str;
      }
    };
    const options = {
      x: attrs.x,
      eol: attrs.eol,
      annotations: json(attrs.annotations),
      textPath: json(attrs["text-path"] || attrs.textPath),
      textVerticalAnchor: attrs["text-vertical-anchor"] || attrs.textVerticalAnchor,
      displayEmpty: (attrs["display-empty"] || attrs.displayEmpty) === "true",
      lineHeight: attrs["line-height"] || attrs.lineHeight
    };
    const fontSize = attrs["font-size"] || attrs.fontSize;
    const textHash = JSON.stringify([text3, options]);
    if (fontSize) {
      elem.setAttribute("font-size", fontSize);
    }
    if (cache == null || cache !== textHash) {
      const textPath2 = options.textPath;
      if (textPath2 != null && typeof textPath2 === "object") {
        const selector = textPath2.selector;
        if (typeof selector === "string") {
          const pathNode = view.find(selector)[0];
          if (pathNode instanceof SVGPathElement) {
            main_exports3.ensureId(pathNode);
            options.textPath = Object.assign({ "xlink:href": `#${pathNode.id}` }, textPath2);
          }
        }
      }
      main_exports3.text(elem, `${text3}`, options);
      main_exports3.data(elem, cacheName, textHash);
    }
  }
};
var textWrap = {
  qualify: object_exports.isPlainObject,
  set(val, { view, elem, attrs, refBBox }) {
    const info = val;
    const width2 = info.width || 0;
    if (number_exports.isPercentage(width2)) {
      refBBox.width *= parseFloat(width2) / 100;
    } else if (width2 <= 0) {
      refBBox.width += width2;
    } else {
      refBBox.width = width2;
    }
    const height2 = info.height || 0;
    if (number_exports.isPercentage(height2)) {
      refBBox.height *= parseFloat(height2) / 100;
    } else if (height2 <= 0) {
      refBBox.height += height2;
    } else {
      refBBox.height = height2;
    }
    let wrappedText;
    let txt = info.text;
    if (txt == null) {
      txt = attrs.text || (elem === null || elem === void 0 ? void 0 : elem.textContent);
    }
    if (txt != null) {
      wrappedText = main_exports3.breakText(`${txt}`, refBBox, {
        "font-weight": attrs["font-weight"] || attrs.fontWeight,
        "font-size": attrs["font-size"] || attrs.fontSize,
        "font-family": attrs["font-family"] || attrs.fontFamily,
        lineHeight: attrs.lineHeight
      }, {
        // svgDocument: view.graph.view.svg,
        ellipsis: info.ellipsis
        // hyphen: info.hyphen as string,
        // breakWord: info.breakWord as boolean,
      });
    } else {
      wrappedText = "";
    }
    main_exports.call(text2.set, this, wrappedText, {
      view,
      elem,
      attrs,
      refBBox,
      cell: view.cell
    });
  }
};
var isTextInUse = (val, { attrs }) => {
  return attrs.text !== void 0;
};
var lineHeight = {
  qualify: isTextInUse
};
var textVerticalAnchor = {
  qualify: isTextInUse
};
var textPath = {
  qualify: isTextInUse
};
var annotations = {
  qualify: isTextInUse
};
var eol = {
  qualify: isTextInUse
};
var displayEmpty = {
  qualify: isTextInUse
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/title.js
var title = {
  qualify(title2, { elem }) {
    return elem instanceof SVGElement;
  },
  set(val, { elem }) {
    const cacheName = "x6-title";
    const title2 = `${val}`;
    const cache = main_exports3.data(elem, cacheName);
    if (cache == null || cache !== title2) {
      main_exports3.data(elem, cacheName, title2);
      const firstChild = elem.firstChild;
      if (firstChild && firstChild.tagName.toUpperCase() === "TITLE") {
        const titleElem = firstChild;
        titleElem.textContent = title2;
      } else {
        const titleNode = document.createElementNS(elem.namespaceURI, "title");
        titleNode.textContent = title2;
        elem.insertBefore(titleNode, firstChild);
      }
    }
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/align.js
var xAlign = {
  offset: offsetWrapper("x", "width", "right")
};
var yAlign = {
  offset: offsetWrapper("y", "height", "bottom")
};
var resetOffset = {
  offset(val, { refBBox }) {
    return val ? { x: -refBBox.x, y: -refBBox.y } : { x: 0, y: 0 };
  }
};
function offsetWrapper(axis, dimension, corner) {
  return (value, { refBBox }) => {
    const point = new Point();
    let delta;
    if (value === "middle") {
      delta = refBBox[dimension] / 2;
    } else if (value === corner) {
      delta = refBBox[dimension];
    } else if (typeof value === "number" && Number.isFinite(value)) {
      delta = value > -1 && value < 1 ? -refBBox[dimension] * value : -value;
    } else if (number_exports.isPercentage(value)) {
      delta = refBBox[dimension] * parseFloat(value) / 100;
    } else {
      delta = 0;
    }
    point[axis] = -(refBBox[axis] + delta);
    return point;
  };
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/style.js
var style = {
  qualify: object_exports.isPlainObject,
  set(styles, { elem }) {
    main_exports3.css(elem, styles);
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/html.js
var html = {
  set(html2, { elem }) {
    elem.innerHTML = `${html2}`;
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/filter.js
var filter2 = {
  qualify: object_exports.isPlainObject,
  set(filter3, { view }) {
    return `url(#${view.graph.defineFilter(filter3)})`;
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/port.js
var port = {
  set(port2) {
    if (port2 != null && typeof port2 === "object" && port2.id) {
      return port2.id;
    }
    return port2;
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/marker/main.js
var main_exports7 = {};
__export(main_exports7, {
  async: () => async,
  block: () => block,
  circle: () => circle,
  circlePlus: () => circlePlus,
  classic: () => classic,
  cross: () => cross,
  diamond: () => diamond,
  ellipse: () => ellipse,
  path: () => path
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/marker/util.js
function normalize2(d, offset1, offset22) {
  let offsetX;
  let offsetY;
  if (typeof offset1 === "object") {
    offsetX = offset1.x;
    offsetY = offset1.y;
  } else {
    offsetX = offset1;
    offsetY = offset22;
  }
  const path2 = Path.parse(d);
  const bbox2 = path2.bbox();
  if (bbox2) {
    let ty = -bbox2.height / 2 - bbox2.y;
    let tx = -bbox2.width / 2 - bbox2.x;
    if (typeof offsetX === "number") {
      tx -= offsetX;
    }
    if (typeof offsetY === "number") {
      ty -= offsetY;
    }
    path2.translate(tx, ty);
  }
  return path2.serialize();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/marker/classic.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var block = (_a) => {
  var { size: size2, width: width2, height: height2, offset: offset3, open } = _a, attrs = __rest2(_a, ["size", "width", "height", "offset", "open"]);
  return createClassicMarker({ size: size2, width: width2, height: height2, offset: offset3 }, open === true, true, void 0, attrs);
};
var classic = (_a) => {
  var { size: size2, width: width2, height: height2, offset: offset3, factor } = _a, attrs = __rest2(_a, ["size", "width", "height", "offset", "factor"]);
  return createClassicMarker({ size: size2, width: width2, height: height2, offset: offset3 }, false, false, factor, attrs);
};
function createClassicMarker(options, open, full, factor = 3 / 4, attrs = {}) {
  const size2 = options.size || 10;
  const width2 = options.width || size2;
  const height2 = options.height || size2;
  const path2 = new Path();
  const localAttrs = {};
  if (open) {
    path2.moveTo(width2, 0).lineTo(0, height2 / 2).lineTo(width2, height2);
    localAttrs.fill = "none";
  } else {
    path2.moveTo(0, height2 / 2);
    path2.lineTo(width2, 0);
    if (!full) {
      const f = number_exports.clamp(factor, 0, 1);
      path2.lineTo(width2 * f, height2 / 2);
    }
    path2.lineTo(width2, height2);
    path2.close();
  }
  return Object.assign(Object.assign(Object.assign({}, localAttrs), attrs), { tagName: "path", d: normalize2(path2.serialize(), {
    x: options.offset != null ? options.offset : -width2 / 2
  }) });
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/marker/diamond.js
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var diamond = (_a) => {
  var { size: size2, width: width2, height: height2, offset: offset3 } = _a, attrs = __rest3(_a, ["size", "width", "height", "offset"]);
  const s = size2 || 10;
  const w = width2 || s;
  const h = height2 || s;
  const path2 = new Path();
  path2.moveTo(0, h / 2).lineTo(w / 2, 0).lineTo(w, h / 2).lineTo(w / 2, h).close();
  return Object.assign(Object.assign({}, attrs), { tagName: "path", d: normalize2(path2.serialize(), offset3 == null ? -w / 2 : offset3) });
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/marker/path.js
var __rest4 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var path = (_a) => {
  var { d, offsetX, offsetY } = _a, attrs = __rest4(_a, ["d", "offsetX", "offsetY"]);
  return Object.assign(Object.assign({}, attrs), { tagName: "path", d: normalize2(d, offsetX, offsetY) });
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/marker/cross.js
var __rest5 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var cross = (_a) => {
  var { size: size2, width: width2, height: height2, offset: offset3 } = _a, attrs = __rest5(_a, ["size", "width", "height", "offset"]);
  const s = size2 || 10;
  const w = width2 || s;
  const h = height2 || s;
  const path2 = new Path();
  path2.moveTo(0, 0).lineTo(w, h).moveTo(0, h).lineTo(w, 0);
  return Object.assign(Object.assign({}, attrs), { tagName: "path", fill: "none", d: normalize2(path2.serialize(), offset3 || -w / 2) });
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/marker/async.js
var __rest6 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var async = (_a) => {
  var { width: width2, height: height2, offset: offset3, open, flip: flip2 } = _a, attrs = __rest6(_a, ["width", "height", "offset", "open", "flip"]);
  let h = height2 || 6;
  const w = width2 || 10;
  const opened = open === true;
  const fliped = flip2 === true;
  const result2 = Object.assign(Object.assign({}, attrs), { tagName: "path" });
  if (fliped) {
    h = -h;
  }
  const path2 = new Path();
  path2.moveTo(0, h).lineTo(w, 0);
  if (!opened) {
    path2.lineTo(w, h);
    path2.close();
  } else {
    result2.fill = "none";
  }
  result2.d = normalize2(path2.serialize(), {
    x: offset3 || -w / 2,
    y: h / 2
  });
  return result2;
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/marker/circle.js
var __rest7 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var circle = (_a) => {
  var { r } = _a, attrs = __rest7(_a, ["r"]);
  const radius = r || 5;
  return Object.assign(Object.assign({ cx: radius }, attrs), { tagName: "circle", r: radius });
};
var circlePlus = (_a) => {
  var { r } = _a, attrs = __rest7(_a, ["r"]);
  const radius = r || 5;
  const path2 = new Path();
  path2.moveTo(radius, 0).lineTo(radius, radius * 2);
  path2.moveTo(0, radius).lineTo(radius * 2, radius);
  return {
    children: [
      Object.assign(Object.assign({}, circle({ r: radius })), { fill: "none" }),
      Object.assign(Object.assign({}, attrs), { tagName: "path", d: normalize2(path2.serialize(), -radius) })
    ]
  };
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/marker/ellipse.js
var __rest8 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var ellipse = (_a) => {
  var { rx, ry } = _a, attrs = __rest8(_a, ["rx", "ry"]);
  const radiusX = rx || 5;
  const radiusy = ry || 5;
  return Object.assign(Object.assign({ cx: radiusX }, attrs), { tagName: "ellipse", rx: radiusX, ry: radiusy });
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/marker/index.js
var Marker;
(function(Marker2) {
  Marker2.presets = main_exports7;
  Marker2.registry = Registry.create({
    type: "marker"
  });
  Marker2.registry.register(Marker2.presets, true);
})(Marker || (Marker = {}));
(function(Marker2) {
  Marker2.normalize = normalize2;
})(Marker || (Marker = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/marker.js
var __rest9 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function qualify(value) {
  return typeof value === "string" || object_exports.isPlainObject(value);
}
var sourceMarker = {
  qualify,
  set(marker, { view, attrs }) {
    return createMarker("marker-start", marker, view, attrs);
  }
};
var targetMarker = {
  qualify,
  set(marker, { view, attrs }) {
    return createMarker("marker-end", marker, view, attrs, {
      transform: "rotate(180)"
    });
  }
};
var vertexMarker = {
  qualify,
  set(marker, { view, attrs }) {
    return createMarker("marker-mid", marker, view, attrs);
  }
};
function createMarker(type, marker, view, attrs, manual2 = {}) {
  const def = typeof marker === "string" ? { name: marker } : marker;
  const { name, args } = def, others = __rest9(def, ["name", "args"]);
  let preset = others;
  if (name && typeof name === "string") {
    const fn = Marker.registry.get(name);
    if (fn) {
      preset = fn(Object.assign(Object.assign({}, others), args));
    } else {
      return Marker.registry.onNotFound(name);
    }
  }
  const options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual2), preset);
  return {
    [type]: `url(#${view.graph.defineMarker(options)})`
  };
}
function normalizeAttr(attr2, type) {
  const result2 = {};
  const stroke3 = attr2.stroke;
  if (typeof stroke3 === "string") {
    result2.stroke = stroke3;
    result2.fill = stroke3;
  }
  let strokeOpacity = attr2.strokeOpacity;
  if (strokeOpacity == null) {
    strokeOpacity = attr2["stroke-opacity"];
  }
  if (strokeOpacity == null) {
    strokeOpacity = attr2.opacity;
  }
  if (strokeOpacity != null) {
    result2["stroke-opacity"] = strokeOpacity;
    result2["fill-opacity"] = strokeOpacity;
  }
  if (type !== "marker-mid") {
    const strokeWidth = parseFloat(attr2.strokeWidth || attr2["stroke-width"]);
    if (Number.isFinite(strokeWidth) && strokeWidth > 1) {
      const offset3 = Math.ceil(strokeWidth / 2);
      result2.refX = type === "marker-start" ? offset3 : -offset3;
    }
  }
  return result2;
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/connection.js
var isEdgeView = (val, { view }) => {
  return view.cell.isEdge();
};
var connection = {
  qualify: isEdgeView,
  set(val, args) {
    var _a, _b, _c, _d;
    const view = args.view;
    const reverse2 = val.reverse || false;
    const stubs = val.stubs || 0;
    let d;
    if (Number.isFinite(stubs) && stubs !== 0) {
      if (!reverse2) {
        let offset3;
        if (stubs < 0) {
          const len = view.getConnectionLength() || 0;
          offset3 = (len + stubs) / 2;
        } else {
          offset3 = stubs;
        }
        const path2 = view.getConnection();
        if (path2) {
          const sourceParts = path2.divideAtLength(offset3);
          const targetParts = path2.divideAtLength(-offset3);
          if (sourceParts && targetParts) {
            d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;
          }
        }
      } else {
        let offset3;
        let length2;
        const len = view.getConnectionLength() || 0;
        if (stubs < 0) {
          offset3 = (len + stubs) / 2;
          length2 = -stubs;
        } else {
          offset3 = stubs;
          length2 = len - stubs * 2;
        }
        const path2 = view.getConnection();
        d = (_d = (_c = (_b = (_a = path2 === null || path2 === void 0 ? void 0 : path2.divideAtLength(offset3)) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.divideAtLength(length2)) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.serialize();
      }
    }
    return { d: d || view.getConnectionPathData() };
  }
};
var atConnectionLengthKeepGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper("getTangentAtLength", { rotate: true })
};
var atConnectionLengthIgnoreGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper("getTangentAtLength", { rotate: false })
};
var atConnectionRatioKeepGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper("getTangentAtRatio", { rotate: true })
};
var atConnectionRatioIgnoreGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper("getTangentAtRatio", { rotate: false })
};
var atConnectionLength = atConnectionLengthKeepGradient;
var atConnectionRatio = atConnectionRatioKeepGradient;
function atConnectionWrapper(method2, options) {
  const zeroVector = { x: 1, y: 0 };
  return (value, args) => {
    let p;
    let angle;
    const view = args.view;
    const tangent = view[method2](Number(value));
    if (tangent) {
      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
      p = tangent.start;
    } else {
      p = view.path.start;
      angle = 0;
    }
    if (angle === 0) {
      return { transform: `translate(${p.x},${p.y}')` };
    }
    return {
      transform: `translate(${p.x},${p.y}') rotate(${angle})`
    };
  };
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/attr/index.js
var Attr;
(function(Attr2) {
  function isValidDefinition(def, val, options) {
    if (def != null) {
      if (typeof def === "string") {
        return true;
      }
      if (typeof def.qualify !== "function" || main_exports.call(def.qualify, this, val, options)) {
        return true;
      }
    }
    return false;
  }
  Attr2.isValidDefinition = isValidDefinition;
})(Attr || (Attr = {}));
(function(Attr2) {
  Attr2.presets = Object.assign(Object.assign({}, raw), main_exports8);
  Attr2.registry = Registry.create({
    type: "attribute definition"
  });
  Attr2.registry.register(Attr2.presets, true);
})(Attr || (Attr = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/highlighter/main.js
var main_exports9 = {};
__export(main_exports9, {
  className: () => className,
  opacity: () => opacity,
  stroke: () => stroke2
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/config/index.js
var Config = {
  prefixCls: "x6",
  autoInsertCSS: true,
  useCSSSelector: true,
  prefix(suffix) {
    return `${Config.prefixCls}-${suffix}`;
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/highlighter/class.js
var defaultClassName = Config.prefix("highlighted");
var className = {
  highlight(cellView, magnet, options) {
    const cls = options && options.className || defaultClassName;
    main_exports3.addClass(magnet, cls);
  },
  unhighlight(cellView, magnet, options) {
    const cls = options && options.className || defaultClassName;
    main_exports3.removeClass(magnet, cls);
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/highlighter/opacity.js
var className2 = Config.prefix("highlight-opacity");
var opacity = {
  highlight(cellView, magnet) {
    main_exports3.addClass(magnet, className2);
  },
  unhighlight(cellView, magnetEl) {
    main_exports3.removeClass(magnetEl, className2);
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/util/index.js
var Util2;
(function(Util3) {
  Util3.normalizeMarker = normalize2;
  function transformPoint(point, matrix) {
    const ret = main_exports3.createSVGPoint(point.x, point.y).matrixTransform(matrix);
    return new Point(ret.x, ret.y);
  }
  Util3.transformPoint = transformPoint;
  function transformLine(line2, matrix) {
    return new Line(transformPoint(line2.start, matrix), transformPoint(line2.end, matrix));
  }
  Util3.transformLine = transformLine;
  function transformPolyline(polyline, matrix) {
    let points = polyline instanceof Polyline ? polyline.points : polyline;
    if (!Array.isArray(points)) {
      points = [];
    }
    return new Polyline(points.map((p) => transformPoint(p, matrix)));
  }
  Util3.transformPolyline = transformPolyline;
  function transformRectangle(rect2, matrix) {
    const svgDocument = main_exports3.createSvgElement("svg");
    const p = svgDocument.createSVGPoint();
    p.x = rect2.x;
    p.y = rect2.y;
    const corner1 = p.matrixTransform(matrix);
    p.x = rect2.x + rect2.width;
    p.y = rect2.y;
    const corner2 = p.matrixTransform(matrix);
    p.x = rect2.x + rect2.width;
    p.y = rect2.y + rect2.height;
    const corner3 = p.matrixTransform(matrix);
    p.x = rect2.x;
    p.y = rect2.y + rect2.height;
    const corner4 = p.matrixTransform(matrix);
    const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);
    const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);
    const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);
    const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);
    return new Rectangle(minX, minY, maxX - minX, maxY - minY);
  }
  Util3.transformRectangle = transformRectangle;
  function bbox2(elem, withoutTransformations, target) {
    let box;
    const ownerSVGElement = elem.ownerSVGElement;
    if (!ownerSVGElement) {
      return new Rectangle(0, 0, 0, 0);
    }
    try {
      box = elem.getBBox();
    } catch (e) {
      box = {
        x: elem.clientLeft,
        y: elem.clientTop,
        width: elem.clientWidth,
        height: elem.clientHeight
      };
    }
    if (withoutTransformations) {
      return Rectangle.create(box);
    }
    const matrix = main_exports3.getTransformToElement(elem, target || ownerSVGElement);
    return transformRectangle(box, matrix);
  }
  Util3.bbox = bbox2;
  function getBBox(elem, options = {}) {
    let outputBBox;
    const ownerSVGElement = elem.ownerSVGElement;
    if (!ownerSVGElement || !main_exports3.isSVGGraphicsElement(elem)) {
      if (main_exports3.isHTMLElement(elem)) {
        const { left: left4, top: top4, width: width2, height: height2 } = getBoundingOffsetRect(elem);
        return new Rectangle(left4, top4, width2, height2);
      }
      return new Rectangle(0, 0, 0, 0);
    }
    let target = options.target;
    const recursive = options.recursive;
    if (!recursive) {
      try {
        outputBBox = elem.getBBox();
      } catch (e) {
        outputBBox = {
          x: elem.clientLeft,
          y: elem.clientTop,
          width: elem.clientWidth,
          height: elem.clientHeight
        };
      }
      if (!target) {
        return Rectangle.create(outputBBox);
      }
      const matrix = main_exports3.getTransformToElement(elem, target);
      return transformRectangle(outputBBox, matrix);
    }
    {
      const children2 = elem.childNodes;
      const n = children2.length;
      if (n === 0) {
        return getBBox(elem, {
          target
        });
      }
      if (!target) {
        target = elem;
      }
      for (let i = 0; i < n; i += 1) {
        const child = children2[i];
        let childBBox;
        if (child.childNodes.length === 0) {
          childBBox = getBBox(child, {
            target
          });
        } else {
          childBBox = getBBox(child, {
            target,
            recursive: true
          });
        }
        if (!outputBBox) {
          outputBBox = childBBox;
        } else {
          outputBBox = outputBBox.union(childBBox);
        }
      }
      return outputBBox;
    }
  }
  Util3.getBBox = getBBox;
  function getBoundingOffsetRect(elem) {
    let left4 = 0;
    let top4 = 0;
    let width2 = 0;
    let height2 = 0;
    if (elem) {
      let current = elem;
      while (current) {
        left4 += current.offsetLeft;
        top4 += current.offsetTop;
        current = current.offsetParent;
        if (current) {
          left4 += parseInt(main_exports3.getComputedStyle(current, "borderLeft"), 10);
          top4 += parseInt(main_exports3.getComputedStyle(current, "borderTop"), 10);
        }
      }
      width2 = elem.offsetWidth;
      height2 = elem.offsetHeight;
    }
    return {
      left: left4,
      top: top4,
      width: width2,
      height: height2
    };
  }
  Util3.getBoundingOffsetRect = getBoundingOffsetRect;
  function toGeometryShape(elem) {
    const attr2 = (name) => {
      const s = elem.getAttribute(name);
      const v = s ? parseFloat(s) : 0;
      return Number.isNaN(v) ? 0 : v;
    };
    switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {
      case "rect":
        return new Rectangle(attr2("x"), attr2("y"), attr2("width"), attr2("height"));
      case "circle":
        return new Ellipse(attr2("cx"), attr2("cy"), attr2("r"), attr2("r"));
      case "ellipse":
        return new Ellipse(attr2("cx"), attr2("cy"), attr2("rx"), attr2("ry"));
      case "polyline": {
        const points = main_exports3.getPointsFromSvgElement(elem);
        return new Polyline(points);
      }
      case "polygon": {
        const points = main_exports3.getPointsFromSvgElement(elem);
        if (points.length > 1) {
          points.push(points[0]);
        }
        return new Polyline(points);
      }
      case "path": {
        let d = elem.getAttribute("d");
        if (!Path.isValid(d)) {
          d = Path.normalize(d);
        }
        return Path.parse(d);
      }
      case "line": {
        return new Line(attr2("x1"), attr2("y1"), attr2("x2"), attr2("y2"));
      }
      default:
        break;
    }
    return getBBox(elem);
  }
  Util3.toGeometryShape = toGeometryShape;
  function translateAndAutoOrient(elem, position2, reference, target) {
    const pos = Point.create(position2);
    const ref2 = Point.create(reference);
    if (!target) {
      const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
      target = svg;
    }
    const s = main_exports3.scale(elem);
    elem.setAttribute("transform", "");
    const bbox3 = getBBox(elem, {
      target
    }).scale(s.sx, s.sy);
    const translateToOrigin = main_exports3.createSVGTransform();
    translateToOrigin.setTranslate(-bbox3.x - bbox3.width / 2, -bbox3.y - bbox3.height / 2);
    const rotateAroundOrigin = main_exports3.createSVGTransform();
    const angle = pos.angleBetween(ref2, pos.clone().translate(1, 0));
    if (angle)
      rotateAroundOrigin.setRotate(angle, 0, 0);
    const translateFromOrigin = main_exports3.createSVGTransform();
    const finalPosition = pos.clone().move(ref2, bbox3.width / 2);
    translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y);
    const ctm = main_exports3.getTransformToElement(elem, target);
    const transform3 = main_exports3.createSVGTransform();
    transform3.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));
    elem.setAttribute("transform", main_exports3.matrixToTransformString(transform3.matrix));
  }
  Util3.translateAndAutoOrient = translateAndAutoOrient;
  function findShapeNode2(magnet) {
    if (magnet == null) {
      return null;
    }
    let node = magnet;
    do {
      let tagName2 = node.tagName;
      if (typeof tagName2 !== "string")
        return null;
      tagName2 = tagName2.toUpperCase();
      if (main_exports3.hasClass(node, "x6-port")) {
        node = node.nextElementSibling;
      } else if (tagName2 === "G") {
        node = node.firstElementChild;
      } else if (tagName2 === "TITLE") {
        node = node.nextElementSibling;
      } else
        break;
    } while (node);
    return node;
  }
  Util3.findShapeNode = findShapeNode2;
  function getBBoxV2(elem) {
    const node = findShapeNode2(elem);
    if (!main_exports3.isSVGGraphicsElement(node)) {
      if (main_exports3.isHTMLElement(elem)) {
        const { left: left4, top: top4, width: width2, height: height2 } = getBoundingOffsetRect(elem);
        return new Rectangle(left4, top4, width2, height2);
      }
      return new Rectangle(0, 0, 0, 0);
    }
    const shape = toGeometryShape(node);
    const bbox3 = shape.bbox() || Rectangle.create();
    return bbox3;
  }
  Util3.getBBoxV2 = getBBoxV2;
})(Util2 || (Util2 = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/highlighter/stroke.js
var defaultOptions = {
  padding: 3,
  rx: 0,
  ry: 0,
  attrs: {
    "stroke-width": 3,
    stroke: "#FEB663"
  }
};
var stroke2 = {
  highlight(cellView, magnet, options) {
    const id = Private2.getHighlighterId(magnet, options);
    if (Private2.hasCache(id)) {
      return;
    }
    options = object_exports.defaultsDeep({}, options, defaultOptions);
    const magnetVel = Vector.create(magnet);
    let pathData;
    let magnetBBox;
    try {
      pathData = magnetVel.toPathData();
    } catch (error) {
      magnetBBox = Util2.bbox(magnetVel.node, true);
      pathData = main_exports3.rectToPathData(Object.assign(Object.assign({}, options), magnetBBox));
    }
    const path2 = main_exports3.createSvgElement("path");
    main_exports3.attr(path2, Object.assign({ d: pathData, "pointer-events": "none", "vector-effect": "non-scaling-stroke", fill: "none" }, options.attrs ? main_exports3.kebablizeAttrs(options.attrs) : null));
    if (cellView.isEdgeElement(magnet)) {
      main_exports3.attr(path2, "d", cellView.getConnectionPathData());
    } else {
      let highlightMatrix = magnetVel.getTransformToElement(cellView.container);
      const padding = options.padding;
      if (padding) {
        if (magnetBBox == null) {
          magnetBBox = Util2.bbox(magnetVel.node, true);
        }
        const cx = magnetBBox.x + magnetBBox.width / 2;
        const cy = magnetBBox.y + magnetBBox.height / 2;
        magnetBBox = Util2.transformRectangle(magnetBBox, highlightMatrix);
        const width2 = Math.max(magnetBBox.width, 1);
        const height2 = Math.max(magnetBBox.height, 1);
        const sx = (width2 + padding) / width2;
        const sy = (height2 + padding) / height2;
        const paddingMatrix = main_exports3.createSVGMatrix({
          a: sx,
          b: 0,
          c: 0,
          d: sy,
          e: cx - sx * cx,
          f: cy - sy * cy
        });
        highlightMatrix = highlightMatrix.multiply(paddingMatrix);
      }
      main_exports3.transform(path2, highlightMatrix);
    }
    main_exports3.addClass(path2, Config.prefix("highlight-stroke"));
    const cell = cellView.cell;
    const removeHandler = () => Private2.removeHighlighter(id);
    cell.on("removed", removeHandler);
    if (cell.model) {
      cell.model.on("reseted", removeHandler);
    }
    cellView.container.appendChild(path2);
    Private2.setCache(id, path2);
  },
  unhighlight(cellView, magnet, opt) {
    Private2.removeHighlighter(Private2.getHighlighterId(magnet, opt));
  }
};
var Private2;
(function(Private5) {
  function getHighlighterId(magnet, options) {
    main_exports3.ensureId(magnet);
    return magnet.id + JSON.stringify(options);
  }
  Private5.getHighlighterId = getHighlighterId;
  const cache = {};
  function setCache(id, elem) {
    cache[id] = elem;
  }
  Private5.setCache = setCache;
  function hasCache(id) {
    return cache[id] != null;
  }
  Private5.hasCache = hasCache;
  function removeHighlighter(id) {
    const elem = cache[id];
    if (elem) {
      main_exports3.remove(elem);
      delete cache[id];
    }
  }
  Private5.removeHighlighter = removeHighlighter;
})(Private2 || (Private2 = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/highlighter/index.js
var Highlighter;
(function(Highlighter2) {
  function check(name, highlighter) {
    if (typeof highlighter.highlight !== "function") {
      throw new Error(`Highlighter '${name}' is missing required \`highlight()\` method`);
    }
    if (typeof highlighter.unhighlight !== "function") {
      throw new Error(`Highlighter '${name}' is missing required \`unhighlight()\` method`);
    }
  }
  Highlighter2.check = check;
})(Highlighter || (Highlighter = {}));
(function(Highlighter2) {
  Highlighter2.presets = main_exports9;
  Highlighter2.registry = Registry.create({
    type: "highlighter"
  });
  Highlighter2.registry.register(Highlighter2.presets, true);
})(Highlighter || (Highlighter = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-layout/main.js
var main_exports10 = {};
__export(main_exports10, {
  absolute: () => absolute,
  bottom: () => bottom,
  ellipse: () => ellipse2,
  ellipseSpread: () => ellipseSpread,
  left: () => left,
  line: () => line,
  right: () => right,
  top: () => top
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-layout/util.js
function normalizePoint(bbox2, args = {}) {
  return new Point(number_exports.normalizePercentage(args.x, bbox2.width), number_exports.normalizePercentage(args.y, bbox2.height));
}
function toResult(point, angle, rawArgs) {
  return Object.assign({ angle, position: point.toJSON() }, rawArgs);
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-layout/absolute.js
var absolute = (portsPositionArgs, elemBBox) => {
  return portsPositionArgs.map(({ x, y, angle }) => toResult(normalizePoint(elemBBox, { x, y }), angle || 0));
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-layout/ellipse.js
var ellipse2 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  const startAngle = groupPositionArgs.start || 0;
  const stepAngle = groupPositionArgs.step || 20;
  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index2, count) => (index2 + 0.5 - count / 2) * stepAngle);
};
var ellipseSpread = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  const startAngle = groupPositionArgs.start || 0;
  const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;
  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index2) => {
    return index2 * stepAngle;
  });
};
function ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {
  const center2 = elemBBox.getCenter();
  const start = elemBBox.getTopCenter();
  const ratio2 = elemBBox.width / elemBBox.height;
  const ellipse3 = Ellipse.fromRect(elemBBox);
  const count = portsPositionArgs.length;
  return portsPositionArgs.map((item, index2) => {
    const angle = startAngle + stepFn(index2, count);
    const p = start.clone().rotate(-angle, center2).scale(ratio2, 1, center2);
    const theta = item.compensateRotate ? -ellipse3.tangentTheta(p) : 0;
    if (item.dx || item.dy) {
      p.translate(item.dx || 0, item.dy || 0);
    }
    if (item.dr) {
      p.move(center2, item.dr);
    }
    return toResult(p.round(), theta, item);
  });
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-layout/line.js
var __rest10 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var line = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  const start = normalizePoint(elemBBox, groupPositionArgs.start || elemBBox.getOrigin());
  const end = normalizePoint(elemBBox, groupPositionArgs.end || elemBBox.getCorner());
  return lineLayout(portsPositionArgs, start, end, groupPositionArgs);
};
var left = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getBottomLeft(), groupPositionArgs);
};
var right = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getTopRight(), elemBBox.getBottomRight(), groupPositionArgs);
};
var top = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getTopRight(), groupPositionArgs);
};
var bottom = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getBottomLeft(), elemBBox.getBottomRight(), groupPositionArgs);
};
function lineLayout(portsPositionArgs, p1, p2, groupPositionArgs) {
  const line2 = new Line(p1, p2);
  const length2 = portsPositionArgs.length;
  return portsPositionArgs.map((_a, index2) => {
    var { strict } = _a, offset3 = __rest10(_a, ["strict"]);
    const ratio2 = strict || groupPositionArgs.strict ? (index2 + 1) / (length2 + 1) : (index2 + 0.5) / length2;
    const p = line2.pointAt(ratio2);
    if (offset3.dx || offset3.dy) {
      p.translate(offset3.dx || 0, offset3.dy || 0);
    }
    return toResult(p.round(), 0, offset3);
  });
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-layout/index.js
var PortLayout;
(function(PortLayout2) {
  PortLayout2.presets = main_exports10;
  PortLayout2.registry = Registry.create({
    type: "port layout"
  });
  PortLayout2.registry.register(PortLayout2.presets, true);
})(PortLayout || (PortLayout = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-label-layout/main.js
var main_exports11 = {};
__export(main_exports11, {
  bottom: () => bottom2,
  inside: () => inside,
  insideOriented: () => insideOriented,
  left: () => left2,
  manual: () => manual,
  outside: () => outside,
  outsideOriented: () => outsideOriented,
  radial: () => radial,
  radialOriented: () => radialOriented,
  right: () => right2,
  top: () => top2
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-label-layout/util.js
var defaults2 = {
  position: { x: 0, y: 0 },
  angle: 0,
  attrs: {
    ".": {
      y: "0",
      "text-anchor": "start"
    }
  }
};
function toResult2(preset, args) {
  const { x, y, angle, attrs } = args || {};
  return object_exports.defaultsDeep({}, { angle, attrs, position: { x, y } }, preset, defaults2);
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-label-layout/side.js
var manual = (portPosition, elemBBox, args) => toResult2({ position: elemBBox.getTopLeft() }, args);
var left2 = (portPosition, elemBBox, args) => toResult2({
  position: { x: -15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "end" } }
}, args);
var right2 = (portPosition, elemBBox, args) => toResult2({
  position: { x: 15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "start" } }
}, args);
var top2 = (portPosition, elemBBox, args) => toResult2({
  position: { x: 0, y: -15 },
  attrs: { ".": { "text-anchor": "middle" } }
}, args);
var bottom2 = (portPosition, elemBBox, args) => toResult2({
  position: { x: 0, y: 15 },
  attrs: { ".": { y: ".6em", "text-anchor": "middle" } }
}, args);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-label-layout/inout.js
var outside = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, false, args);
var outsideOriented = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, true, args);
var inside = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, false, args);
var insideOriented = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, true, args);
function outsideLayout(portPosition, elemBBox, autoOrient, args) {
  const offset3 = args.offset != null ? args.offset : 15;
  const angle = elemBBox.getCenter().theta(portPosition);
  const bboxAngles = getBBoxAngles(elemBBox);
  let y;
  let tx;
  let ty;
  let textAnchor;
  let orientAngle = 0;
  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
    y = ".3em";
    tx = offset3;
    ty = 0;
    textAnchor = "start";
  } else if (angle < bboxAngles[0]) {
    y = "0";
    tx = 0;
    ty = -offset3;
    if (autoOrient) {
      orientAngle = -90;
      textAnchor = "start";
    } else {
      textAnchor = "middle";
    }
  } else if (angle < bboxAngles[3]) {
    y = ".3em";
    tx = -offset3;
    ty = 0;
    textAnchor = "end";
  } else {
    y = ".6em";
    tx = 0;
    ty = offset3;
    if (autoOrient) {
      orientAngle = 90;
      textAnchor = "start";
    } else {
      textAnchor = "middle";
    }
  }
  return toResult2({
    position: {
      x: Math.round(tx),
      y: Math.round(ty)
    },
    angle: orientAngle,
    attrs: {
      ".": {
        y,
        "text-anchor": textAnchor
      }
    }
  }, args);
}
function insideLayout(portPosition, elemBBox, autoOrient, args) {
  const offset3 = args.offset != null ? args.offset : 15;
  const angle = elemBBox.getCenter().theta(portPosition);
  const bboxAngles = getBBoxAngles(elemBBox);
  let y;
  let tx;
  let ty;
  let textAnchor;
  let orientAngle = 0;
  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
    y = ".3em";
    tx = -offset3;
    ty = 0;
    textAnchor = "end";
  } else if (angle < bboxAngles[0]) {
    y = ".6em";
    tx = 0;
    ty = offset3;
    if (autoOrient) {
      orientAngle = 90;
      textAnchor = "start";
    } else {
      textAnchor = "middle";
    }
  } else if (angle < bboxAngles[3]) {
    y = ".3em";
    tx = offset3;
    ty = 0;
    textAnchor = "start";
  } else {
    y = "0em";
    tx = 0;
    ty = -offset3;
    if (autoOrient) {
      orientAngle = -90;
      textAnchor = "start";
    } else {
      textAnchor = "middle";
    }
  }
  return toResult2({
    position: {
      x: Math.round(tx),
      y: Math.round(ty)
    },
    angle: orientAngle,
    attrs: {
      ".": {
        y,
        "text-anchor": textAnchor
      }
    }
  }, args);
}
function getBBoxAngles(elemBBox) {
  const center2 = elemBBox.getCenter();
  const tl = center2.theta(elemBBox.getTopLeft());
  const bl = center2.theta(elemBBox.getBottomLeft());
  const br = center2.theta(elemBBox.getBottomRight());
  const tr = center2.theta(elemBBox.getTopRight());
  return [tl, tr, br, bl];
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-label-layout/radial.js
var radial = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), false, args);
var radialOriented = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), true, args);
function radialLayout(portCenterOffset, autoOrient, args) {
  const offset3 = args.offset != null ? args.offset : 20;
  const origin = new Point(0, 0);
  const angle = -portCenterOffset.theta(origin);
  const pos = portCenterOffset.clone().move(origin, offset3).diff(portCenterOffset).round();
  let y = ".3em";
  let textAnchor;
  let orientAngle = angle;
  if ((angle + 90) % 180 === 0) {
    textAnchor = autoOrient ? "end" : "middle";
    if (!autoOrient && angle === -270) {
      y = "0em";
    }
  } else if (angle > -270 && angle < -90) {
    textAnchor = "start";
    orientAngle = angle - 180;
  } else {
    textAnchor = "end";
  }
  return toResult2({
    position: pos.round().toJSON(),
    angle: autoOrient ? orientAngle : 0,
    attrs: {
      ".": {
        y,
        "text-anchor": textAnchor
      }
    }
  }, args);
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/port-label-layout/index.js
var PortLabelLayout;
(function(PortLabelLayout2) {
  PortLabelLayout2.presets = main_exports11;
  PortLabelLayout2.registry = Registry.create({
    type: "port label layout"
  });
  PortLabelLayout2.registry.register(PortLabelLayout2.presets, true);
})(PortLabelLayout || (PortLabelLayout = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/view/view.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var View = class _View extends Basecoat {
  get priority() {
    return 2;
  }
  /** If need remove `this.container` DOM */
  get disposeContainer() {
    return true;
  }
  constructor() {
    super();
    this.cid = Private3.uniqueId();
    _View.views[this.cid] = this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(flag, options) {
    return 0;
  }
  empty(elem = this.container) {
    main_exports3.empty(elem);
    return this;
  }
  unmount(elem = this.container) {
    main_exports3.remove(elem);
    return this;
  }
  remove(elem = this.container) {
    if (elem === this.container) {
      this.removeEventListeners(document);
      this.onRemove();
      delete _View.views[this.cid];
      if (this.disposeContainer) {
        this.unmount(elem);
      }
    } else {
      this.unmount(elem);
    }
    return this;
  }
  onRemove() {
  }
  setClass(className3, elem = this.container) {
    elem.classList.value = Array.isArray(className3) ? className3.join(" ") : className3;
  }
  addClass(className3, elem = this.container) {
    main_exports3.addClass(elem, Array.isArray(className3) ? className3.join(" ") : className3);
    return this;
  }
  removeClass(className3, elem = this.container) {
    main_exports3.removeClass(elem, Array.isArray(className3) ? className3.join(" ") : className3);
    return this;
  }
  setStyle(style2, elem = this.container) {
    main_exports3.css(elem, style2);
    return this;
  }
  setAttrs(attrs, elem = this.container) {
    if (attrs != null && elem != null) {
      main_exports3.attr(elem, attrs);
    }
    return this;
  }
  /**
   * Returns the value of the specified attribute of `node`.
   *
   * If the node does not set a value for attribute, start recursing up
   * the DOM tree from node to lookup for attribute at the ancestors of
   * node. If the recursion reaches CellView's root node and attribute
   * is not found even there, return `null`.
   */
  findAttr(attrName, elem = this.container) {
    let current = elem;
    while (current && current.nodeType === 1) {
      const value = current.getAttribute(attrName);
      if (value != null) {
        return value;
      }
      if (current === this.container) {
        return null;
      }
      current = current.parentNode;
    }
    return null;
  }
  find(selector, rootElem = this.container, selectors = this.selectors) {
    return _View.find(selector, rootElem, selectors).elems;
  }
  findOne(selector, rootElem = this.container, selectors = this.selectors) {
    const nodes = this.find(selector, rootElem, selectors);
    return nodes.length > 0 ? nodes[0] : null;
  }
  findByAttr(attrName, elem = this.container) {
    let node = elem;
    while (node && node.getAttribute) {
      const val = node.getAttribute(attrName);
      if ((val != null || node === this.container) && val !== "false") {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  }
  getSelector(elem, prevSelector) {
    let selector;
    if (elem === this.container) {
      if (typeof prevSelector === "string") {
        selector = `> ${prevSelector}`;
      }
      return selector;
    }
    if (elem) {
      const nth2 = main_exports3.index(elem) + 1;
      selector = `${elem.tagName.toLowerCase()}:nth-child(${nth2})`;
      if (prevSelector) {
        selector += ` > ${prevSelector}`;
      }
      selector = this.getSelector(elem.parentNode, selector);
    }
    return selector;
  }
  prefixClassName(className3) {
    return Config.prefix(className3);
  }
  delegateEvents(events, append2) {
    if (events == null) {
      return this;
    }
    if (!append2) {
      this.undelegateEvents();
    }
    const splitter = /^(\S+)\s*(.*)$/;
    Object.keys(events).forEach((key) => {
      const match = key.match(splitter);
      if (match == null) {
        return;
      }
      const method2 = this.getEventHandler(events[key]);
      if (typeof method2 === "function") {
        this.delegateEvent(match[1], match[2], method2);
      }
    });
    return this;
  }
  undelegateEvents() {
    main_exports3.Event.off(this.container, this.getEventNamespace());
    return this;
  }
  delegateDocumentEvents(events, data2) {
    this.addEventListeners(document, events, data2);
    return this;
  }
  undelegateDocumentEvents() {
    this.removeEventListeners(document);
    return this;
  }
  delegateEvent(eventName, selector, listener) {
    main_exports3.Event.on(this.container, eventName + this.getEventNamespace(), selector, listener);
    return this;
  }
  undelegateEvent(eventName, selector, listener) {
    const name = eventName + this.getEventNamespace();
    if (selector == null) {
      main_exports3.Event.off(this.container, name);
    } else if (typeof selector === "string") {
      main_exports3.Event.off(this.container, name, selector, listener);
    } else {
      main_exports3.Event.off(this.container, name, selector);
    }
    return this;
  }
  addEventListeners(elem, events, data2) {
    if (events == null) {
      return this;
    }
    const ns2 = this.getEventNamespace();
    Object.keys(events).forEach((eventName) => {
      const method2 = this.getEventHandler(events[eventName]);
      if (typeof method2 === "function") {
        main_exports3.Event.on(elem, eventName + ns2, data2, method2);
      }
    });
    return this;
  }
  removeEventListeners(elem) {
    if (elem != null) {
      main_exports3.Event.off(elem, this.getEventNamespace());
    }
    return this;
  }
  getEventNamespace() {
    return `.${Config.prefixCls}-event-${this.cid}`;
  }
  // eslint-disable-next-line
  getEventHandler(handler) {
    let method2;
    if (typeof handler === "string") {
      const fn = this[handler];
      if (typeof fn === "function") {
        method2 = (...args) => fn.call(this, ...args);
      }
    } else {
      method2 = (...args) => handler.call(this, ...args);
    }
    return method2;
  }
  getEventTarget(e, options = {}) {
    const { target, type, clientX = 0, clientY = 0 } = e;
    if (options.fromPoint || type === "touchmove" || type === "touchend") {
      return document.elementFromPoint(clientX, clientY);
    }
    return target;
  }
  stopPropagation(e) {
    this.setEventData(e, { propagationStopped: true });
    return this;
  }
  isPropagationStopped(e) {
    return this.getEventData(e).propagationStopped === true;
  }
  getEventData(e) {
    return this.eventData(e);
  }
  setEventData(e, data2) {
    return this.eventData(e, data2);
  }
  eventData(e, data2) {
    if (e == null) {
      throw new TypeError("Event object required");
    }
    let currentData = e.data;
    const key = `__${this.cid}__`;
    if (data2 == null) {
      if (currentData == null) {
        return {};
      }
      return currentData[key] || {};
    }
    if (currentData == null) {
      currentData = e.data = {};
    }
    if (currentData[key] == null) {
      currentData[key] = Object.assign({}, data2);
    } else {
      currentData[key] = Object.assign(Object.assign({}, currentData[key]), data2);
    }
    return currentData[key];
  }
  normalizeEvent(evt) {
    return _View.normalizeEvent(evt);
  }
  dispose() {
    this.remove();
  }
};
__decorate2([
  View.dispose()
], View.prototype, "dispose", null);
(function(View2) {
  function createElement2(tagName2, isSvgElement) {
    return isSvgElement ? main_exports3.createSvgElement(tagName2 || "g") : main_exports3.createElementNS(tagName2 || "div");
  }
  View2.createElement = createElement2;
  function find3(selector, rootElem, selectors) {
    if (!selector || selector === ".") {
      return { elems: [rootElem] };
    }
    if (selectors) {
      const nodes = selectors[selector];
      if (nodes) {
        return { elems: Array.isArray(nodes) ? nodes : [nodes] };
      }
    }
    if (Config.useCSSSelector) {
      const validSelector = selector.includes(">") ? `:scope ${selector}` : selector;
      return {
        isCSSSelector: true,
        // $(rootElem).find(selector).toArray() as Element[]
        elems: Array.prototype.slice.call(rootElem.querySelectorAll(validSelector))
      };
    }
    return { elems: [] };
  }
  View2.find = find3;
  function normalizeEvent(evt) {
    let normalizedEvent = evt;
    const originalEvent = evt.originalEvent;
    const touchEvt = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];
    if (touchEvt) {
      for (const key in evt) {
        if (touchEvt[key] === void 0) {
          touchEvt[key] = evt[key];
        }
      }
      normalizedEvent = touchEvt;
    }
    return normalizedEvent;
  }
  View2.normalizeEvent = normalizeEvent;
})(View || (View = {}));
(function(View2) {
  View2.views = {};
  function getView2(cid) {
    return View2.views[cid] || null;
  }
  View2.getView = getView2;
})(View || (View = {}));
var Private3;
(function(Private5) {
  let counter = 0;
  function uniqueId3() {
    const id = `v${counter}`;
    counter += 1;
    return id;
  }
  Private5.uniqueId = uniqueId3;
})(Private3 || (Private3 = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/view/cache.js
var Cache = class {
  constructor(view) {
    this.view = view;
    this.clean();
  }
  clean() {
    if (this.elemCache) {
      this.elemCache.dispose();
    }
    this.elemCache = new Dictionary();
    this.pathCache = {};
  }
  get(elem) {
    const cache = this.elemCache;
    if (!cache.has(elem)) {
      this.elemCache.set(elem, {});
    }
    return this.elemCache.get(elem);
  }
  getData(elem) {
    const meta = this.get(elem);
    if (!meta.data) {
      meta.data = {};
    }
    return meta.data;
  }
  getMatrix(elem) {
    const meta = this.get(elem);
    if (meta.matrix == null) {
      const target = this.view.container;
      meta.matrix = main_exports3.getTransformToParentElement(elem, target);
    }
    return main_exports3.createSVGMatrix(meta.matrix);
  }
  getShape(elem) {
    const meta = this.get(elem);
    if (meta.shape == null) {
      meta.shape = Util2.toGeometryShape(elem);
    }
    return meta.shape.clone();
  }
  getBoundingRect(elem) {
    const meta = this.get(elem);
    if (meta.boundingRect == null) {
      meta.boundingRect = Util2.getBBoxV2(elem);
    }
    return meta.boundingRect.clone();
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/view/markup.js
var Markup;
(function(Markup2) {
  function isJSONMarkup(markup) {
    return markup != null && !isStringMarkup(markup);
  }
  Markup2.isJSONMarkup = isJSONMarkup;
  function isStringMarkup(markup) {
    return markup != null && typeof markup === "string";
  }
  Markup2.isStringMarkup = isStringMarkup;
  function clone2(markup) {
    return markup == null || isStringMarkup(markup) ? markup : object_exports.cloneDeep(markup);
  }
  Markup2.clone = clone2;
  function sanitize2(markup) {
    return `${markup}`.trim().replace(/[\r|\n]/g, " ").replace(/>\s+</g, "><");
  }
  Markup2.sanitize = sanitize2;
  function parseJSONMarkup(markup, options = { ns: main_exports3.ns.svg }) {
    const fragment = document.createDocumentFragment();
    const groups = {};
    const selectors = {};
    const queue = [
      {
        markup: Array.isArray(markup) ? markup : [markup],
        parent: fragment,
        ns: options.ns
      }
    ];
    while (queue.length > 0) {
      const item = queue.pop();
      let ns2 = item.ns || main_exports3.ns.svg;
      const defines = item.markup;
      const parentNode = item.parent;
      defines.forEach((define) => {
        const tagName2 = define.tagName;
        if (!tagName2) {
          throw new TypeError("Invalid tagName");
        }
        if (define.ns) {
          ns2 = define.ns;
        }
        const node = ns2 ? main_exports3.createElementNS(tagName2, ns2) : main_exports3.createElement(tagName2);
        const attrs = define.attrs;
        if (attrs) {
          main_exports3.attr(node, main_exports3.kebablizeAttrs(attrs));
        }
        const style2 = define.style;
        if (style2) {
          main_exports3.css(node, style2);
        }
        const className3 = define.className;
        if (className3 != null) {
          node.setAttribute("class", Array.isArray(className3) ? className3.join(" ") : className3);
        }
        if (define.textContent) {
          node.textContent = define.textContent;
        }
        const selector = define.selector;
        if (selector != null) {
          if (selectors[selector]) {
            throw new TypeError("Selector must be unique");
          }
          selectors[selector] = node;
        }
        if (define.groupSelector) {
          let nodeGroups = define.groupSelector;
          if (!Array.isArray(nodeGroups)) {
            nodeGroups = [nodeGroups];
          }
          nodeGroups.forEach((name) => {
            if (!groups[name]) {
              groups[name] = [];
            }
            groups[name].push(node);
          });
        }
        parentNode.appendChild(node);
        const children2 = define.children;
        if (Array.isArray(children2)) {
          queue.push({ ns: ns2, markup: children2, parent: node });
        }
      });
    }
    Object.keys(groups).forEach((groupName) => {
      if (selectors[groupName]) {
        throw new Error("Ambiguous group selector");
      }
      selectors[groupName] = groups[groupName];
    });
    return { fragment, selectors, groups };
  }
  Markup2.parseJSONMarkup = parseJSONMarkup;
  function createContainer(firstChild) {
    return firstChild instanceof SVGElement ? main_exports3.createSvgElement("g") : main_exports3.createElement("div");
  }
  function renderMarkup(markup) {
    if (isStringMarkup(markup)) {
      const nodes = Vector.createVectors(markup);
      const count = nodes.length;
      if (count === 1) {
        return {
          elem: nodes[0].node
        };
      }
      if (count > 1) {
        const elem2 = createContainer(nodes[0].node);
        nodes.forEach((node) => {
          elem2.appendChild(node.node);
        });
        return { elem: elem2 };
      }
      return {};
    }
    const result2 = parseJSONMarkup(markup);
    const fragment = result2.fragment;
    let elem = null;
    if (fragment.childNodes.length > 1) {
      elem = createContainer(fragment.firstChild);
      elem.appendChild(fragment);
    } else {
      elem = fragment.firstChild;
    }
    return { elem, selectors: result2.selectors };
  }
  Markup2.renderMarkup = renderMarkup;
  function parseLabelStringMarkup(markup) {
    const children2 = Vector.createVectors(markup);
    const fragment = document.createDocumentFragment();
    for (let i = 0, n = children2.length; i < n; i += 1) {
      const currentChild = children2[i].node;
      fragment.appendChild(currentChild);
    }
    return { fragment, selectors: {} };
  }
  Markup2.parseLabelStringMarkup = parseLabelStringMarkup;
})(Markup || (Markup = {}));
(function(Markup2) {
  function getSelector(elem, stop, prev) {
    if (elem != null) {
      let selector;
      const tagName2 = elem.tagName.toLowerCase();
      if (elem === stop) {
        if (typeof prev === "string") {
          selector = `> ${tagName2} > ${prev}`;
        } else {
          selector = `> ${tagName2}`;
        }
        return selector;
      }
      const parent2 = elem.parentNode;
      if (parent2 && parent2.childNodes.length > 1) {
        const nth2 = main_exports3.index(elem) + 1;
        selector = `${tagName2}:nth-child(${nth2})`;
      } else {
        selector = tagName2;
      }
      if (prev) {
        selector += ` > ${prev}`;
      }
      return getSelector(elem.parentNode, stop, selector);
    }
    return prev;
  }
  Markup2.getSelector = getSelector;
})(Markup || (Markup = {}));
(function(Markup2) {
  function getPortContainerMarkup() {
    return "g";
  }
  Markup2.getPortContainerMarkup = getPortContainerMarkup;
  function getPortMarkup() {
    return {
      tagName: "circle",
      selector: "circle",
      attrs: {
        r: 10,
        fill: "#FFFFFF",
        stroke: "#000000"
      }
    };
  }
  Markup2.getPortMarkup = getPortMarkup;
  function getPortLabelMarkup() {
    return {
      tagName: "text",
      selector: "text",
      attrs: {
        fill: "#000000"
      }
    };
  }
  Markup2.getPortLabelMarkup = getPortLabelMarkup;
})(Markup || (Markup = {}));
(function(Markup2) {
  function getEdgeMarkup() {
    return [
      {
        tagName: "path",
        selector: "wrap",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          cursor: "pointer",
          stroke: "transparent",
          strokeLinecap: "round"
        }
      },
      {
        tagName: "path",
        selector: "line",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          pointerEvents: "none"
        }
      }
    ];
  }
  Markup2.getEdgeMarkup = getEdgeMarkup;
})(Markup || (Markup = {}));
(function(Markup2) {
  function getForeignObjectMarkup(bare = false) {
    return {
      tagName: "foreignObject",
      selector: "fo",
      children: [
        {
          ns: main_exports3.ns.xhtml,
          tagName: "body",
          selector: "foBody",
          attrs: {
            xmlns: main_exports3.ns.xhtml
          },
          style: {
            width: "100%",
            height: "100%",
            background: "transparent"
          },
          children: bare ? [] : [
            {
              tagName: "div",
              selector: "foContent",
              style: {
                width: "100%",
                height: "100%"
              }
            }
          ]
        }
      ]
    };
  }
  Markup2.getForeignObjectMarkup = getForeignObjectMarkup;
})(Markup || (Markup = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/view/attr.js
var AttrManager = class {
  constructor(view) {
    this.view = view;
  }
  get cell() {
    return this.view.cell;
  }
  getDefinition(attrName) {
    return this.cell.getAttrDefinition(attrName);
  }
  processAttrs(elem, raw2) {
    let normal3;
    let set2;
    let offset3;
    let position2;
    const specials = [];
    Object.keys(raw2).forEach((name) => {
      const val = raw2[name];
      const definition = this.getDefinition(name);
      const isValid2 = main_exports.call(Attr.isValidDefinition, this.view, definition, val, {
        elem,
        attrs: raw2,
        cell: this.cell,
        view: this.view
      });
      if (definition && isValid2) {
        if (typeof definition === "string") {
          if (normal3 == null) {
            normal3 = {};
          }
          normal3[definition] = val;
        } else if (val !== null) {
          specials.push({ name, definition });
        }
      } else {
        if (normal3 == null) {
          normal3 = {};
        }
        const normalName = main_exports3.CASE_SENSITIVE_ATTR.includes(name) ? name : string_exports.kebabCase(name);
        normal3[normalName] = val;
      }
    });
    specials.forEach(({ name, definition }) => {
      const val = raw2[name];
      const setDefine = definition;
      if (typeof setDefine.set === "function") {
        if (set2 == null) {
          set2 = {};
        }
        set2[name] = val;
      }
      const offsetDefine = definition;
      if (typeof offsetDefine.offset === "function") {
        if (offset3 == null) {
          offset3 = {};
        }
        offset3[name] = val;
      }
      const positionDefine = definition;
      if (typeof positionDefine.position === "function") {
        if (position2 == null) {
          position2 = {};
        }
        position2[name] = val;
      }
    });
    return {
      raw: raw2,
      normal: normal3,
      set: set2,
      offset: offset3,
      position: position2
    };
  }
  mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {
    allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);
    allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);
    allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset);
    const transform3 = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;
    if (transform3 != null && roProcessedAttrs.normal) {
      roProcessedAttrs.normal.transform = transform3;
    }
    allProcessedAttrs.normal = roProcessedAttrs.normal;
  }
  findAttrs(cellAttrs, rootNode, selectorCache, selectors) {
    const merge2 = [];
    const result2 = new Dictionary();
    Object.keys(cellAttrs).forEach((selector) => {
      const attrs = cellAttrs[selector];
      if (!object_exports.isPlainObject(attrs)) {
        return;
      }
      const { isCSSSelector, elems } = View.find(selector, rootNode, selectors);
      selectorCache[selector] = elems;
      for (let i = 0, l = elems.length; i < l; i += 1) {
        const elem = elems[i];
        const unique = selectors && selectors[selector] === elem;
        const prev = result2.get(elem);
        if (prev) {
          if (!prev.array) {
            merge2.push(elem);
            prev.array = true;
            prev.attrs = [prev.attrs];
            prev.priority = [prev.priority];
          }
          const attributes = prev.attrs;
          const selectedLength = prev.priority;
          if (unique) {
            attributes.unshift(attrs);
            selectedLength.unshift(-1);
          } else {
            const sortIndex = array_exports.sortedIndex(selectedLength, isCSSSelector ? -1 : l);
            attributes.splice(sortIndex, 0, attrs);
            selectedLength.splice(sortIndex, 0, l);
          }
        } else {
          result2.set(elem, {
            elem,
            attrs,
            priority: unique ? -1 : l,
            array: false
          });
        }
      }
    });
    merge2.forEach((node) => {
      const item = result2.get(node);
      const arr = item.attrs;
      item.attrs = arr.reduceRight((memo, attrs) => object_exports.merge(memo, attrs), {});
    });
    return result2;
  }
  updateRelativeAttrs(elem, processedAttrs, refBBox) {
    const rawAttrs = processedAttrs.raw || {};
    let nodeAttrs = processedAttrs.normal || {};
    const setAttrs = processedAttrs.set;
    const positionAttrs = processedAttrs.position;
    const offsetAttrs = processedAttrs.offset;
    const getOptions = () => ({
      elem,
      cell: this.cell,
      view: this.view,
      attrs: rawAttrs,
      refBBox: refBBox.clone()
    });
    if (setAttrs != null) {
      Object.keys(setAttrs).forEach((name) => {
        const val = setAttrs[name];
        const def = this.getDefinition(name);
        if (def != null) {
          const ret = main_exports.call(def.set, this.view, val, getOptions());
          if (typeof ret === "object") {
            nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);
          } else if (ret != null) {
            nodeAttrs[name] = ret;
          }
        }
      });
    }
    if (elem instanceof HTMLElement) {
      this.view.setAttrs(nodeAttrs, elem);
      return;
    }
    const nodeTransform = nodeAttrs.transform;
    const transform3 = nodeTransform ? `${nodeTransform}` : null;
    const nodeMatrix = main_exports3.transformStringToMatrix(transform3);
    const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);
    if (nodeTransform) {
      delete nodeAttrs.transform;
      nodeMatrix.e = 0;
      nodeMatrix.f = 0;
    }
    let positioned = false;
    if (positionAttrs != null) {
      Object.keys(positionAttrs).forEach((name) => {
        const val = positionAttrs[name];
        const def = this.getDefinition(name);
        if (def != null) {
          const ts = main_exports.call(def.position, this.view, val, getOptions());
          if (ts != null) {
            positioned = true;
            nodePosition.translate(Point.create(ts));
          }
        }
      });
    }
    this.view.setAttrs(nodeAttrs, elem);
    let offseted = false;
    if (offsetAttrs != null) {
      const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);
      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
        const nodeBBox = Util2.transformRectangle(nodeBoundingRect, nodeMatrix);
        Object.keys(offsetAttrs).forEach((name) => {
          const val = offsetAttrs[name];
          const def = this.getDefinition(name);
          if (def != null) {
            const ts = main_exports.call(def.offset, this.view, val, {
              elem,
              cell: this.cell,
              view: this.view,
              attrs: rawAttrs,
              refBBox: nodeBBox
            });
            if (ts != null) {
              offseted = true;
              nodePosition.translate(Point.create(ts));
            }
          }
        });
      }
    }
    if (nodeTransform != null || positioned || offseted) {
      nodePosition.round(1);
      nodeMatrix.e = nodePosition.x;
      nodeMatrix.f = nodePosition.y;
      elem.setAttribute("transform", main_exports3.matrixToTransformString(nodeMatrix));
    }
  }
  update(rootNode, attrs, options) {
    const selectorCache = {};
    const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors);
    const nodesAllAttrs = options.attrs ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors) : nodesAttrs;
    const specialItems = [];
    nodesAttrs.each((data2) => {
      const node = data2.elem;
      const nodeAttrs = data2.attrs;
      const processed = this.processAttrs(node, nodeAttrs);
      if (processed.set == null && processed.position == null && processed.offset == null) {
        this.view.setAttrs(processed.normal, node);
      } else {
        const data3 = nodesAllAttrs.get(node);
        const nodeAllAttrs = data3 ? data3.attrs : null;
        const refSelector = nodeAllAttrs && nodeAttrs.ref == null ? nodeAllAttrs.ref : nodeAttrs.ref;
        let refNode;
        if (refSelector) {
          refNode = (selectorCache[refSelector] || this.view.find(refSelector, rootNode, options.selectors))[0];
          if (!refNode) {
            throw new Error(`"${refSelector}" reference does not exist.`);
          }
        } else {
          refNode = null;
        }
        const item = {
          node,
          refNode,
          attributes: nodeAllAttrs,
          processedAttributes: processed
        };
        const index2 = specialItems.findIndex((item2) => item2.refNode === node);
        if (index2 > -1) {
          specialItems.splice(index2, 0, item);
        } else {
          specialItems.push(item);
        }
      }
    });
    const bboxCache = new Dictionary();
    let rotatableMatrix;
    specialItems.forEach((item) => {
      const node = item.node;
      const refNode = item.refNode;
      let unrotatedRefBBox;
      const isRefNodeRotatable = refNode != null && options.rotatableNode != null && main_exports3.contains(options.rotatableNode, refNode);
      if (refNode) {
        unrotatedRefBBox = bboxCache.get(refNode);
      }
      if (!unrotatedRefBBox) {
        const target = isRefNodeRotatable ? options.rotatableNode : rootNode;
        unrotatedRefBBox = refNode ? Util2.getBBox(refNode, { target }) : options.rootBBox;
        if (refNode) {
          bboxCache.set(refNode, unrotatedRefBBox);
        }
      }
      let processedAttrs;
      if (options.attrs && item.attributes) {
        processedAttrs = this.processAttrs(node, item.attributes);
        this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);
      } else {
        processedAttrs = item.processedAttributes;
      }
      let refBBox = unrotatedRefBBox;
      if (isRefNodeRotatable && options.rotatableNode != null && !options.rotatableNode.contains(node)) {
        if (!rotatableMatrix) {
          rotatableMatrix = main_exports3.transformStringToMatrix(main_exports3.attr(options.rotatableNode, "transform"));
        }
        refBBox = Util2.transformRectangle(unrotatedRefBBox, rotatableMatrix);
      }
      this.updateRelativeAttrs(node, processedAttrs, refBBox);
    });
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/view/flag.js
var FlagManager = class {
  get cell() {
    return this.view.cell;
  }
  constructor(view, actions, bootstrap = []) {
    this.view = view;
    const flags = {};
    const attrs = {};
    let shift = 0;
    Object.keys(actions).forEach((attr2) => {
      let labels2 = actions[attr2];
      if (!Array.isArray(labels2)) {
        labels2 = [labels2];
      }
      labels2.forEach((label) => {
        let flag = flags[label];
        if (!flag) {
          shift += 1;
          flag = flags[label] = 1 << shift;
        }
        attrs[attr2] |= flag;
      });
    });
    let labels = bootstrap;
    if (!Array.isArray(labels)) {
      labels = [labels];
    }
    labels.forEach((label) => {
      if (!flags[label]) {
        shift += 1;
        flags[label] = 1 << shift;
      }
    });
    if (shift > 25) {
      throw new Error("Maximum number of flags exceeded.");
    }
    this.flags = flags;
    this.attrs = attrs;
    this.bootstrap = bootstrap;
  }
  getFlag(label) {
    const flags = this.flags;
    if (flags == null) {
      return 0;
    }
    if (Array.isArray(label)) {
      return label.reduce((memo, key) => memo | flags[key], 0);
    }
    return flags[label] | 0;
  }
  hasAction(flag, label) {
    return flag & this.getFlag(label);
  }
  removeAction(flag, label) {
    return flag ^ flag & this.getFlag(label);
  }
  getBootstrapFlag() {
    return this.getFlag(this.bootstrap);
  }
  getChangedFlag() {
    let flag = 0;
    if (!this.attrs) {
      return flag;
    }
    Object.keys(this.attrs).forEach((attr2) => {
      if (this.cell.hasChanged(attr2)) {
        flag |= this.attrs[attr2];
      }
    });
    return flag;
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/view/cell.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest11 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var CellView = class _CellView extends View {
  static getDefaults() {
    return this.defaults;
  }
  static config(options) {
    this.defaults = this.getOptions(options);
  }
  static getOptions(options) {
    const mergeActions = (arr1, arr2) => {
      if (arr2 != null) {
        return array_exports.uniq([
          ...Array.isArray(arr1) ? arr1 : [arr1],
          ...Array.isArray(arr2) ? arr2 : [arr2]
        ]);
      }
      return Array.isArray(arr1) ? [...arr1] : [arr1];
    };
    const ret = object_exports.cloneDeep(this.getDefaults());
    const { bootstrap, actions, events, documentEvents } = options, others = __rest11(options, ["bootstrap", "actions", "events", "documentEvents"]);
    if (bootstrap) {
      ret.bootstrap = mergeActions(ret.bootstrap, bootstrap);
    }
    if (actions) {
      Object.entries(actions).forEach(([key, val]) => {
        const raw2 = ret.actions[key];
        if (val && raw2) {
          ret.actions[key] = mergeActions(raw2, val);
        } else if (val) {
          ret.actions[key] = mergeActions(val);
        }
      });
    }
    if (events) {
      ret.events = Object.assign(Object.assign({}, ret.events), events);
    }
    if (options.documentEvents) {
      ret.documentEvents = Object.assign(Object.assign({}, ret.documentEvents), documentEvents);
    }
    return object_exports.merge(ret, others);
  }
  get [Symbol.toStringTag]() {
    return _CellView.toStringTag;
  }
  constructor(cell, options = {}) {
    super();
    this.cell = cell;
    this.options = this.ensureOptions(options);
    this.graph = this.options.graph;
    this.attr = new AttrManager(this);
    this.flag = new FlagManager(this, this.options.actions, this.options.bootstrap);
    this.cache = new Cache(this);
    this.setContainer(this.ensureContainer());
    this.setup();
    this.init();
  }
  init() {
  }
  onRemove() {
    this.removeTools();
  }
  get priority() {
    return this.options.priority;
  }
  get rootSelector() {
    return this.options.rootSelector;
  }
  getConstructor() {
    return this.constructor;
  }
  ensureOptions(options) {
    return this.getConstructor().getOptions(options);
  }
  getContainerTagName() {
    return this.options.isSvgElement ? "g" : "div";
  }
  getContainerStyle() {
  }
  getContainerAttrs() {
    return {
      "data-cell-id": this.cell.id,
      "data-shape": this.cell.shape
    };
  }
  getContainerClassName() {
    return this.prefixClassName("cell");
  }
  ensureContainer() {
    return View.createElement(this.getContainerTagName(), this.options.isSvgElement);
  }
  setContainer(container) {
    if (this.container !== container) {
      this.undelegateEvents();
      this.container = container;
      if (this.options.events != null) {
        this.delegateEvents(this.options.events);
      }
      const attrs = this.getContainerAttrs();
      if (attrs != null) {
        this.setAttrs(attrs, container);
      }
      const style2 = this.getContainerStyle();
      if (style2 != null) {
        this.setStyle(style2, container);
      }
      const className3 = this.getContainerClassName();
      if (className3 != null) {
        this.addClass(className3, container);
      }
    }
    return this;
  }
  isNodeView() {
    return false;
  }
  isEdgeView() {
    return false;
  }
  render() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(flag, options = {}) {
    return 0;
  }
  getBootstrapFlag() {
    return this.flag.getBootstrapFlag();
  }
  getFlag(actions) {
    return this.flag.getFlag(actions);
  }
  hasAction(flag, actions) {
    return this.flag.hasAction(flag, actions);
  }
  removeAction(flag, actions) {
    return this.flag.removeAction(flag, actions);
  }
  handleAction(flag, action, handle, additionalRemovedActions) {
    if (this.hasAction(flag, action)) {
      handle();
      const removedFlags = [action];
      if (additionalRemovedActions) {
        if (typeof additionalRemovedActions === "string") {
          removedFlags.push(additionalRemovedActions);
        } else {
          removedFlags.push(...additionalRemovedActions);
        }
      }
      return this.removeAction(flag, removedFlags);
    }
    return flag;
  }
  setup() {
    this.cell.on("changed", this.onCellChanged, this);
  }
  onCellChanged({ options }) {
    this.onAttrsChange(options);
  }
  onAttrsChange(options) {
    let flag = this.flag.getChangedFlag();
    if (options.updated || !flag) {
      return;
    }
    if (options.dirty && this.hasAction(flag, "update")) {
      flag |= this.getFlag("render");
    }
    if (options.toolId) {
      options.async = false;
    }
    if (this.graph != null) {
      this.graph.renderer.requestViewUpdate(this, flag, options);
    }
  }
  parseJSONMarkup(markup, rootElem) {
    const result2 = Markup.parseJSONMarkup(markup);
    const selectors = result2.selectors;
    const rootSelector = this.rootSelector;
    if (rootElem && rootSelector) {
      if (selectors[rootSelector]) {
        throw new Error("Invalid root selector");
      }
      selectors[rootSelector] = rootElem;
    }
    return result2;
  }
  can(feature) {
    let interacting = this.graph.options.interacting;
    if (typeof interacting === "function") {
      interacting = main_exports.call(interacting, this.graph, this);
    }
    if (typeof interacting === "object") {
      let val = interacting[feature];
      if (typeof val === "function") {
        val = main_exports.call(val, this.graph, this);
      }
      return val !== false;
    }
    if (typeof interacting === "boolean") {
      return interacting;
    }
    return false;
  }
  cleanCache() {
    this.cache.clean();
    return this;
  }
  getCache(elem) {
    return this.cache.get(elem);
  }
  getDataOfElement(elem) {
    return this.cache.getData(elem);
  }
  getMatrixOfElement(elem) {
    return this.cache.getMatrix(elem);
  }
  getShapeOfElement(elem) {
    return this.cache.getShape(elem);
  }
  getBoundingRectOfElement(elem) {
    return this.cache.getBoundingRect(elem);
  }
  getBBoxOfElement(elem) {
    const rect2 = this.getBoundingRectOfElement(elem);
    const matrix = this.getMatrixOfElement(elem);
    const rm = this.getRootRotatedMatrix();
    const tm = this.getRootTranslatedMatrix();
    return Util2.transformRectangle(rect2, tm.multiply(rm).multiply(matrix));
  }
  getUnrotatedBBoxOfElement(elem) {
    const rect2 = this.getBoundingRectOfElement(elem);
    const matrix = this.getMatrixOfElement(elem);
    const tm = this.getRootTranslatedMatrix();
    return Util2.transformRectangle(rect2, tm.multiply(matrix));
  }
  getBBox(options = {}) {
    let bbox2;
    if (options.useCellGeometry) {
      const cell = this.cell;
      const angle = cell.isNode() ? cell.getAngle() : 0;
      bbox2 = cell.getBBox().bbox(angle);
    } else {
      bbox2 = this.getBBoxOfElement(this.container);
    }
    return this.graph.coord.localToGraphRect(bbox2);
  }
  getRootTranslatedMatrix() {
    const cell = this.cell;
    const pos = cell.isNode() ? cell.getPosition() : { x: 0, y: 0 };
    return main_exports3.createSVGMatrix().translate(pos.x, pos.y);
  }
  getRootRotatedMatrix() {
    let matrix = main_exports3.createSVGMatrix();
    const cell = this.cell;
    const angle = cell.isNode() ? cell.getAngle() : 0;
    if (angle) {
      const bbox2 = cell.getBBox();
      const cx = bbox2.width / 2;
      const cy = bbox2.height / 2;
      matrix = matrix.translate(cx, cy).rotate(angle).translate(-cx, -cy);
    }
    return matrix;
  }
  findMagnet(elem = this.container) {
    return this.findByAttr("magnet", elem);
  }
  updateAttrs(rootNode, attrs, options = {}) {
    if (options.rootBBox == null) {
      options.rootBBox = new Rectangle();
    }
    if (options.selectors == null) {
      options.selectors = this.selectors;
    }
    this.attr.update(rootNode, attrs, options);
  }
  isEdgeElement(magnet) {
    return this.cell.isEdge() && (magnet == null || magnet === this.container);
  }
  // #region highlight
  prepareHighlight(elem, options = {}) {
    const magnet = elem || this.container;
    options.partial = magnet === this.container;
    return magnet;
  }
  highlight(elem, options = {}) {
    const magnet = this.prepareHighlight(elem, options);
    this.notify("cell:highlight", {
      magnet,
      options,
      view: this,
      cell: this.cell
    });
    if (this.isEdgeView()) {
      this.notify("edge:highlight", {
        magnet,
        options,
        view: this,
        edge: this.cell,
        cell: this.cell
      });
    } else if (this.isNodeView()) {
      this.notify("node:highlight", {
        magnet,
        options,
        view: this,
        node: this.cell,
        cell: this.cell
      });
    }
    return this;
  }
  unhighlight(elem, options = {}) {
    const magnet = this.prepareHighlight(elem, options);
    this.notify("cell:unhighlight", {
      magnet,
      options,
      view: this,
      cell: this.cell
    });
    if (this.isNodeView()) {
      this.notify("node:unhighlight", {
        magnet,
        options,
        view: this,
        node: this.cell,
        cell: this.cell
      });
    } else if (this.isEdgeView()) {
      this.notify("edge:unhighlight", {
        magnet,
        options,
        view: this,
        edge: this.cell,
        cell: this.cell
      });
    }
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  notifyUnhighlight(magnet, options) {
  }
  // #endregion
  getEdgeTerminal(magnet, x, y, edge, type) {
    const cell = this.cell;
    const portId = this.findAttr("port", magnet);
    const selector = magnet.getAttribute("data-selector");
    const terminal = { cell: cell.id };
    if (selector != null) {
      terminal.magnet = selector;
    }
    if (portId != null) {
      terminal.port = portId;
      if (cell.isNode()) {
        if (!cell.hasPort(portId) && selector == null) {
          terminal.selector = this.getSelector(magnet);
        }
      }
    } else if (selector == null && this.container !== magnet) {
      terminal.selector = this.getSelector(magnet);
    }
    return terminal;
  }
  getMagnetFromEdgeTerminal(terminal) {
    const cell = this.cell;
    const root2 = this.container;
    const portId = terminal.port;
    let selector = terminal.magnet;
    let magnet;
    if (portId != null && cell.isNode() && cell.hasPort(portId)) {
      magnet = this.findPortElem(portId, selector) || root2;
    } else {
      if (!selector) {
        selector = terminal.selector;
      }
      if (!selector && portId != null) {
        selector = `[port="${portId}"]`;
      }
      magnet = this.findOne(selector, root2, this.selectors);
    }
    return magnet;
  }
  hasTools(name) {
    const tools = this.tools;
    if (tools == null) {
      return false;
    }
    if (name == null) {
      return true;
    }
    return tools.name === name;
  }
  addTools(config) {
    this.removeTools();
    if (config) {
      if (!this.can("toolsAddable")) {
        return this;
      }
      const tools = ToolsView.isToolsView(config) ? config : new ToolsView(config);
      this.tools = tools;
      tools.config({ view: this });
      tools.mount();
    }
    return this;
  }
  updateTools(options = {}) {
    if (this.tools) {
      this.tools.update(options);
    }
    return this;
  }
  removeTools() {
    if (this.tools) {
      this.tools.remove();
      this.tools = null;
    }
    return this;
  }
  hideTools() {
    if (this.tools) {
      this.tools.hide();
    }
    return this;
  }
  showTools() {
    if (this.tools) {
      this.tools.show();
    }
    return this;
  }
  renderTools() {
    const tools = this.cell.getTools();
    this.addTools(tools);
    return this;
  }
  notify(name, args) {
    this.trigger(name, args);
    this.graph.trigger(name, args);
    return this;
  }
  getEventArgs(e, x, y) {
    const view = this;
    const cell = view.cell;
    if (x == null || y == null) {
      return { e, view, cell };
    }
    return { e, x, y, view, cell };
  }
  onClick(e, x, y) {
    this.notify("cell:click", this.getEventArgs(e, x, y));
  }
  onDblClick(e, x, y) {
    this.notify("cell:dblclick", this.getEventArgs(e, x, y));
  }
  onContextMenu(e, x, y) {
    this.notify("cell:contextmenu", this.getEventArgs(e, x, y));
  }
  onMouseDown(e, x, y) {
    if (this.cell.model) {
      this.cachedModelForMouseEvent = this.cell.model;
      this.cachedModelForMouseEvent.startBatch("mouse");
    }
    this.notify("cell:mousedown", this.getEventArgs(e, x, y));
  }
  onMouseUp(e, x, y) {
    this.notify("cell:mouseup", this.getEventArgs(e, x, y));
    if (this.cachedModelForMouseEvent) {
      this.cachedModelForMouseEvent.stopBatch("mouse", { cell: this.cell });
      this.cachedModelForMouseEvent = null;
    }
  }
  onMouseMove(e, x, y) {
    this.notify("cell:mousemove", this.getEventArgs(e, x, y));
  }
  onMouseOver(e) {
    this.notify("cell:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    this.notify("cell:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    this.notify("cell:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    this.notify("cell:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, x, y, delta) {
    this.notify("cell:mousewheel", Object.assign({ delta }, this.getEventArgs(e, x, y)));
  }
  onCustomEvent(e, name, x, y) {
    this.notify("cell:customevent", Object.assign({ name }, this.getEventArgs(e, x, y)));
    this.notify(name, Object.assign({}, this.getEventArgs(e, x, y)));
  }
  onMagnetMouseDown(e, magnet, x, y) {
  }
  onMagnetDblClick(e, magnet, x, y) {
  }
  onMagnetContextMenu(e, magnet, x, y) {
  }
  onLabelMouseDown(e, x, y) {
  }
  checkMouseleave(e) {
    const target = this.getEventTarget(e, { fromPoint: true });
    const view = this.graph.findViewByElem(target);
    if (view === this) {
      return;
    }
    this.onMouseLeave(e);
    if (!view) {
      return;
    }
    view.onMouseEnter(e);
  }
  dispose() {
    this.cell.off("changed", this.onCellChanged, this);
  }
};
CellView.defaults = {
  isSvgElement: true,
  rootSelector: "root",
  priority: 0,
  bootstrap: [],
  actions: {}
};
__decorate3([
  CellView.dispose()
], CellView.prototype, "dispose", null);
(function(CellView2) {
  CellView2.Flag = FlagManager;
  CellView2.Attr = AttrManager;
})(CellView || (CellView = {}));
(function(CellView2) {
  CellView2.toStringTag = `X6.${CellView2.name}`;
  function isCellView(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof CellView2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const view = instance;
    if ((tag == null || tag === CellView2.toStringTag) && typeof view.isNodeView === "function" && typeof view.isEdgeView === "function" && typeof view.confirmUpdate === "function") {
      return true;
    }
    return false;
  }
  CellView2.isCellView = isCellView;
})(CellView || (CellView = {}));
(function(CellView2) {
  function priority(value) {
    return function(ctor) {
      ctor.config({ priority: value });
    };
  }
  CellView2.priority = priority;
  function bootstrap(actions) {
    return function(ctor) {
      ctor.config({ bootstrap: actions });
    };
  }
  CellView2.bootstrap = bootstrap;
})(CellView || (CellView = {}));
(function(CellView2) {
  CellView2.registry = Registry.create({
    type: "view"
  });
})(CellView || (CellView = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/view/tool.js
var ToolsView = class _ToolsView extends View {
  get name() {
    return this.options.name;
  }
  get graph() {
    return this.cellView.graph;
  }
  get cell() {
    return this.cellView.cell;
  }
  get [Symbol.toStringTag]() {
    return _ToolsView.toStringTag;
  }
  constructor(options = {}) {
    super();
    this.svgContainer = this.createContainer(true, options);
    this.htmlContainer = this.createContainer(false, options);
    this.config(options);
  }
  createContainer(svg, options) {
    const container = svg ? View.createElement("g", true) : View.createElement("div", false);
    main_exports3.addClass(container, this.prefixClassName("cell-tools"));
    if (options.className) {
      main_exports3.addClass(container, options.className);
    }
    return container;
  }
  config(options) {
    this.options = Object.assign(Object.assign({}, this.options), options);
    if (!CellView.isCellView(options.view) || options.view === this.cellView) {
      return this;
    }
    this.cellView = options.view;
    if (this.cell.isEdge()) {
      main_exports3.addClass(this.svgContainer, this.prefixClassName("edge-tools"));
      main_exports3.addClass(this.htmlContainer, this.prefixClassName("edge-tools"));
    } else if (this.cell.isNode()) {
      main_exports3.addClass(this.svgContainer, this.prefixClassName("node-tools"));
      main_exports3.addClass(this.htmlContainer, this.prefixClassName("node-tools"));
    }
    this.svgContainer.setAttribute("data-cell-id", this.cell.id);
    this.htmlContainer.setAttribute("data-cell-id", this.cell.id);
    if (this.name) {
      this.svgContainer.setAttribute("data-tools-name", this.name);
      this.htmlContainer.setAttribute("data-tools-name", this.name);
    }
    const tools = this.options.items;
    if (!Array.isArray(tools)) {
      return this;
    }
    this.tools = [];
    const normalizedTools = [];
    tools.forEach((meta) => {
      if (_ToolsView.ToolItem.isToolItem(meta)) {
        if (meta.name === "vertices") {
          normalizedTools.unshift(meta);
        } else {
          normalizedTools.push(meta);
        }
      } else {
        const name = typeof meta === "object" ? meta.name : meta;
        if (name === "vertices") {
          normalizedTools.unshift(meta);
        } else {
          normalizedTools.push(meta);
        }
      }
    });
    for (let i = 0; i < normalizedTools.length; i += 1) {
      const meta = normalizedTools[i];
      let tool;
      if (_ToolsView.ToolItem.isToolItem(meta)) {
        tool = meta;
      } else {
        const name = typeof meta === "object" ? meta.name : meta;
        const args = typeof meta === "object" ? meta.args || {} : {};
        if (name) {
          if (this.cell.isNode()) {
            const ctor = NodeTool.registry.get(name);
            if (ctor) {
              tool = new ctor(args);
            } else {
              return NodeTool.registry.onNotFound(name);
            }
          } else if (this.cell.isEdge()) {
            const ctor = EdgeTool.registry.get(name);
            if (ctor) {
              tool = new ctor(args);
            } else {
              return EdgeTool.registry.onNotFound(name);
            }
          }
        }
      }
      if (tool) {
        tool.config(this.cellView, this);
        tool.render();
        const container = tool.options.isSVGElement !== false ? this.svgContainer : this.htmlContainer;
        container.appendChild(tool.container);
        this.tools.push(tool);
      }
    }
    return this;
  }
  update(options = {}) {
    const tools = this.tools;
    if (tools) {
      tools.forEach((tool) => {
        if (options.toolId !== tool.cid && tool.isVisible()) {
          tool.update();
        }
      });
    }
    return this;
  }
  focus(focusedTool) {
    const tools = this.tools;
    if (tools) {
      tools.forEach((tool) => {
        if (focusedTool === tool) {
          tool.show();
        } else {
          tool.hide();
        }
      });
    }
    return this;
  }
  blur(blurredTool) {
    const tools = this.tools;
    if (tools) {
      tools.forEach((tool) => {
        if (tool !== blurredTool && !tool.isVisible()) {
          tool.show();
          tool.update();
        }
      });
    }
    return this;
  }
  hide() {
    return this.focus(null);
  }
  show() {
    return this.blur(null);
  }
  remove() {
    const tools = this.tools;
    if (tools) {
      tools.forEach((tool) => tool.remove());
      this.tools = null;
    }
    main_exports3.remove(this.svgContainer);
    main_exports3.remove(this.htmlContainer);
    return super.remove();
  }
  mount() {
    const tools = this.tools;
    const cellView = this.cellView;
    if (cellView && tools) {
      const hasSVG = tools.some((tool) => tool.options.isSVGElement !== false);
      const hasHTML = tools.some((tool) => tool.options.isSVGElement === false);
      if (hasSVG) {
        const parent2 = this.options.local ? cellView.container : cellView.graph.view.decorator;
        parent2.appendChild(this.svgContainer);
      }
      if (hasHTML) {
        this.graph.container.appendChild(this.htmlContainer);
      }
    }
    return this;
  }
};
(function(ToolsView2) {
  ToolsView2.toStringTag = `X6.${ToolsView2.name}`;
  function isToolsView(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof ToolsView2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const view = instance;
    if ((tag == null || tag === ToolsView2.toStringTag) && view.graph != null && view.cell != null && typeof view.config === "function" && typeof view.update === "function" && typeof view.focus === "function" && typeof view.blur === "function" && typeof view.show === "function" && typeof view.hide === "function") {
      return true;
    }
    return false;
  }
  ToolsView2.isToolsView = isToolsView;
})(ToolsView || (ToolsView = {}));
(function(ToolsView2) {
  class ToolItem extends View {
    static getDefaults() {
      return this.defaults;
    }
    static config(options) {
      this.defaults = this.getOptions(options);
    }
    static getOptions(options) {
      return object_exports.merge(object_exports.cloneDeep(this.getDefaults()), options);
    }
    get graph() {
      return this.cellView.graph;
    }
    get cell() {
      return this.cellView.cell;
    }
    get name() {
      return this.options.name;
    }
    get [Symbol.toStringTag]() {
      return ToolItem.toStringTag;
    }
    constructor(options = {}) {
      super();
      this.visible = true;
      this.options = this.getOptions(options);
      this.container = View.createElement(this.options.tagName || "g", this.options.isSVGElement !== false);
      main_exports3.addClass(this.container, this.prefixClassName("cell-tool"));
      if (typeof this.options.className === "string") {
        main_exports3.addClass(this.container, this.options.className);
      }
      this.init();
    }
    init() {
    }
    getOptions(options) {
      const ctor = this.constructor;
      return ctor.getOptions(options);
    }
    delegateEvents() {
      if (this.options.events) {
        super.delegateEvents(this.options.events);
      }
      return this;
    }
    config(view, toolsView) {
      this.cellView = view;
      this.parent = toolsView;
      this.stamp(this.container);
      if (this.cell.isEdge()) {
        main_exports3.addClass(this.container, this.prefixClassName("edge-tool"));
      } else if (this.cell.isNode()) {
        main_exports3.addClass(this.container, this.prefixClassName("node-tool"));
      }
      if (this.name) {
        this.container.setAttribute("data-tool-name", this.name);
      }
      this.delegateEvents();
      return this;
    }
    render() {
      this.empty();
      const markup = this.options.markup;
      if (markup) {
        const meta = Markup.parseJSONMarkup(markup);
        this.container.appendChild(meta.fragment);
        this.childNodes = meta.selectors;
      }
      this.onRender();
      return this;
    }
    onRender() {
    }
    update() {
      return this;
    }
    stamp(elem) {
      if (elem) {
        elem.setAttribute("data-cell-id", this.cellView.cell.id);
      }
    }
    show() {
      this.container.style.display = "";
      this.visible = true;
      return this;
    }
    hide() {
      this.container.style.display = "none";
      this.visible = false;
      return this;
    }
    isVisible() {
      return this.visible;
    }
    focus() {
      const opacity2 = this.options.focusOpacity;
      if (opacity2 != null && Number.isFinite(opacity2)) {
        this.container.style.opacity = `${opacity2}`;
      }
      this.parent.focus(this);
      return this;
    }
    blur() {
      this.container.style.opacity = "";
      this.parent.blur(this);
      return this;
    }
    guard(evt) {
      if (this.graph == null || this.cellView == null) {
        return true;
      }
      return this.graph.view.guard(evt, this.cellView);
    }
  }
  ToolItem.defaults = {
    isSVGElement: true,
    tagName: "g"
  };
  ToolsView2.ToolItem = ToolItem;
  (function(ToolItem2) {
    let counter = 0;
    function getClassName(name) {
      if (name) {
        return string_exports.pascalCase(name);
      }
      counter += 1;
      return `CustomTool${counter}`;
    }
    function define(options) {
      const tool = object_exports.createClass(getClassName(options.name), this);
      tool.config(options);
      return tool;
    }
    ToolItem2.define = define;
  })(ToolItem = ToolsView2.ToolItem || (ToolsView2.ToolItem = {}));
  (function(ToolItem2) {
    ToolItem2.toStringTag = `X6.${ToolItem2.name}`;
    function isToolItem(instance) {
      if (instance == null) {
        return false;
      }
      if (instance instanceof ToolItem2) {
        return true;
      }
      const tag = instance[Symbol.toStringTag];
      const view = instance;
      if ((tag == null || tag === ToolItem2.toStringTag) && view.graph != null && view.cell != null && typeof view.config === "function" && typeof view.update === "function" && typeof view.focus === "function" && typeof view.blur === "function" && typeof view.show === "function" && typeof view.hide === "function" && typeof view.isVisible === "function") {
        return true;
      }
      return false;
    }
    ToolItem2.isToolItem = isToolItem;
  })(ToolItem = ToolsView2.ToolItem || (ToolsView2.ToolItem = {}));
})(ToolsView || (ToolsView = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-strategy/main.js
var main_exports12 = {};
__export(main_exports12, {
  noop: () => noop2,
  pinAbsolute: () => pinAbsolute,
  pinRelative: () => pinRelative
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-strategy/noop.js
var noop2 = (terminal) => terminal;

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-strategy/pin.js
function toPercentage(value, max2) {
  if (max2 === 0) {
    return "0%";
  }
  return `${Math.round(value / max2 * 100)}%`;
}
function pin(relative) {
  const strategy = (terminal, view, magnet, coords) => {
    return view.isEdgeElement(magnet) ? pinEdgeTerminal(relative, terminal, view, magnet, coords) : pinNodeTerminal(relative, terminal, view, magnet, coords);
  };
  return strategy;
}
function pinNodeTerminal(relative, data2, view, magnet, coords) {
  const node = view.cell;
  const angle = node.getAngle();
  const bbox2 = view.getUnrotatedBBoxOfElement(magnet);
  const center2 = node.getBBox().getCenter();
  const pos = Point.create(coords).rotate(angle, center2);
  let dx = pos.x - bbox2.x;
  let dy = pos.y - bbox2.y;
  if (relative) {
    dx = toPercentage(dx, bbox2.width);
    dy = toPercentage(dy, bbox2.height);
  }
  data2.anchor = {
    name: "topLeft",
    args: {
      dx,
      dy,
      rotate: true
    }
  };
  return data2;
}
function pinEdgeTerminal(relative, end, view, magnet, coords) {
  const connection2 = view.getConnection();
  if (!connection2) {
    return end;
  }
  const length2 = connection2.closestPointLength(coords);
  if (relative) {
    const totalLength = connection2.length();
    end.anchor = {
      name: "ratio",
      args: {
        ratio: length2 / totalLength
      }
    };
  } else {
    end.anchor = {
      name: "length",
      args: {
        length: length2
      }
    };
  }
  return end;
}
var pinRelative = pin(true);
var pinAbsolute = pin(false);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-strategy/index.js
var ConnectionStrategy;
(function(ConnectionStrategy2) {
  ConnectionStrategy2.presets = main_exports12;
  ConnectionStrategy2.registry = Registry.create({
    type: "connection strategy"
  });
  ConnectionStrategy2.registry.register(ConnectionStrategy2.presets, true);
})(ConnectionStrategy || (ConnectionStrategy = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/tool/util.js
function getAnchor(pos, terminalView, terminalMagnet, type) {
  const end = main_exports.call(ConnectionStrategy.presets.pinRelative, this.graph, {}, terminalView, terminalMagnet, pos, this.cell, type, {});
  return end.anchor;
}
function getViewBBox(view, quick) {
  if (quick) {
    return view.cell.getBBox();
  }
  return view.cell.isEdge() ? view.getConnection().bbox() : view.getUnrotatedBBoxOfElement(view.container);
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/tool/button.js
var Button = class extends ToolsView.ToolItem {
  onRender() {
    main_exports3.addClass(this.container, this.prefixClassName("cell-tool-button"));
    this.update();
  }
  update() {
    this.updatePosition();
    return this;
  }
  updatePosition() {
    const view = this.cellView;
    const matrix = view.cell.isEdge() ? this.getEdgeMatrix() : this.getNodeMatrix();
    main_exports3.transform(this.container, matrix, { absolute: true });
  }
  getNodeMatrix() {
    const view = this.cellView;
    const options = this.options;
    let { x = 0, y = 0 } = options;
    const { offset: offset3, useCellGeometry, rotate: rotate3 } = options;
    let bbox2 = getViewBBox(view, useCellGeometry);
    const angle = view.cell.getAngle();
    if (!rotate3) {
      bbox2 = bbox2.bbox(angle);
    }
    let offsetX = 0;
    let offsetY = 0;
    if (typeof offset3 === "number") {
      offsetX = offset3;
      offsetY = offset3;
    } else if (typeof offset3 === "object") {
      offsetX = offset3.x;
      offsetY = offset3.y;
    }
    x = number_exports.normalizePercentage(x, bbox2.width);
    y = number_exports.normalizePercentage(y, bbox2.height);
    let matrix = main_exports3.createSVGMatrix().translate(bbox2.x + bbox2.width / 2, bbox2.y + bbox2.height / 2);
    if (rotate3) {
      matrix = matrix.rotate(angle);
    }
    matrix = matrix.translate(x + offsetX - bbox2.width / 2, y + offsetY - bbox2.height / 2);
    return matrix;
  }
  getEdgeMatrix() {
    const view = this.cellView;
    const options = this.options;
    const { offset: offset3 = 0, distance = 0, rotate: rotate3 } = options;
    let tangent;
    let position2;
    let angle;
    const d = number_exports.normalizePercentage(distance, 1);
    if (d >= 0 && d <= 1) {
      tangent = view.getTangentAtRatio(d);
    } else {
      tangent = view.getTangentAtLength(d);
    }
    if (tangent) {
      position2 = tangent.start;
      angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;
    } else {
      position2 = view.getConnection().start;
      angle = 0;
    }
    let matrix = main_exports3.createSVGMatrix().translate(position2.x, position2.y).rotate(angle);
    if (typeof offset3 === "object") {
      matrix = matrix.translate(offset3.x || 0, offset3.y || 0);
    } else {
      matrix = matrix.translate(0, offset3);
    }
    if (!rotate3) {
      matrix = matrix.rotate(-angle);
    }
    return matrix;
  }
  onMouseDown(e) {
    if (this.guard(e)) {
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    const onClick = this.options.onClick;
    if (typeof onClick === "function") {
      main_exports.call(onClick, this.cellView, {
        e,
        view: this.cellView,
        cell: this.cellView.cell,
        btn: this
      });
    }
  }
};
(function(Button2) {
  Button2.config({
    name: "button",
    useCellGeometry: true,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    }
  });
})(Button || (Button = {}));
(function(Button2) {
  Button2.Remove = Button2.define({
    name: "button-remove",
    markup: [
      {
        tagName: "circle",
        selector: "button",
        attrs: {
          r: 7,
          fill: "#FF1D00",
          cursor: "pointer"
        }
      },
      {
        tagName: "path",
        selector: "icon",
        attrs: {
          d: "M -3 -3 3 3 M -3 3 3 -3",
          fill: "none",
          stroke: "#FFFFFF",
          "stroke-width": 2,
          "pointer-events": "none"
        }
      }
    ],
    distance: 60,
    offset: 0,
    useCellGeometry: true,
    onClick({ view, btn }) {
      btn.parent.remove();
      view.cell.remove({ ui: true, toolId: btn.cid });
    }
  });
})(Button || (Button = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/tool/boundary.js
var __rest12 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Boundary = class extends ToolsView.ToolItem {
  onRender() {
    main_exports3.addClass(this.container, this.prefixClassName("cell-tool-boundary"));
    if (this.options.attrs) {
      const _a = this.options.attrs, { class: className3 } = _a, attrs = __rest12(_a, ["class"]);
      main_exports3.attr(this.container, main_exports3.kebablizeAttrs(attrs));
      if (className3) {
        main_exports3.addClass(this.container, className3);
      }
    }
    this.update();
  }
  update() {
    const view = this.cellView;
    const options = this.options;
    const { useCellGeometry, rotate: rotate3 } = options;
    const padding = number_exports.normalizeSides(options.padding);
    let bbox2 = getViewBBox(view, useCellGeometry).moveAndExpand({
      x: -padding.left,
      y: -padding.top,
      width: padding.left + padding.right,
      height: padding.top + padding.bottom
    });
    const cell = view.cell;
    if (cell.isNode()) {
      const angle = cell.getAngle();
      if (angle) {
        if (rotate3) {
          const origin = cell.getBBox().getCenter();
          main_exports3.rotate(this.container, angle, origin.x, origin.y, {
            absolute: true
          });
        } else {
          bbox2 = bbox2.bbox(angle);
        }
      }
    }
    main_exports3.attr(this.container, bbox2.toJSON());
    return this;
  }
};
(function(Boundary2) {
  Boundary2.config({
    name: "boundary",
    tagName: "rect",
    padding: 10,
    useCellGeometry: true,
    attrs: {
      fill: "none",
      stroke: "#333",
      "stroke-width": 0.5,
      "stroke-dasharray": "5, 5",
      "pointer-events": "none"
    }
  });
})(Boundary || (Boundary = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/tool/vertices.js
var Vertices = class extends ToolsView.ToolItem {
  constructor() {
    super(...arguments);
    this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  onRender() {
    this.addClass(this.prefixClassName("edge-tool-vertices"));
    if (this.options.addable) {
      this.updatePath();
    }
    this.resetHandles();
    this.renderHandles();
    return this;
  }
  update() {
    const vertices = this.vertices;
    if (vertices.length === this.handles.length) {
      this.updateHandles();
    } else {
      this.resetHandles();
      this.renderHandles();
    }
    if (this.options.addable) {
      this.updatePath();
    }
    return this;
  }
  resetHandles() {
    const handles = this.handles;
    this.handles = [];
    if (handles) {
      handles.forEach((handle) => {
        this.stopHandleListening(handle);
        handle.remove();
      });
    }
  }
  renderHandles() {
    const vertices = this.vertices;
    for (let i = 0, l = vertices.length; i < l; i += 1) {
      const vertex = vertices[i];
      const createHandle = this.options.createHandle;
      const processHandle = this.options.processHandle;
      const handle = createHandle({
        index: i,
        graph: this.graph,
        guard: (evt) => this.guard(evt),
        attrs: this.options.attrs || {}
      });
      if (processHandle) {
        processHandle(handle);
      }
      handle.updatePosition(vertex.x, vertex.y);
      this.stamp(handle.container);
      this.container.appendChild(handle.container);
      this.handles.push(handle);
      this.startHandleListening(handle);
    }
  }
  updateHandles() {
    const vertices = this.vertices;
    for (let i = 0, l = vertices.length; i < l; i += 1) {
      const vertex = vertices[i];
      const handle = this.handles[i];
      if (handle) {
        handle.updatePosition(vertex.x, vertex.y);
      }
    }
  }
  updatePath() {
    const connection2 = this.childNodes.connection;
    if (connection2) {
      connection2.setAttribute("d", this.cellView.getConnectionPathData());
    }
  }
  startHandleListening(handle) {
    const edgeView = this.cellView;
    if (edgeView.can("vertexMovable")) {
      handle.on("change", this.onHandleChange, this);
      handle.on("changing", this.onHandleChanging, this);
      handle.on("changed", this.onHandleChanged, this);
    }
    if (edgeView.can("vertexDeletable")) {
      handle.on("remove", this.onHandleRemove, this);
    }
  }
  stopHandleListening(handle) {
    const edgeView = this.cellView;
    if (edgeView.can("vertexMovable")) {
      handle.off("change", this.onHandleChange, this);
      handle.off("changing", this.onHandleChanging, this);
      handle.off("changed", this.onHandleChanged, this);
    }
    if (edgeView.can("vertexDeletable")) {
      handle.off("remove", this.onHandleRemove, this);
    }
  }
  getNeighborPoints(index2) {
    const edgeView = this.cellView;
    const vertices = this.vertices;
    const prev = index2 > 0 ? vertices[index2 - 1] : edgeView.sourceAnchor;
    const next = index2 < vertices.length - 1 ? vertices[index2 + 1] : edgeView.targetAnchor;
    return {
      prev: Point.create(prev),
      next: Point.create(next)
    };
  }
  getMouseEventArgs(evt) {
    const e = this.normalizeEvent(evt);
    const { x, y } = this.graph.snapToGrid(e.clientX, e.clientY);
    return { e, x, y };
  }
  onHandleChange({ e }) {
    this.focus();
    const edgeView = this.cellView;
    edgeView.cell.startBatch("move-vertex", { ui: true, toolId: this.cid });
    if (!this.options.stopPropagation) {
      const { e: evt, x, y } = this.getMouseEventArgs(e);
      this.eventData(evt, { start: { x, y } });
      edgeView.notifyMouseDown(evt, x, y);
    }
  }
  onHandleChanging({ handle, e }) {
    const edgeView = this.cellView;
    const index2 = handle.options.index;
    const { e: evt, x, y } = this.getMouseEventArgs(e);
    const vertex = { x, y };
    this.snapVertex(vertex, index2);
    edgeView.cell.setVertexAt(index2, vertex, { ui: true, toolId: this.cid });
    handle.updatePosition(vertex.x, vertex.y);
    if (!this.options.stopPropagation) {
      edgeView.notifyMouseMove(evt, x, y);
    }
  }
  stopBatch(vertexAdded) {
    this.cell.stopBatch("move-vertex", { ui: true, toolId: this.cid });
    if (vertexAdded) {
      this.cell.stopBatch("add-vertex", { ui: true, toolId: this.cid });
    }
  }
  onHandleChanged({ e }) {
    const options = this.options;
    const edgeView = this.cellView;
    if (options.addable) {
      this.updatePath();
    }
    if (!options.removeRedundancies) {
      this.stopBatch(this.eventData(e).vertexAdded);
      return;
    }
    const verticesRemoved = edgeView.removeRedundantLinearVertices({
      ui: true,
      toolId: this.cid
    });
    if (verticesRemoved) {
      this.render();
    }
    this.blur();
    this.stopBatch(this.eventData(e).vertexAdded);
    const { e: evt, x, y } = this.getMouseEventArgs(e);
    if (!this.options.stopPropagation) {
      edgeView.notifyMouseUp(evt, x, y);
      const { start } = this.eventData(evt);
      if (start) {
        const { x: startX, y: startY } = start;
        if (startX === x && startY === y) {
          edgeView.onClick(evt, x, y);
        }
      }
    }
    edgeView.checkMouseleave(evt);
    options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });
  }
  snapVertex(vertex, index2) {
    const snapRadius = this.options.snapRadius || 0;
    if (snapRadius > 0) {
      const neighbors = this.getNeighborPoints(index2);
      const prev = neighbors.prev;
      const next = neighbors.next;
      if (Math.abs(vertex.x - prev.x) < snapRadius) {
        vertex.x = prev.x;
      } else if (Math.abs(vertex.x - next.x) < snapRadius) {
        vertex.x = next.x;
      }
      if (Math.abs(vertex.y - prev.y) < snapRadius) {
        vertex.y = neighbors.prev.y;
      } else if (Math.abs(vertex.y - next.y) < snapRadius) {
        vertex.y = next.y;
      }
    }
  }
  onHandleRemove({ handle, e }) {
    if (this.options.removable) {
      const index2 = handle.options.index;
      const edgeView = this.cellView;
      edgeView.cell.removeVertexAt(index2, { ui: true });
      if (this.options.addable) {
        this.updatePath();
      }
      edgeView.checkMouseleave(this.normalizeEvent(e));
    }
  }
  allowAddVertex(e) {
    const guard = this.guard(e);
    const addable = this.options.addable && this.cellView.can("vertexAddable");
    const matchModifiers = this.options.modifiers ? ModifierKey.isMatch(e, this.options.modifiers) : true;
    return !guard && addable && matchModifiers;
  }
  onPathMouseDown(evt) {
    const edgeView = this.cellView;
    if (!this.allowAddVertex(evt)) {
      return;
    }
    evt.stopPropagation();
    evt.preventDefault();
    const e = this.normalizeEvent(evt);
    const vertex = this.graph.snapToGrid(e.clientX, e.clientY).toJSON();
    edgeView.cell.startBatch("add-vertex", { ui: true, toolId: this.cid });
    const index2 = edgeView.getVertexIndex(vertex.x, vertex.y);
    this.snapVertex(vertex, index2);
    edgeView.cell.insertVertex(vertex, index2, {
      ui: true,
      toolId: this.cid
    });
    this.render();
    const handle = this.handles[index2];
    this.eventData(e, { vertexAdded: true });
    handle.onMouseDown(e);
  }
  onRemove() {
    this.resetHandles();
  }
};
(function(Vertices2) {
  class Handle extends View {
    get graph() {
      return this.options.graph;
    }
    constructor(options) {
      super();
      this.options = options;
      this.render();
      this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown",
        dblclick: "onDoubleClick"
      });
    }
    render() {
      this.container = View.createElement("circle", true);
      const attrs = this.options.attrs;
      if (typeof attrs === "function") {
        const defaults5 = Vertices2.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, defaults5.attrs), attrs(this)));
      } else {
        this.setAttrs(attrs);
      }
      this.addClass(this.prefixClassName("edge-tool-vertex"));
    }
    updatePosition(x, y) {
      this.setAttrs({ cx: x, cy: y });
    }
    onMouseDown(evt) {
      if (this.options.guard(evt)) {
        return;
      }
      evt.stopPropagation();
      evt.preventDefault();
      this.graph.view.undelegateEvents();
      this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, evt.data);
      this.emit("change", { e: evt, handle: this });
    }
    onMouseMove(evt) {
      this.emit("changing", { e: evt, handle: this });
    }
    onMouseUp(evt) {
      this.emit("changed", { e: evt, handle: this });
      this.undelegateDocumentEvents();
      this.graph.view.delegateEvents();
    }
    onDoubleClick(evt) {
      this.emit("remove", { e: evt, handle: this });
    }
  }
  Vertices2.Handle = Handle;
})(Vertices || (Vertices = {}));
(function(Vertices2) {
  const pathClassName = Config.prefix("edge-tool-vertex-path");
  Vertices2.config({
    name: "vertices",
    snapRadius: 20,
    addable: true,
    removable: true,
    removeRedundancies: true,
    stopPropagation: true,
    attrs: {
      r: 6,
      fill: "#333",
      stroke: "#fff",
      cursor: "move",
      "stroke-width": 2
    },
    createHandle: (options) => new Vertices2.Handle(options),
    markup: [
      {
        tagName: "path",
        selector: "connection",
        className: pathClassName,
        attrs: {
          fill: "none",
          stroke: "transparent",
          "stroke-width": 10,
          cursor: "pointer"
        }
      }
    ],
    events: {
      [`mousedown .${pathClassName}`]: "onPathMouseDown",
      [`touchstart .${pathClassName}`]: "onPathMouseDown"
    }
  });
})(Vertices || (Vertices = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/tool/segments.js
var Segments = class extends ToolsView.ToolItem {
  constructor() {
    super(...arguments);
    this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  update() {
    this.render();
    return this;
  }
  onRender() {
    main_exports3.addClass(this.container, this.prefixClassName("edge-tool-segments"));
    this.resetHandles();
    const edgeView = this.cellView;
    const vertices = [...this.vertices];
    vertices.unshift(edgeView.sourcePoint);
    vertices.push(edgeView.targetPoint);
    for (let i = 0, l = vertices.length; i < l - 1; i += 1) {
      const vertex = vertices[i];
      const nextVertex = vertices[i + 1];
      const handle = this.renderHandle(vertex, nextVertex, i);
      this.stamp(handle.container);
      this.handles.push(handle);
    }
    return this;
  }
  renderHandle(vertex, nextVertex, index2) {
    const handle = this.options.createHandle({
      index: index2,
      graph: this.graph,
      guard: (evt) => this.guard(evt),
      attrs: this.options.attrs || {}
    });
    if (this.options.processHandle) {
      this.options.processHandle(handle);
    }
    this.updateHandle(handle, vertex, nextVertex);
    this.container.appendChild(handle.container);
    this.startHandleListening(handle);
    return handle;
  }
  startHandleListening(handle) {
    handle.on("change", this.onHandleChange, this);
    handle.on("changing", this.onHandleChanging, this);
    handle.on("changed", this.onHandleChanged, this);
  }
  stopHandleListening(handle) {
    handle.off("change", this.onHandleChange, this);
    handle.off("changing", this.onHandleChanging, this);
    handle.off("changed", this.onHandleChanged, this);
  }
  resetHandles() {
    const handles = this.handles;
    this.handles = [];
    if (handles) {
      handles.forEach((handle) => {
        this.stopHandleListening(handle);
        handle.remove();
      });
    }
  }
  shiftHandleIndexes(delta) {
    const handles = this.handles;
    for (let i = 0, n = handles.length; i < n; i += 1) {
      handles[i].options.index += delta;
    }
  }
  resetAnchor(type, anchor2) {
    const edge = this.cellView.cell;
    const options = {
      ui: true,
      toolId: this.cid
    };
    if (anchor2) {
      edge.prop([type, "anchor"], anchor2, options);
    } else {
      edge.removeProp([type, "anchor"], options);
    }
  }
  snapHandle(handle, position2, data2) {
    const axis = handle.options.axis;
    const index2 = handle.options.index;
    const edgeView = this.cellView;
    const edge = edgeView.cell;
    const vertices = edge.getVertices();
    const prev = vertices[index2 - 2] || data2.sourceAnchor;
    const next = vertices[index2 + 1] || data2.targetAnchor;
    const snapRadius = this.options.snapRadius;
    if (Math.abs(position2[axis] - prev[axis]) < snapRadius) {
      position2[axis] = prev[axis];
    } else if (Math.abs(position2[axis] - next[axis]) < snapRadius) {
      position2[axis] = next[axis];
    }
    return position2;
  }
  onHandleChanging({ handle, e }) {
    const graph = this.graph;
    const options = this.options;
    const edgeView = this.cellView;
    const anchorFn = options.anchor;
    const axis = handle.options.axis;
    const index2 = handle.options.index - 1;
    const data2 = this.getEventData(e);
    const evt = this.normalizeEvent(e);
    const coords = graph.snapToGrid(evt.clientX, evt.clientY);
    const position2 = this.snapHandle(handle, coords.clone(), data2);
    const vertices = object_exports.cloneDeep(this.vertices);
    let vertex = vertices[index2];
    let nextVertex = vertices[index2 + 1];
    const sourceView = edgeView.sourceView;
    const sourceBBox = edgeView.sourceBBox;
    let changeSourceAnchor = false;
    let deleteSourceAnchor = false;
    if (!vertex) {
      vertex = edgeView.sourceAnchor.toJSON();
      vertex[axis] = position2[axis];
      if (sourceBBox.containsPoint(vertex)) {
        changeSourceAnchor = true;
      } else {
        vertices.unshift(vertex);
        this.shiftHandleIndexes(1);
        deleteSourceAnchor = true;
      }
    } else if (index2 === 0) {
      if (sourceBBox.containsPoint(vertex)) {
        vertices.shift();
        this.shiftHandleIndexes(-1);
        changeSourceAnchor = true;
      } else {
        vertex[axis] = position2[axis];
        deleteSourceAnchor = true;
      }
    } else {
      vertex[axis] = position2[axis];
    }
    if (typeof anchorFn === "function" && sourceView) {
      if (changeSourceAnchor) {
        const sourceAnchorPosition = data2.sourceAnchor.clone();
        sourceAnchorPosition[axis] = position2[axis];
        const sourceAnchor = main_exports.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, "source", edgeView, this);
        this.resetAnchor("source", sourceAnchor);
      }
      if (deleteSourceAnchor) {
        this.resetAnchor("source", data2.sourceAnchorDef);
      }
    }
    const targetView = edgeView.targetView;
    const targetBBox = edgeView.targetBBox;
    let changeTargetAnchor = false;
    let deleteTargetAnchor = false;
    if (!nextVertex) {
      nextVertex = edgeView.targetAnchor.toJSON();
      nextVertex[axis] = position2[axis];
      if (targetBBox.containsPoint(nextVertex)) {
        changeTargetAnchor = true;
      } else {
        vertices.push(nextVertex);
        deleteTargetAnchor = true;
      }
    } else if (index2 === vertices.length - 2) {
      if (targetBBox.containsPoint(nextVertex)) {
        vertices.pop();
        changeTargetAnchor = true;
      } else {
        nextVertex[axis] = position2[axis];
        deleteTargetAnchor = true;
      }
    } else {
      nextVertex[axis] = position2[axis];
    }
    if (typeof anchorFn === "function" && targetView) {
      if (changeTargetAnchor) {
        const targetAnchorPosition = data2.targetAnchor.clone();
        targetAnchorPosition[axis] = position2[axis];
        const targetAnchor = main_exports.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, "target", edgeView, this);
        this.resetAnchor("target", targetAnchor);
      }
      if (deleteTargetAnchor) {
        this.resetAnchor("target", data2.targetAnchorDef);
      }
    }
    if (!Point.equalPoints(vertices, this.vertices)) {
      this.cellView.cell.setVertices(vertices, { ui: true, toolId: this.cid });
    }
    this.updateHandle(handle, vertex, nextVertex, 0);
    if (!options.stopPropagation) {
      edgeView.notifyMouseMove(evt, coords.x, coords.y);
    }
  }
  onHandleChange({ handle, e }) {
    const options = this.options;
    const handles = this.handles;
    const edgeView = this.cellView;
    const index2 = handle.options.index;
    if (!Array.isArray(handles)) {
      return;
    }
    for (let i = 0, n = handles.length; i < n; i += 1) {
      if (i !== index2) {
        handles[i].hide();
      }
    }
    this.focus();
    this.setEventData(e, {
      sourceAnchor: edgeView.sourceAnchor.clone(),
      targetAnchor: edgeView.targetAnchor.clone(),
      sourceAnchorDef: object_exports.cloneDeep(this.cell.prop(["source", "anchor"])),
      targetAnchorDef: object_exports.cloneDeep(this.cell.prop(["target", "anchor"]))
    });
    this.cell.startBatch("move-segment", { ui: true, toolId: this.cid });
    if (!options.stopPropagation) {
      const normalizedEvent = this.normalizeEvent(e);
      const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
      edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);
    }
  }
  onHandleChanged({ e }) {
    const options = this.options;
    const edgeView = this.cellView;
    if (options.removeRedundancies) {
      edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });
    }
    const normalizedEvent = this.normalizeEvent(e);
    const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
    this.render();
    this.blur();
    this.cell.stopBatch("move-segment", { ui: true, toolId: this.cid });
    if (!options.stopPropagation) {
      edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);
    }
    edgeView.checkMouseleave(normalizedEvent);
    options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });
  }
  updateHandle(handle, vertex, nextVertex, offset3 = 0) {
    const precision = this.options.precision || 0;
    const vertical = Math.abs(vertex.x - nextVertex.x) < precision;
    const horizontal = Math.abs(vertex.y - nextVertex.y) < precision;
    if (vertical || horizontal) {
      const segmentLine = new Line(vertex, nextVertex);
      const length2 = segmentLine.length();
      if (length2 < this.options.threshold) {
        handle.hide();
      } else {
        const position2 = segmentLine.getCenter();
        const axis = vertical ? "x" : "y";
        position2[axis] += offset3 || 0;
        const angle = segmentLine.vector().vectorAngle(new Point(1, 0));
        handle.updatePosition(position2.x, position2.y, angle, this.cellView);
        handle.show();
        handle.options.axis = axis;
      }
    } else {
      handle.hide();
    }
  }
  onRemove() {
    this.resetHandles();
  }
};
(function(Segments2) {
  class Handle extends View {
    constructor(options) {
      super();
      this.options = options;
      this.render();
      this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown"
      });
    }
    render() {
      this.container = View.createElement("rect", true);
      const attrs = this.options.attrs;
      if (typeof attrs === "function") {
        const defaults5 = Segments2.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, defaults5.attrs), attrs(this)));
      } else {
        this.setAttrs(attrs);
      }
      this.addClass(this.prefixClassName("edge-tool-segment"));
    }
    updatePosition(x, y, angle, view) {
      const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y);
      let matrix = main_exports3.createSVGMatrix().translate(p.x, p.y);
      if (!p.equals({ x, y })) {
        const line2 = new Line(x, y, p.x, p.y);
        let deg = line2.vector().vectorAngle(new Point(1, 0));
        if (deg !== 0) {
          deg += 90;
        }
        matrix = matrix.rotate(deg);
      } else {
        matrix = matrix.rotate(angle);
      }
      this.setAttrs({
        transform: main_exports3.matrixToTransformString(matrix),
        cursor: angle % 180 === 0 ? "row-resize" : "col-resize"
      });
    }
    onMouseDown(evt) {
      if (this.options.guard(evt)) {
        return;
      }
      this.trigger("change", { e: evt, handle: this });
      evt.stopPropagation();
      evt.preventDefault();
      this.options.graph.view.undelegateEvents();
      this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, evt.data);
    }
    onMouseMove(evt) {
      this.emit("changing", { e: evt, handle: this });
    }
    onMouseUp(evt) {
      this.emit("changed", { e: evt, handle: this });
      this.undelegateDocumentEvents();
      this.options.graph.view.delegateEvents();
    }
    show() {
      this.container.style.display = "";
    }
    hide() {
      this.container.style.display = "none";
    }
  }
  Segments2.Handle = Handle;
})(Segments || (Segments = {}));
(function(Segments2) {
  Segments2.config({
    name: "segments",
    precision: 0.5,
    threshold: 40,
    snapRadius: 10,
    stopPropagation: true,
    removeRedundancies: true,
    attrs: {
      width: 20,
      height: 8,
      x: -10,
      y: -4,
      rx: 4,
      ry: 4,
      fill: "#333",
      stroke: "#fff",
      "stroke-width": 2
    },
    createHandle: (options) => new Segments2.Handle(options),
    anchor: getAnchor
  });
})(Segments || (Segments = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/tool/anchor.js
var Anchor = class extends ToolsView.ToolItem {
  get type() {
    return this.options.type;
  }
  onRender() {
    main_exports3.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`));
    this.toggleArea(false);
    this.update();
  }
  update() {
    const type = this.type;
    const edgeView = this.cellView;
    const terminalView = edgeView.getTerminalView(type);
    if (terminalView) {
      this.updateAnchor();
      this.updateArea();
      this.container.style.display = "";
    } else {
      this.container.style.display = "none";
    }
    return this;
  }
  updateAnchor() {
    const childNodes = this.childNodes;
    if (!childNodes) {
      return;
    }
    const anchorNode = childNodes.anchor;
    if (!anchorNode) {
      return;
    }
    const type = this.type;
    const edgeView = this.cellView;
    const options = this.options;
    const position2 = edgeView.getTerminalAnchor(type);
    const customAnchor = edgeView.cell.prop([type, "anchor"]);
    anchorNode.setAttribute("transform", `translate(${position2.x}, ${position2.y})`);
    const anchorAttrs = customAnchor ? options.customAnchorAttrs : options.defaultAnchorAttrs;
    if (anchorAttrs) {
      Object.keys(anchorAttrs).forEach((attrName) => {
        anchorNode.setAttribute(attrName, anchorAttrs[attrName]);
      });
    }
  }
  updateArea() {
    const childNodes = this.childNodes;
    if (!childNodes) {
      return;
    }
    const areaNode = childNodes.area;
    if (!areaNode) {
      return;
    }
    const type = this.type;
    const edgeView = this.cellView;
    const terminalView = edgeView.getTerminalView(type);
    if (terminalView) {
      const terminalCell = terminalView.cell;
      const magnet = edgeView.getTerminalMagnet(type);
      let padding = this.options.areaPadding || 0;
      if (!Number.isFinite(padding)) {
        padding = 0;
      }
      let bbox2;
      let angle;
      let center2;
      if (terminalView.isEdgeElement(magnet)) {
        bbox2 = terminalView.getBBox();
        angle = 0;
        center2 = bbox2.getCenter();
      } else {
        bbox2 = terminalView.getUnrotatedBBoxOfElement(magnet);
        angle = terminalCell.getAngle();
        center2 = bbox2.getCenter();
        if (angle) {
          center2.rotate(-angle, terminalCell.getBBox().getCenter());
        }
      }
      bbox2.inflate(padding);
      main_exports3.attr(areaNode, {
        x: -bbox2.width / 2,
        y: -bbox2.height / 2,
        width: bbox2.width,
        height: bbox2.height,
        transform: `translate(${center2.x}, ${center2.y}) rotate(${angle})`
      });
    }
  }
  toggleArea(visible) {
    if (this.childNodes) {
      const elem = this.childNodes.area;
      if (elem) {
        elem.style.display = visible ? "" : "none";
      }
    }
  }
  onMouseDown(evt) {
    if (this.guard(evt)) {
      return;
    }
    evt.stopPropagation();
    evt.preventDefault();
    this.graph.view.undelegateEvents();
    if (this.options.documentEvents) {
      this.delegateDocumentEvents(this.options.documentEvents);
    }
    this.focus();
    this.toggleArea(this.options.restrictArea);
    this.cell.startBatch("move-anchor", {
      ui: true,
      toolId: this.cid
    });
  }
  resetAnchor(anchor2) {
    const type = this.type;
    const cell = this.cell;
    if (anchor2) {
      cell.prop([type, "anchor"], anchor2, {
        rewrite: true,
        ui: true,
        toolId: this.cid
      });
    } else {
      cell.removeProp([type, "anchor"], {
        ui: true,
        toolId: this.cid
      });
    }
  }
  onMouseMove(evt) {
    const terminalType = this.type;
    const edgeView = this.cellView;
    const terminalView = edgeView.getTerminalView(terminalType);
    if (terminalView == null) {
      return;
    }
    const e = this.normalizeEvent(evt);
    const terminalCell = terminalView.cell;
    const terminalMagnet = edgeView.getTerminalMagnet(terminalType);
    let coords = this.graph.coord.clientToLocalPoint(e.clientX, e.clientY);
    const snapFn = this.options.snap;
    if (typeof snapFn === "function") {
      const tmp = main_exports.call(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
      coords = Point.create(tmp);
    }
    if (this.options.restrictArea) {
      if (terminalView.isEdgeElement(terminalMagnet)) {
        const pointAtConnection = terminalView.getClosestPoint(coords);
        if (pointAtConnection) {
          coords = pointAtConnection;
        }
      } else {
        const bbox2 = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);
        const angle = terminalCell.getAngle();
        const origin = terminalCell.getBBox().getCenter();
        const rotatedCoords = coords.clone().rotate(angle, origin);
        if (!bbox2.containsPoint(rotatedCoords)) {
          coords = bbox2.getNearestPointToPoint(rotatedCoords).rotate(-angle, origin);
        }
      }
    }
    let anchor2;
    const anchorFn = this.options.anchor;
    if (typeof anchorFn === "function") {
      anchor2 = main_exports.call(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
    }
    this.resetAnchor(anchor2);
    this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMouseUp(evt) {
    this.graph.view.delegateEvents();
    this.undelegateDocumentEvents();
    this.blur();
    this.toggleArea(false);
    const edgeView = this.cellView;
    if (this.options.removeRedundancies) {
      edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });
    }
    this.cell.stopBatch("move-anchor", { ui: true, toolId: this.cid });
  }
  onDblClick() {
    const anchor2 = this.options.resetAnchor;
    if (anchor2) {
      this.resetAnchor(anchor2 === true ? void 0 : anchor2);
    }
    this.update();
  }
};
(function(Anchor2) {
  Anchor2.config({
    tagName: "g",
    markup: [
      {
        tagName: "circle",
        selector: "anchor",
        attrs: {
          cursor: "pointer"
        }
      },
      {
        tagName: "rect",
        selector: "area",
        attrs: {
          "pointer-events": "none",
          fill: "none",
          stroke: "#33334F",
          "stroke-dasharray": "2,4",
          rx: 5,
          ry: 5
        }
      }
    ],
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown",
      dblclick: "onDblClick"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    },
    customAnchorAttrs: {
      "stroke-width": 4,
      stroke: "#33334F",
      fill: "#FFFFFF",
      r: 5
    },
    defaultAnchorAttrs: {
      "stroke-width": 2,
      stroke: "#FFFFFF",
      fill: "#33334F",
      r: 6
    },
    areaPadding: 6,
    snapRadius: 10,
    resetAnchor: true,
    restrictArea: true,
    removeRedundancies: true,
    anchor: getAnchor,
    snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {
      const snapRadius = toolView.options.snapRadius || 0;
      const isSource = terminalType === "source";
      const refIndex = isSource ? 0 : -1;
      const ref2 = this.cell.getVertexAt(refIndex) || this.getTerminalAnchor(isSource ? "target" : "source");
      if (ref2) {
        if (Math.abs(ref2.x - pos.x) < snapRadius)
          pos.x = ref2.x;
        if (Math.abs(ref2.y - pos.y) < snapRadius)
          pos.y = ref2.y;
      }
      return pos;
    }
  });
})(Anchor || (Anchor = {}));
var SourceAnchor = Anchor.define({
  name: "source-anchor",
  type: "source"
});
var TargetAnchor = Anchor.define({
  name: "target-anchor",
  type: "target"
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/tool/arrowhead.js
var __rest13 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Arrowhead = class extends ToolsView.ToolItem {
  get type() {
    return this.options.type;
  }
  get ratio() {
    return this.options.ratio;
  }
  init() {
    if (this.options.attrs) {
      const _a = this.options.attrs, { class: className3 } = _a, attrs = __rest13(_a, ["class"]);
      this.setAttrs(attrs, this.container);
      if (className3) {
        main_exports3.addClass(this.container, className3);
      }
    }
  }
  onRender() {
    main_exports3.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-arrowhead`));
    this.update();
  }
  update() {
    const ratio2 = this.ratio;
    const edgeView = this.cellView;
    const tangent = edgeView.getTangentAtRatio(ratio2);
    const position2 = tangent ? tangent.start : edgeView.getPointAtRatio(ratio2);
    const angle = tangent && tangent.vector().vectorAngle(new Point(1, 0)) || 0;
    if (!position2) {
      return this;
    }
    const matrix = main_exports3.createSVGMatrix().translate(position2.x, position2.y).rotate(angle);
    main_exports3.transform(this.container, matrix, { absolute: true });
    return this;
  }
  onMouseDown(evt) {
    if (this.guard(evt)) {
      return;
    }
    evt.stopPropagation();
    evt.preventDefault();
    const edgeView = this.cellView;
    if (edgeView.can("arrowheadMovable")) {
      edgeView.cell.startBatch("move-arrowhead", {
        ui: true,
        toolId: this.cid
      });
      const coords = this.graph.snapToGrid(evt.clientX, evt.clientY);
      const data2 = edgeView.prepareArrowheadDragging(this.type, {
        x: coords.x,
        y: coords.y,
        options: Object.assign(Object.assign({}, this.options), { toolId: this.cid })
      });
      this.cellView.setEventData(evt, data2);
      this.delegateDocumentEvents(this.options.documentEvents, evt.data);
      edgeView.graph.view.undelegateEvents();
      this.container.style.pointerEvents = "none";
    }
    this.focus();
  }
  onMouseMove(evt) {
    const e = this.normalizeEvent(evt);
    const coords = this.graph.snapToGrid(e.clientX, e.clientY);
    this.cellView.onMouseMove(e, coords.x, coords.y);
    this.update();
  }
  onMouseUp(evt) {
    this.undelegateDocumentEvents();
    const e = this.normalizeEvent(evt);
    const edgeView = this.cellView;
    const coords = this.graph.snapToGrid(e.clientX, e.clientY);
    edgeView.onMouseUp(e, coords.x, coords.y);
    this.graph.view.delegateEvents();
    this.blur();
    this.container.style.pointerEvents = "";
    edgeView.cell.stopBatch("move-arrowhead", {
      ui: true,
      toolId: this.cid
    });
  }
};
(function(Arrowhead2) {
  Arrowhead2.config({
    tagName: "path",
    isSVGElement: true,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    }
  });
})(Arrowhead || (Arrowhead = {}));
var SourceArrowhead = Arrowhead.define({
  name: "source-arrowhead",
  type: "source",
  ratio: 0,
  attrs: {
    d: "M 10 -8 -10 0 10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
});
var TargetArrowhead = Arrowhead.define({
  name: "target-arrowhead",
  type: "target",
  ratio: 1,
  attrs: {
    d: "M -10 -8 10 0 -10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/tool/editor.js
var CellEditor = class extends ToolsView.ToolItem {
  constructor() {
    super(...arguments);
    this.labelIndex = -1;
    this.distance = 0.5;
    this.dblClick = this.onCellDblClick.bind(this);
  }
  onRender() {
    const cellView = this.cellView;
    if (cellView) {
      cellView.on("cell:dblclick", this.dblClick);
    }
  }
  createElement() {
    const classNames = [
      this.prefixClassName(`${this.cell.isEdge() ? "edge" : "node"}-tool-editor`),
      this.prefixClassName("cell-tool-editor")
    ];
    this.editor = ToolsView.createElement("div", false);
    this.addClass(classNames, this.editor);
    this.editor.contentEditable = "true";
    this.container.appendChild(this.editor);
  }
  removeElement() {
    this.undelegateDocumentEvents();
    if (this.editor) {
      this.container.removeChild(this.editor);
      this.editor = null;
    }
  }
  updateEditor() {
    const { cell, editor } = this;
    if (!editor) {
      return;
    }
    const { style: style2 } = editor;
    if (cell.isNode()) {
      this.updateNodeEditorTransform();
    } else if (cell.isEdge()) {
      this.updateEdgeEditorTransform();
    }
    const { attrs } = this.options;
    style2.fontSize = `${attrs.fontSize}px`;
    style2.fontFamily = attrs.fontFamily;
    style2.color = attrs.color;
    style2.backgroundColor = attrs.backgroundColor;
    const text3 = this.getCellText() || "";
    editor.innerText = text3;
    this.setCellText("");
    return this;
  }
  updateNodeEditorTransform() {
    const { graph, cell, editor } = this;
    if (!editor) {
      return;
    }
    let pos = Point.create();
    let minWidth = 20;
    let translate2 = "";
    let { x, y } = this.options;
    const { width: width2, height: height2 } = this.options;
    if (typeof x !== "undefined" && typeof y !== "undefined") {
      const bbox2 = cell.getBBox();
      x = number_exports.normalizePercentage(x, bbox2.width);
      y = number_exports.normalizePercentage(y, bbox2.height);
      pos = bbox2.topLeft.translate(x, y);
      minWidth = bbox2.width - x * 2;
    } else {
      const bbox2 = cell.getBBox();
      pos = bbox2.center;
      minWidth = bbox2.width - 4;
      translate2 = "translate(-50%, -50%)";
    }
    const scale2 = graph.scale();
    const { style: style2 } = editor;
    pos = graph.localToGraph(pos);
    style2.left = `${pos.x}px`;
    style2.top = `${pos.y}px`;
    style2.transform = `scale(${scale2.sx}, ${scale2.sy}) ${translate2}`;
    style2.minWidth = `${minWidth}px`;
    if (typeof width2 === "number") {
      style2.width = `${width2}px`;
    }
    if (typeof height2 === "number") {
      style2.height = `${height2}px`;
    }
  }
  updateEdgeEditorTransform() {
    if (!this.event) {
      return;
    }
    const { graph, editor } = this;
    if (!editor) {
      return;
    }
    let pos = Point.create();
    let minWidth = 20;
    const { style: style2 } = editor;
    const target = this.event.target;
    const parent2 = target.parentElement;
    const isEdgeLabel = parent2 && main_exports3.hasClass(parent2, this.prefixClassName("edge-label"));
    if (isEdgeLabel) {
      const index2 = parent2.getAttribute("data-index") || "0";
      this.labelIndex = parseInt(index2, 10);
      const matrix = parent2.getAttribute("transform");
      const { translation } = main_exports3.parseTransformString(matrix);
      pos = new Point(translation.tx, translation.ty);
      minWidth = Util2.getBBox(target).width;
    } else {
      if (!this.options.labelAddable) {
        return this;
      }
      pos = graph.clientToLocal(Point.create(this.event.clientX, this.event.clientY));
      const view = this.cellView;
      const d = view.path.closestPointLength(pos);
      this.distance = d;
      this.labelIndex = -1;
    }
    pos = graph.localToGraph(pos);
    const scale2 = graph.scale();
    style2.left = `${pos.x}px`;
    style2.top = `${pos.y}px`;
    style2.minWidth = `${minWidth}px`;
    style2.transform = `scale(${scale2.sx}, ${scale2.sy}) translate(-50%, -50%)`;
  }
  onDocumentMouseUp(e) {
    if (this.editor && e.target !== this.editor) {
      const value = this.editor.innerText.replace(/\n$/, "") || "";
      this.setCellText(value !== "" ? value : null);
      this.removeElement();
    }
  }
  onCellDblClick({ e }) {
    if (!this.editor) {
      e.stopPropagation();
      this.removeElement();
      this.event = e;
      this.createElement();
      this.updateEditor();
      this.autoFocus();
      this.delegateDocumentEvents(this.options.documentEvents);
    }
  }
  onMouseDown(e) {
    e.stopPropagation();
  }
  autoFocus() {
    setTimeout(() => {
      if (this.editor) {
        this.editor.focus();
        this.selectText();
      }
    });
  }
  selectText() {
    if (window.getSelection && this.editor) {
      const range2 = document.createRange();
      const selection = window.getSelection();
      range2.selectNodeContents(this.editor);
      selection.removeAllRanges();
      selection.addRange(range2);
    }
  }
  getCellText() {
    const { getText } = this.options;
    if (typeof getText === "function") {
      return main_exports.call(getText, this.cellView, {
        cell: this.cell,
        index: this.labelIndex
      });
    }
    if (typeof getText === "string") {
      if (this.cell.isNode()) {
        return this.cell.attr(getText);
      }
      if (this.cell.isEdge()) {
        if (this.labelIndex !== -1) {
          return this.cell.prop(`labels/${this.labelIndex}/attrs/${getText}`);
        }
      }
    }
  }
  setCellText(value) {
    const setText = this.options.setText;
    if (typeof setText === "function") {
      main_exports.call(setText, this.cellView, {
        cell: this.cell,
        value,
        index: this.labelIndex,
        distance: this.distance
      });
      return;
    }
    if (typeof setText === "string") {
      if (this.cell.isNode()) {
        if (value !== null) {
          this.cell.attr(setText, value);
        }
        return;
      }
      if (this.cell.isEdge()) {
        const edge = this.cell;
        if (this.labelIndex === -1) {
          if (value) {
            const newLabel = {
              position: {
                distance: this.distance
              },
              attrs: {}
            };
            object_exports.setByPath(newLabel, `attrs/${setText}`, value);
            edge.appendLabel(newLabel);
          }
        } else {
          if (value !== null) {
            edge.prop(`labels/${this.labelIndex}/attrs/${setText}`, value);
          } else if (typeof this.labelIndex === "number") {
            edge.removeLabelAt(this.labelIndex);
          }
        }
      }
    }
  }
  onRemove() {
    const cellView = this.cellView;
    if (cellView) {
      cellView.off("cell:dblclick", this.dblClick);
    }
    this.removeElement();
  }
};
(function(CellEditor2) {
  CellEditor2.config({
    tagName: "div",
    isSVGElement: false,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mouseup: "onDocumentMouseUp",
      touchend: "onDocumentMouseUp",
      touchcancel: "onDocumentMouseUp"
    }
  });
})(CellEditor || (CellEditor = {}));
(function(CellEditor2) {
  CellEditor2.NodeEditor = CellEditor2.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    getText: "text/text",
    setText: "text/text"
  });
  CellEditor2.EdgeEditor = CellEditor2.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    labelAddable: true,
    getText: "label/text",
    setText: "label/text"
  });
})(CellEditor || (CellEditor = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/tool/index.js
var __rest14 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var NodeTool;
(function(NodeTool2) {
  NodeTool2.presets = {
    boundary: Boundary,
    button: Button,
    "button-remove": Button.Remove,
    "node-editor": CellEditor.NodeEditor
  };
  NodeTool2.registry = Registry.create({
    type: "node tool",
    process(name, options) {
      if (typeof options === "function") {
        return options;
      }
      let parent2 = ToolsView.ToolItem;
      const { inherit: inherit2 } = options, others = __rest14(options, ["inherit"]);
      if (inherit2) {
        const base = this.get(inherit2);
        if (base == null) {
          this.onNotFound(inherit2, "inherited");
        } else {
          parent2 = base;
        }
      }
      if (others.name == null) {
        others.name = name;
      }
      return parent2.define.call(parent2, others);
    }
  });
  NodeTool2.registry.register(NodeTool2.presets, true);
})(NodeTool || (NodeTool = {}));
var EdgeTool;
(function(EdgeTool2) {
  EdgeTool2.presets = {
    boundary: Boundary,
    vertices: Vertices,
    segments: Segments,
    button: Button,
    "button-remove": Button.Remove,
    "source-anchor": SourceAnchor,
    "target-anchor": TargetAnchor,
    "source-arrowhead": SourceArrowhead,
    "target-arrowhead": TargetArrowhead,
    "edge-editor": CellEditor.EdgeEditor
  };
  EdgeTool2.registry = Registry.create({
    type: "edge tool",
    process(name, options) {
      if (typeof options === "function") {
        return options;
      }
      let parent2 = ToolsView.ToolItem;
      const { inherit: inherit2 } = options, others = __rest14(options, ["inherit"]);
      if (inherit2) {
        const base = this.get(inherit2);
        if (base == null) {
          this.onNotFound(inherit2, "inherited");
        } else {
          parent2 = base;
        }
      }
      if (others.name == null) {
        others.name = name;
      }
      return parent2.define.call(parent2, others);
    }
  });
  EdgeTool2.registry.register(EdgeTool2.presets, true);
})(EdgeTool || (EdgeTool = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/node-anchor/main.js
var main_exports13 = {};
__export(main_exports13, {
  bottom: () => bottom3,
  bottomLeft: () => bottomLeft,
  bottomRight: () => bottomRight,
  center: () => center,
  left: () => left3,
  midSide: () => midSide,
  nodeCenter: () => nodeCenter,
  orth: () => orth,
  right: () => right3,
  top: () => top3,
  topLeft: () => topLeft,
  topRight: () => topRight
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/node-anchor/bbox.js
var center = createBBoxAnchor("center");
var top3 = createBBoxAnchor("topCenter");
var bottom3 = createBBoxAnchor("bottomCenter");
var left3 = createBBoxAnchor("leftMiddle");
var right3 = createBBoxAnchor("rightMiddle");
var topLeft = createBBoxAnchor("topLeft");
var topRight = createBBoxAnchor("topRight");
var bottomLeft = createBBoxAnchor("bottomLeft");
var bottomRight = createBBoxAnchor("bottomRight");
function createBBoxAnchor(method2) {
  return function(view, magnet, ref2, options = {}) {
    const bbox2 = options.rotate ? view.getUnrotatedBBoxOfElement(magnet) : view.getBBoxOfElement(magnet);
    const result2 = bbox2[method2];
    result2.x += number_exports.normalizePercentage(options.dx, bbox2.width);
    result2.y += number_exports.normalizePercentage(options.dy, bbox2.height);
    const cell = view.cell;
    return options.rotate ? result2.rotate(-cell.getAngle(), cell.getBBox().getCenter()) : result2;
  };
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/node-anchor/util.js
function resolve(fn) {
  return function(view, magnet, ref2, options) {
    if (ref2 instanceof Element) {
      const refView = this.graph.findViewByElem(ref2);
      let refPoint;
      if (refView) {
        if (refView.isEdgeElement(ref2)) {
          const distance = options.fixedAt != null ? options.fixedAt : "50%";
          refPoint = getPointAtEdge(refView, distance);
        } else {
          refPoint = refView.getBBoxOfElement(ref2).getCenter();
        }
      } else {
        refPoint = new Point();
      }
      return fn.call(this, view, magnet, refPoint, options);
    }
    return fn.apply(this, arguments);
  };
}
function getPointAtEdge(edgeView, value) {
  const isPercentage2 = number_exports.isPercentage(value);
  const num = typeof value === "string" ? parseFloat(value) : value;
  if (isPercentage2) {
    return edgeView.getPointAtRatio(num / 100);
  }
  return edgeView.getPointAtLength(num);
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/node-anchor/orth.js
var orthogonal = function(view, magnet, refPoint, options) {
  const angle = Angle.normalize(view.cell.getAngle());
  const bbox2 = view.getBBoxOfElement(magnet);
  const result2 = bbox2.getCenter();
  const topLeft2 = bbox2.getTopLeft();
  const bottomRight2 = bbox2.getBottomRight();
  let padding = options.padding;
  if (!Number.isFinite(padding)) {
    padding = 0;
  }
  if (topLeft2.y + padding <= refPoint.y && refPoint.y <= bottomRight2.y - padding) {
    const dy = refPoint.y - result2.y;
    result2.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(Angle.toRad(angle));
    result2.y += dy;
  } else if (topLeft2.x + padding <= refPoint.x && refPoint.x <= bottomRight2.x - padding) {
    const dx = refPoint.x - result2.x;
    result2.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle));
    result2.x += dx;
  }
  return result2;
};
var orth = resolve(orthogonal);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/node-anchor/node-center.js
var nodeCenter = function(view, magnet, ref2, options, endType) {
  const result2 = view.cell.getConnectionPoint(this.cell, endType);
  if (options.dx || options.dy) {
    result2.translate(options.dx || 0, options.dy || 0);
  }
  return result2;
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/node-anchor/middle-side.js
var middleSide = function(view, magnet, refPoint, options) {
  let bbox2;
  let angle = 0;
  let center2;
  const node = view.cell;
  if (options.rotate) {
    bbox2 = view.getUnrotatedBBoxOfElement(magnet);
    center2 = node.getBBox().getCenter();
    angle = node.getAngle();
  } else {
    bbox2 = view.getBBoxOfElement(magnet);
  }
  const padding = options.padding;
  if (padding != null && Number.isFinite(padding)) {
    bbox2.inflate(padding);
  }
  if (options.rotate) {
    refPoint.rotate(angle, center2);
  }
  const side = bbox2.getNearestSideToPoint(refPoint);
  let result2;
  switch (side) {
    case "left":
      result2 = bbox2.getLeftMiddle();
      break;
    case "right":
      result2 = bbox2.getRightMiddle();
      break;
    case "top":
      result2 = bbox2.getTopCenter();
      break;
    case "bottom":
      result2 = bbox2.getBottomCenter();
      break;
    default:
      break;
  }
  const direction = options.direction;
  if (direction === "H") {
    if (side === "top" || side === "bottom") {
      if (refPoint.x <= bbox2.x + bbox2.width) {
        result2 = bbox2.getLeftMiddle();
      } else {
        result2 = bbox2.getRightMiddle();
      }
    }
  } else if (direction === "V") {
    if (refPoint.y <= bbox2.y + bbox2.height) {
      result2 = bbox2.getTopCenter();
    } else {
      result2 = bbox2.getBottomCenter();
    }
  }
  return options.rotate ? result2.rotate(-angle, center2) : result2;
};
var midSide = resolve(middleSide);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/node-anchor/index.js
var NodeAnchor;
(function(NodeAnchor2) {
  NodeAnchor2.presets = main_exports13;
  NodeAnchor2.registry = Registry.create({
    type: "node endpoint"
  });
  NodeAnchor2.registry.register(NodeAnchor2.presets, true);
})(NodeAnchor || (NodeAnchor = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/edge-anchor/main.js
var main_exports14 = {};
__export(main_exports14, {
  closest: () => closest,
  length: () => length,
  orth: () => orth2,
  ratio: () => ratio
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/edge-anchor/ratio.js
var ratio = function(view, magnet, ref2, options) {
  let ratio2 = options.ratio != null ? options.ratio : 0.5;
  if (ratio2 > 1) {
    ratio2 /= 100;
  }
  return view.getPointAtRatio(ratio2);
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/edge-anchor/length.js
var length = function(view, magnet, ref2, options) {
  const length2 = options.length != null ? options.length : 20;
  return view.getPointAtLength(length2);
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/edge-anchor/closest.js
var getClosestPoint = function(view, magnet, refPoint, options) {
  const closestPoint = view.getClosestPoint(refPoint);
  return closestPoint != null ? closestPoint : new Point();
};
var closest = resolve(getClosestPoint);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/edge-anchor/orth.js
var orthogonal2 = function(view, magnet, refPoint, options) {
  const OFFSET = 1e6;
  const path2 = view.getConnection();
  const segmentSubdivisions = view.getConnectionSubdivisions();
  const vLine = new Line(refPoint.clone().translate(0, OFFSET), refPoint.clone().translate(0, -OFFSET));
  const hLine = new Line(refPoint.clone().translate(OFFSET, 0), refPoint.clone().translate(-OFFSET, 0));
  const vIntersections = vLine.intersect(path2, {
    segmentSubdivisions
  });
  const hIntersections = hLine.intersect(path2, {
    segmentSubdivisions
  });
  const intersections = [];
  if (vIntersections) {
    intersections.push(...vIntersections);
  }
  if (hIntersections) {
    intersections.push(...hIntersections);
  }
  if (intersections.length > 0) {
    return refPoint.closest(intersections);
  }
  if (options.fallbackAt != null) {
    return getPointAtEdge(view, options.fallbackAt);
  }
  return main_exports.call(getClosestPoint, this, view, magnet, refPoint, options);
};
var orth2 = resolve(orthogonal2);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/edge-anchor/index.js
var EdgeAnchor;
(function(EdgeAnchor2) {
  EdgeAnchor2.presets = main_exports14;
  EdgeAnchor2.registry = Registry.create({
    type: "edge endpoint"
  });
  EdgeAnchor2.registry.register(EdgeAnchor2.presets, true);
})(EdgeAnchor || (EdgeAnchor = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-point/main.js
var main_exports15 = {};
__export(main_exports15, {
  anchor: () => anchor,
  bbox: () => bbox,
  boundary: () => boundary,
  rect: () => rect
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-point/util.js
function offset2(p1, p2, offset3) {
  let tx;
  if (typeof offset3 === "object") {
    if (Number.isFinite(offset3.y)) {
      const line2 = new Line(p2, p1);
      const { start, end } = line2.parallel(offset3.y);
      p2 = start;
      p1 = end;
    }
    tx = offset3.x;
  } else {
    tx = offset3;
  }
  if (tx == null || !Number.isFinite(tx)) {
    return p1;
  }
  const length2 = p1.distance(p2);
  if (tx === 0 && length2 > 0) {
    return p1;
  }
  return p1.move(p2, -Math.min(tx, length2 - 1));
}
function getStrokeWidth(magnet) {
  const stroke3 = magnet.getAttribute("stroke-width");
  if (stroke3 === null) {
    return 0;
  }
  return parseFloat(stroke3) || 0;
}
function findShapeNode(magnet) {
  if (magnet == null) {
    return null;
  }
  let node = magnet;
  do {
    let tagName2 = node.tagName;
    if (typeof tagName2 !== "string")
      return null;
    tagName2 = tagName2.toUpperCase();
    if (tagName2 === "G") {
      node = node.firstElementChild;
    } else if (tagName2 === "TITLE") {
      node = node.nextElementSibling;
    } else
      break;
  } while (node);
  return node;
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-point/bbox.js
var bbox = function(line2, view, magnet, options) {
  const bbox2 = view.getBBoxOfElement(magnet);
  if (options.stroked) {
    bbox2.inflate(getStrokeWidth(magnet) / 2);
  }
  const intersections = line2.intersect(bbox2);
  const p = intersections && intersections.length ? line2.start.closest(intersections) : line2.end;
  return offset2(p, line2.start, options.offset);
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-point/rect.js
var rect = function(line2, view, magnet, options, type) {
  const cell = view.cell;
  const angle = cell.isNode() ? cell.getAngle() : 0;
  if (angle === 0) {
    return main_exports.call(bbox, this, line2, view, magnet, options, type);
  }
  const bboxRaw = view.getUnrotatedBBoxOfElement(magnet);
  if (options.stroked) {
    bboxRaw.inflate(getStrokeWidth(magnet) / 2);
  }
  const center2 = bboxRaw.getCenter();
  const lineRaw = line2.clone().rotate(angle, center2);
  const intersections = lineRaw.setLength(1e6).intersect(bboxRaw);
  const p = intersections && intersections.length ? lineRaw.start.closest(intersections).rotate(-angle, center2) : line2.end;
  return offset2(p, line2.start, options.offset);
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-point/boundary.js
var boundary = function(line2, view, magnet, options) {
  let node;
  let intersection2;
  const anchor2 = line2.end;
  const selector = options.selector;
  if (typeof selector === "string") {
    node = view.findOne(selector);
  } else if (Array.isArray(selector)) {
    node = object_exports.getByPath(magnet, selector);
  } else {
    node = findShapeNode(magnet);
  }
  if (!main_exports3.isSVGGraphicsElement(node)) {
    if (node === magnet || !main_exports3.isSVGGraphicsElement(magnet)) {
      return anchor2;
    }
    node = magnet;
  }
  const localShape = view.getShapeOfElement(node);
  const magnetMatrix = view.getMatrixOfElement(node);
  const translateMatrix = view.getRootTranslatedMatrix();
  const rotateMatrix = view.getRootRotatedMatrix();
  const targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);
  const localMatrix = targetMatrix.inverse();
  const localLine = Util2.transformLine(line2, localMatrix);
  const localRef = localLine.start.clone();
  const data2 = view.getDataOfElement(node);
  if (options.insideout === false) {
    if (data2.shapeBBox == null) {
      data2.shapeBBox = localShape.bbox();
    }
    const localBBox = data2.shapeBBox;
    if (localBBox != null && localBBox.containsPoint(localRef)) {
      return anchor2;
    }
  }
  if (options.extrapolate === true) {
    localLine.setLength(1e6);
  }
  let pathOptions;
  if (Path.isPath(localShape)) {
    const precision = options.precision || 2;
    if (data2.segmentSubdivisions == null) {
      data2.segmentSubdivisions = localShape.getSegmentSubdivisions({
        precision
      });
    }
    pathOptions = {
      precision,
      segmentSubdivisions: data2.segmentSubdivisions
    };
    intersection2 = localLine.intersect(localShape, pathOptions);
  } else {
    intersection2 = localLine.intersect(localShape);
  }
  if (intersection2) {
    if (Array.isArray(intersection2)) {
      intersection2 = localRef.closest(intersection2);
    }
  } else if (options.sticky === true) {
    if (Rectangle.isRectangle(localShape)) {
      intersection2 = localShape.getNearestPointToPoint(localRef);
    } else if (Ellipse.isEllipse(localShape)) {
      intersection2 = localShape.intersectsWithLineFromCenterToPoint(localRef);
    } else {
      intersection2 = localShape.closestPoint(localRef, pathOptions);
    }
  }
  const cp = intersection2 ? Util2.transformPoint(intersection2, targetMatrix) : anchor2;
  let cpOffset = options.offset || 0;
  if (options.stroked !== false) {
    if (typeof cpOffset === "object") {
      cpOffset = Object.assign({}, cpOffset);
      if (cpOffset.x == null) {
        cpOffset.x = 0;
      }
      cpOffset.x += getStrokeWidth(node) / 2;
    } else {
      cpOffset += getStrokeWidth(node) / 2;
    }
  }
  return offset2(cp, line2.start, cpOffset);
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-point/anchor.js
function alignLine(line2, type, offset3 = 0) {
  const { start, end } = line2;
  let a;
  let b;
  let direction;
  let coordinate;
  switch (type) {
    case "left":
      coordinate = "x";
      a = end;
      b = start;
      direction = -1;
      break;
    case "right":
      coordinate = "x";
      a = start;
      b = end;
      direction = 1;
      break;
    case "top":
      coordinate = "y";
      a = end;
      b = start;
      direction = -1;
      break;
    case "bottom":
      coordinate = "y";
      a = start;
      b = end;
      direction = 1;
      break;
    default:
      return;
  }
  if (start[coordinate] < end[coordinate]) {
    a[coordinate] = b[coordinate];
  } else {
    b[coordinate] = a[coordinate];
  }
  if (Number.isFinite(offset3)) {
    a[coordinate] += direction * offset3;
    b[coordinate] += direction * offset3;
  }
}
var anchor = function(line2, view, magnet, options) {
  const { alignOffset, align: align2 } = options;
  if (align2) {
    alignLine(line2, align2, alignOffset);
  }
  return offset2(line2.end, line2.start, options.offset);
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connection-point/index.js
var ConnectionPoint;
(function(ConnectionPoint2) {
  ConnectionPoint2.presets = main_exports15;
  ConnectionPoint2.registry = Registry.create({
    type: "connection point"
  });
  ConnectionPoint2.registry.register(ConnectionPoint2.presets, true);
})(ConnectionPoint || (ConnectionPoint = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/main.js
var main_exports16 = {};
__export(main_exports16, {
  er: () => er,
  loop: () => loop,
  manhattan: () => manhattan,
  metro: () => metro,
  normal: () => normal,
  oneSide: () => oneSide,
  orth: () => orth3
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/normal.js
var normal = function(vertices) {
  return [...vertices];
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/oneside.js
var oneSide = function(vertices, options, edgeView) {
  const side = options.side || "bottom";
  const padding = number_exports.normalizeSides(options.padding || 40);
  const sourceBBox = edgeView.sourceBBox;
  const targetBBox = edgeView.targetBBox;
  const sourcePoint = sourceBBox.getCenter();
  const targetPoint = targetBBox.getCenter();
  let coord;
  let dim;
  let factor;
  switch (side) {
    case "top":
      factor = -1;
      coord = "y";
      dim = "height";
      break;
    case "left":
      factor = -1;
      coord = "x";
      dim = "width";
      break;
    case "right":
      factor = 1;
      coord = "x";
      dim = "width";
      break;
    case "bottom":
    default:
      factor = 1;
      coord = "y";
      dim = "height";
      break;
  }
  sourcePoint[coord] += factor * (sourceBBox[dim] / 2 + padding[side]);
  targetPoint[coord] += factor * (targetBBox[dim] / 2 + padding[side]);
  if (factor * (sourcePoint[coord] - targetPoint[coord]) > 0) {
    targetPoint[coord] = sourcePoint[coord];
  } else {
    sourcePoint[coord] = targetPoint[coord];
  }
  return [sourcePoint.toJSON(), ...vertices, targetPoint.toJSON()];
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/util.js
function getPointBBox(p) {
  return new Rectangle(p.x, p.y, 0, 0);
}
function getPaddingBox(options = {}) {
  const sides = number_exports.normalizeSides(options.padding || 20);
  return {
    x: -sides.left,
    y: -sides.top,
    width: sides.left + sides.right,
    height: sides.top + sides.bottom
  };
}
function getSourceBBox(view, options = {}) {
  return view.sourceBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getTargetBBox(view, options = {}) {
  return view.targetBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getSourceAnchor(view, options = {}) {
  if (view.sourceAnchor) {
    return view.sourceAnchor;
  }
  const bbox2 = getSourceBBox(view, options);
  return bbox2.getCenter();
}
function getTargetAnchor(view, options = {}) {
  if (view.targetAnchor) {
    return view.targetAnchor;
  }
  const bbox2 = getTargetBBox(view, options);
  return bbox2.getCenter();
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/orth.js
var orth3 = function(vertices, options, edgeView) {
  let sourceBBox = getSourceBBox(edgeView, options);
  let targetBBox = getTargetBBox(edgeView, options);
  const sourceAnchor = getSourceAnchor(edgeView, options);
  const targetAnchor = getTargetAnchor(edgeView, options);
  sourceBBox = sourceBBox.union(getPointBBox(sourceAnchor));
  targetBBox = targetBBox.union(getPointBBox(targetAnchor));
  const points = vertices.map((p) => Point.create(p));
  points.unshift(sourceAnchor);
  points.push(targetAnchor);
  let bearing = null;
  const result2 = [];
  for (let i = 0, len = points.length - 1; i < len; i += 1) {
    let route = null;
    const from = points[i];
    const to = points[i + 1];
    const isOrthogonal = Private4.getBearing(from, to) != null;
    if (i === 0) {
      if (i + 1 === len) {
        if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {
          route = Private4.insideNode(from, to, sourceBBox, targetBBox);
        } else if (!isOrthogonal) {
          route = Private4.nodeToNode(from, to, sourceBBox, targetBBox);
        }
      } else {
        if (sourceBBox.containsPoint(to)) {
          route = Private4.insideNode(from, to, sourceBBox, getPointBBox(to).moveAndExpand(getPaddingBox(options)));
        } else if (!isOrthogonal) {
          route = Private4.nodeToVertex(from, to, sourceBBox);
        }
      }
    } else if (i + 1 === len) {
      const isOrthogonalLoop = isOrthogonal && Private4.getBearing(to, from) === bearing;
      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {
        route = Private4.insideNode(from, to, getPointBBox(from).moveAndExpand(getPaddingBox(options)), targetBBox, bearing);
      } else if (!isOrthogonal) {
        route = Private4.vertexToNode(from, to, targetBBox, bearing);
      }
    } else if (!isOrthogonal) {
      route = Private4.vertexToVertex(from, to, bearing);
    }
    if (route) {
      result2.push(...route.points);
      bearing = route.direction;
    } else {
      bearing = Private4.getBearing(from, to);
    }
    if (i + 1 < len) {
      result2.push(to);
    }
  }
  return result2;
};
var Private4;
(function(Private5) {
  const opposites = {
    N: "S",
    S: "N",
    E: "W",
    W: "E"
  };
  const radians = {
    N: -Math.PI / 2 * 3,
    S: -Math.PI / 2,
    E: 0,
    W: Math.PI
  };
  function freeJoin(p1, p2, bbox2) {
    let p = new Point(p1.x, p2.y);
    if (bbox2.containsPoint(p)) {
      p = new Point(p2.x, p1.y);
    }
    return p;
  }
  function getBBoxSize(bbox2, bearing) {
    return bbox2[bearing === "W" || bearing === "E" ? "width" : "height"];
  }
  Private5.getBBoxSize = getBBoxSize;
  function getBearing(from, to) {
    if (from.x === to.x) {
      return from.y > to.y ? "N" : "S";
    }
    if (from.y === to.y) {
      return from.x > to.x ? "W" : "E";
    }
    return null;
  }
  Private5.getBearing = getBearing;
  function vertexToVertex(from, to, bearing) {
    const p1 = new Point(from.x, to.y);
    const p2 = new Point(to.x, from.y);
    const d1 = getBearing(from, p1);
    const d2 = getBearing(from, p2);
    const opposite = bearing ? opposites[bearing] : null;
    const p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;
    return { points: [p], direction: getBearing(p, to) };
  }
  Private5.vertexToVertex = vertexToVertex;
  function nodeToVertex(from, to, fromBBox) {
    const p = freeJoin(from, to, fromBBox);
    return { points: [p], direction: getBearing(p, to) };
  }
  Private5.nodeToVertex = nodeToVertex;
  function vertexToNode(from, to, toBBox, bearing) {
    const points = [new Point(from.x, to.y), new Point(to.x, from.y)];
    const freePoints = points.filter((p2) => !toBBox.containsPoint(p2));
    const freeBearingPoints = freePoints.filter((p2) => getBearing(p2, from) !== bearing);
    let p;
    if (freeBearingPoints.length > 0) {
      p = freeBearingPoints.filter((p2) => getBearing(from, p2) === bearing).pop();
      p = p || freeBearingPoints[0];
      return {
        points: [p],
        direction: getBearing(p, to)
      };
    }
    {
      p = array_exports.difference(points, freePoints)[0];
      const p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);
      const p1 = freeJoin(p2, from, toBBox);
      return {
        points: [p1, p2],
        direction: getBearing(p2, to)
      };
    }
  }
  Private5.vertexToNode = vertexToNode;
  function nodeToNode(from, to, fromBBox, toBBox) {
    let route = nodeToVertex(to, from, toBBox);
    const p1 = route.points[0];
    if (fromBBox.containsPoint(p1)) {
      route = nodeToVertex(from, to, fromBBox);
      const p2 = route.points[0];
      if (toBBox.containsPoint(p2)) {
        const fromBorder = Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
        const toBorder = Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
        const mid = new Line(fromBorder, toBorder).getCenter();
        const startRoute = nodeToVertex(from, mid, fromBBox);
        const endRoute = vertexToVertex(mid, to, startRoute.direction);
        route.points = [startRoute.points[0], endRoute.points[0]];
        route.direction = endRoute.direction;
      }
    }
    return route;
  }
  Private5.nodeToNode = nodeToNode;
  function insideNode(from, to, fromBBox, toBBox, bearing) {
    const boundary2 = fromBBox.union(toBBox).inflate(1);
    const center2 = boundary2.getCenter();
    const reversed = center2.distance(to) > center2.distance(from);
    const start = reversed ? to : from;
    const end = reversed ? from : to;
    let p1;
    let p2;
    let p3;
    if (bearing) {
      p1 = Point.fromPolar(boundary2.width + boundary2.height, radians[bearing], start);
      p1 = boundary2.getNearestPointToPoint(p1).move(p1, -1);
    } else {
      p1 = boundary2.getNearestPointToPoint(start).move(start, 1);
    }
    p2 = freeJoin(p1, end, boundary2);
    let points;
    if (p1.round().equals(p2.round())) {
      p2 = Point.fromPolar(boundary2.width + boundary2.height, Angle.toRad(p1.theta(start)) + Math.PI / 2, end);
      p2 = boundary2.getNearestPointToPoint(p2).move(end, 1).round();
      p3 = freeJoin(p1, p2, boundary2);
      points = reversed ? [p2, p3, p1] : [p1, p3, p2];
    } else {
      points = reversed ? [p2, p1] : [p1, p2];
    }
    const direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
    return {
      points,
      direction
    };
  }
  Private5.insideNode = insideNode;
})(Private4 || (Private4 = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/manhattan/options.js
var defaults3 = {
  step: 10,
  maxLoopCount: 2e3,
  precision: 1,
  maxDirectionChange: 90,
  perpendicular: true,
  excludeTerminals: [],
  excludeNodes: [],
  excludeShapes: [],
  startDirections: ["top", "right", "bottom", "left"],
  endDirections: ["top", "right", "bottom", "left"],
  directionMap: {
    top: { x: 0, y: -1 },
    right: { x: 1, y: 0 },
    bottom: { x: 0, y: 1 },
    left: { x: -1, y: 0 }
  },
  cost() {
    const step = resolve2(this.step, this);
    return step;
  },
  directions() {
    const step = resolve2(this.step, this);
    const cost = resolve2(this.cost, this);
    return [
      { cost, offsetX: step, offsetY: 0 },
      { cost, offsetX: -step, offsetY: 0 },
      { cost, offsetX: 0, offsetY: step },
      { cost, offsetX: 0, offsetY: -step }
    ];
  },
  penalties() {
    const step = resolve2(this.step, this);
    return {
      0: 0,
      45: step / 2,
      90: step / 2
    };
  },
  paddingBox() {
    const step = resolve2(this.step, this);
    return {
      x: -step,
      y: -step,
      width: 2 * step,
      height: 2 * step
    };
  },
  fallbackRouter: orth3,
  draggingRouter: null,
  snapToGrid: true
};
function resolve2(input, options) {
  if (typeof input === "function") {
    return input.call(options);
  }
  return input;
}
function resolveOptions(options) {
  const result2 = Object.keys(options).reduce((memo, key) => {
    const ret = memo;
    if (key === "fallbackRouter" || key === "draggingRouter" || key === "fallbackRoute") {
      ret[key] = options[key];
    } else {
      ret[key] = resolve2(options[key], options);
    }
    return memo;
  }, {});
  if (result2.padding) {
    const sides = number_exports.normalizeSides(result2.padding);
    result2.paddingBox = {
      x: -sides.left,
      y: -sides.top,
      width: sides.left + sides.right,
      height: sides.top + sides.bottom
    };
  }
  result2.directions.forEach((direction) => {
    const point1 = new Point(0, 0);
    const point2 = new Point(direction.offsetX, direction.offsetY);
    direction.angle = Angle.normalize(point1.theta(point2));
  });
  return result2;
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/manhattan/sorted-set.js
var OPEN = 1;
var CLOSE = 2;
var SortedSet = class {
  constructor() {
    this.items = [];
    this.hash = {};
    this.values = {};
  }
  add(item, value) {
    if (this.hash[item]) {
      this.items.splice(this.items.indexOf(item), 1);
    } else {
      this.hash[item] = OPEN;
    }
    this.values[item] = value;
    const index2 = array_exports.sortedIndexBy(this.items, item, (key) => this.values[key]);
    this.items.splice(index2, 0, item);
  }
  pop() {
    const item = this.items.shift();
    if (item) {
      this.hash[item] = CLOSE;
    }
    return item;
  }
  isOpen(item) {
    return this.hash[item] === OPEN;
  }
  isClose(item) {
    return this.hash[item] === CLOSE;
  }
  isEmpty() {
    return this.items.length === 0;
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/manhattan/obstacle-map.js
var ObstacleMap = class {
  constructor(options) {
    this.options = options;
    this.mapGridSize = 100;
    this.map = {};
  }
  /**
   * Builds a map of all nodes for quicker obstacle queries i.e. is a point
   * contained in any obstacle?
   *
   * A simplified grid search.
   */
  build(model, edge) {
    const options = this.options;
    const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {
      const terminal = edge[type];
      if (terminal) {
        const cell = model.getCell(terminal.cell);
        if (cell) {
          memo.push(cell);
        }
      }
      return memo;
    }, []);
    let excludedAncestors = [];
    const source = model.getCell(edge.getSourceCellId());
    if (source) {
      excludedAncestors = array_exports.union(excludedAncestors, source.getAncestors().map((cell) => cell.id));
    }
    const target = model.getCell(edge.getTargetCellId());
    if (target) {
      excludedAncestors = array_exports.union(excludedAncestors, target.getAncestors().map((cell) => cell.id));
    }
    const mapGridSize = this.mapGridSize;
    model.getNodes().reduce((map2, node) => {
      const excludedTerminal = excludedTerminals.some((cell) => cell.id === node.id);
      const excludedShape = node.shape ? options.excludeShapes.includes(node.shape) : false;
      const excludedNode = options.excludeNodes.some((item) => {
        if (typeof item === "string") {
          return node.id === item;
        }
        return item === node;
      });
      const excludedAncestor = excludedAncestors.includes(node.id);
      const excluded = excludedShape || excludedTerminal || excludedNode || excludedAncestor;
      if (node.isVisible() && !excluded) {
        const bbox2 = node.getBBox().moveAndExpand(options.paddingBox);
        const origin = bbox2.getOrigin().snapToGrid(mapGridSize);
        const corner = bbox2.getCorner().snapToGrid(mapGridSize);
        for (let x = origin.x; x <= corner.x; x += mapGridSize) {
          for (let y = origin.y; y <= corner.y; y += mapGridSize) {
            const key = new Point(x, y).toString();
            if (map2[key] == null) {
              map2[key] = [];
            }
            map2[key].push(bbox2);
          }
        }
      }
      return map2;
    }, this.map);
    return this;
  }
  isAccessible(point) {
    const key = point.clone().snapToGrid(this.mapGridSize).toString();
    const rects = this.map[key];
    return rects ? rects.every((rect2) => !rect2.containsPoint(point)) : true;
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/manhattan/util.js
function getSourceBBox2(view, options) {
  const bbox2 = view.sourceBBox.clone();
  if (options && options.paddingBox) {
    return bbox2.moveAndExpand(options.paddingBox);
  }
  return bbox2;
}
function getTargetBBox2(view, options) {
  const bbox2 = view.targetBBox.clone();
  if (options && options.paddingBox) {
    return bbox2.moveAndExpand(options.paddingBox);
  }
  return bbox2;
}
function getSourceEndpoint(view, options) {
  if (view.sourceAnchor) {
    return view.sourceAnchor;
  }
  const sourceBBox = getSourceBBox2(view, options);
  return sourceBBox.getCenter();
}
function getTargetEndpoint(view, options) {
  if (view.targetAnchor) {
    return view.targetAnchor;
  }
  const targetBBox = getTargetBBox2(view, options);
  return targetBBox.getCenter();
}
function getDirectionAngle(start, end, directionCount, grid, options) {
  const quadrant = 360 / directionCount;
  const angleTheta = start.theta(fixAngleEnd(start, end, grid, options));
  const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);
  return quadrant * Math.floor(normalizedAngle / quadrant);
}
function fixAngleEnd(start, end, grid, options) {
  const step = options.step;
  const diffX = end.x - start.x;
  const diffY = end.y - start.y;
  const gridStepsX = diffX / grid.x;
  const gridStepsY = diffY / grid.y;
  const distanceX = gridStepsX * step;
  const distanceY = gridStepsY * step;
  return new Point(start.x + distanceX, start.y + distanceY);
}
function getDirectionChange(angle1, angle2) {
  const change = Math.abs(angle1 - angle2);
  return change > 180 ? 360 - change : change;
}
function getGridOffsets(grid, options) {
  const step = options.step;
  options.directions.forEach((direction) => {
    direction.gridOffsetX = direction.offsetX / step * grid.x;
    direction.gridOffsetY = direction.offsetY / step * grid.y;
  });
  return options.directions;
}
function getGrid(step, source, target) {
  return {
    source: source.clone(),
    x: getGridDimension(target.x - source.x, step),
    y: getGridDimension(target.y - source.y, step)
  };
}
function getGridDimension(diff, step) {
  if (!diff) {
    return step;
  }
  const abs2 = Math.abs(diff);
  const count = Math.round(abs2 / step);
  if (!count) {
    return abs2;
  }
  const roundedDiff = count * step;
  const remainder = abs2 - roundedDiff;
  const correction = remainder / count;
  return step + correction;
}
function snapGrid(point, grid) {
  const source = grid.source;
  const x = GeometryUtil.snapToGrid(point.x - source.x, grid.x) + source.x;
  const y = GeometryUtil.snapToGrid(point.y - source.y, grid.y) + source.y;
  return new Point(x, y);
}
function round2(point, precision) {
  return point.round(precision);
}
function align(point, grid, precision) {
  return round2(snapGrid(point.clone(), grid), precision);
}
function getKey(point) {
  return point.toString();
}
function normalizePoint2(point) {
  return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
}
function getCost(from, anchors) {
  let min2 = Infinity;
  for (let i = 0, len = anchors.length; i < len; i += 1) {
    const dist = from.manhattanDistance(anchors[i]);
    if (dist < min2) {
      min2 = dist;
    }
  }
  return min2;
}
function getRectPoints(anchor2, bbox2, directionList, grid, options) {
  const precision = options.precision;
  const directionMap = options.directionMap;
  const centerVector = anchor2.diff(bbox2.getCenter());
  const rectPoints = Object.keys(directionMap).reduce((res, key) => {
    if (directionList.includes(key)) {
      const direction = directionMap[key];
      const ending = new Point(anchor2.x + direction.x * (Math.abs(centerVector.x) + bbox2.width), anchor2.y + direction.y * (Math.abs(centerVector.y) + bbox2.height));
      const intersectionLine = new Line(anchor2, ending);
      const intersections = intersectionLine.intersect(bbox2) || [];
      let farthestIntersectionDistance;
      let farthestIntersection = null;
      for (let i = 0; i < intersections.length; i += 1) {
        const intersection2 = intersections[i];
        const distance = anchor2.squaredDistance(intersection2);
        if (farthestIntersectionDistance == null || distance > farthestIntersectionDistance) {
          farthestIntersectionDistance = distance;
          farthestIntersection = intersection2;
        }
      }
      if (farthestIntersection) {
        let target = align(farthestIntersection, grid, precision);
        if (bbox2.containsPoint(target)) {
          target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);
        }
        res.push(target);
      }
    }
    return res;
  }, []);
  if (!bbox2.containsPoint(anchor2)) {
    rectPoints.push(align(anchor2, grid, precision));
  }
  return rectPoints;
}
function reconstructRoute(parents, points, tailPoint, from, to) {
  const route = [];
  let prevDiff = normalizePoint2(to.diff(tailPoint));
  let currentKey = getKey(tailPoint);
  let parent2 = parents[currentKey];
  let point;
  while (parent2) {
    point = points[currentKey];
    const diff = normalizePoint2(point.diff(parent2));
    if (!diff.equals(prevDiff)) {
      route.unshift(point);
      prevDiff = diff;
    }
    currentKey = getKey(parent2);
    parent2 = parents[currentKey];
  }
  const leadPoint = points[currentKey];
  const fromDiff = normalizePoint2(leadPoint.diff(from));
  if (!fromDiff.equals(prevDiff)) {
    route.unshift(leadPoint);
  }
  return route;
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/manhattan/router.js
function findRoute(edgeView, from, to, map2, options) {
  const precision = options.precision;
  let sourceEndpoint;
  let targetEndpoint;
  if (Rectangle.isRectangle(from)) {
    sourceEndpoint = round2(getSourceEndpoint(edgeView, options).clone(), precision);
  } else {
    sourceEndpoint = round2(from.clone(), precision);
  }
  if (Rectangle.isRectangle(to)) {
    targetEndpoint = round2(getTargetEndpoint(edgeView, options).clone(), precision);
  } else {
    targetEndpoint = round2(to.clone(), precision);
  }
  const grid = getGrid(options.step, sourceEndpoint, targetEndpoint);
  const startPoint = sourceEndpoint;
  const endPoint = targetEndpoint;
  let startPoints;
  let endPoints;
  if (Rectangle.isRectangle(from)) {
    startPoints = getRectPoints(startPoint, from, options.startDirections, grid, options);
  } else {
    startPoints = [startPoint];
  }
  if (Rectangle.isRectangle(to)) {
    endPoints = getRectPoints(targetEndpoint, to, options.endDirections, grid, options);
  } else {
    endPoints = [endPoint];
  }
  startPoints = startPoints.filter((p) => map2.isAccessible(p));
  endPoints = endPoints.filter((p) => map2.isAccessible(p));
  if (startPoints.length > 0 && endPoints.length > 0) {
    const openSet = new SortedSet();
    const points = {};
    const parents = {};
    const costs = {};
    for (let i = 0, n = startPoints.length; i < n; i += 1) {
      const startPoint2 = startPoints[i];
      const key = getKey(startPoint2);
      openSet.add(key, getCost(startPoint2, endPoints));
      points[key] = startPoint2;
      costs[key] = 0;
    }
    const previousRouteDirectionAngle = options.previousDirectionAngle;
    const isPathBeginning = previousRouteDirectionAngle === void 0;
    let direction;
    let directionChange;
    const directions = getGridOffsets(grid, options);
    const numDirections = directions.length;
    const endPointsKeys = endPoints.reduce((res, endPoint2) => {
      const key = getKey(endPoint2);
      res.push(key);
      return res;
    }, []);
    const sameStartEndPoints = Point.equalPoints(startPoints, endPoints);
    let loopsRemaining = options.maxLoopCount;
    while (!openSet.isEmpty() && loopsRemaining > 0) {
      const currentKey = openSet.pop();
      const currentPoint = points[currentKey];
      const currentParent = parents[currentKey];
      const currentCost = costs[currentKey];
      const isStartPoint = currentPoint.equals(startPoint);
      const isRouteBeginning = currentParent == null;
      let previousDirectionAngle;
      if (!isRouteBeginning) {
        previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);
      } else if (!isPathBeginning) {
        previousDirectionAngle = previousRouteDirectionAngle;
      } else if (!isStartPoint) {
        previousDirectionAngle = getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);
      } else {
        previousDirectionAngle = null;
      }
      const skipEndCheck = isRouteBeginning && sameStartEndPoints;
      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
        options.previousDirectionAngle = previousDirectionAngle;
        return reconstructRoute(parents, points, currentPoint, startPoint, endPoint);
      }
      for (let i = 0; i < numDirections; i += 1) {
        direction = directions[i];
        const directionAngle = direction.angle;
        directionChange = getDirectionChange(previousDirectionAngle, directionAngle);
        if (!(isPathBeginning && isStartPoint) && directionChange > options.maxDirectionChange) {
          continue;
        }
        const neighborPoint = align(currentPoint.clone().translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);
        const neighborKey = getKey(neighborPoint);
        if (openSet.isClose(neighborKey) || !map2.isAccessible(neighborPoint)) {
          continue;
        }
        if (endPointsKeys.indexOf(neighborKey) >= 0) {
          const isEndPoint = neighborPoint.equals(endPoint);
          if (!isEndPoint) {
            const endDirectionAngle = getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);
            const endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);
            if (endDirectionChange > options.maxDirectionChange) {
              continue;
            }
          }
        }
        const neighborCost = direction.cost;
        const neighborPenalty = isStartPoint ? 0 : options.penalties[directionChange];
        const costFromStart = currentCost + neighborCost + neighborPenalty;
        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
          points[neighborKey] = neighborPoint;
          parents[neighborKey] = currentPoint;
          costs[neighborKey] = costFromStart;
          openSet.add(neighborKey, costFromStart + getCost(neighborPoint, endPoints));
        }
      }
      loopsRemaining -= 1;
    }
  }
  if (options.fallbackRoute) {
    return main_exports.call(options.fallbackRoute, this, startPoint, endPoint, options);
  }
  return null;
}
function snap(vertices, gridSize = 10) {
  if (vertices.length <= 1) {
    return vertices;
  }
  for (let i = 0, len = vertices.length; i < len - 1; i += 1) {
    const first = vertices[i];
    const second = vertices[i + 1];
    if (first.x === second.x) {
      const x = gridSize * Math.round(first.x / gridSize);
      if (first.x !== x) {
        first.x = x;
        second.x = x;
      }
    } else if (first.y === second.y) {
      const y = gridSize * Math.round(first.y / gridSize);
      if (first.y !== y) {
        first.y = y;
        second.y = y;
      }
    }
  }
  return vertices;
}
var router = function(vertices, optionsRaw, edgeView) {
  const options = resolveOptions(optionsRaw);
  const sourceBBox = getSourceBBox2(edgeView, options);
  const targetBBox = getTargetBBox2(edgeView, options);
  const sourceEndpoint = getSourceEndpoint(edgeView, options);
  const map2 = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);
  const oldVertices = vertices.map((p) => Point.create(p));
  const newVertices = [];
  let tailPoint = sourceEndpoint;
  let from;
  let to;
  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {
    let partialRoute = null;
    from = to || sourceBBox;
    to = oldVertices[i];
    if (to == null) {
      to = targetBBox;
      const edge = edgeView.cell;
      const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;
      if (isEndingAtPoint && typeof options.draggingRouter === "function") {
        const dragFrom = from === sourceBBox ? sourceEndpoint : from;
        const dragTo = to.getOrigin();
        partialRoute = main_exports.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);
      }
    }
    if (partialRoute == null) {
      partialRoute = findRoute(edgeView, from, to, map2, options);
    }
    if (partialRoute === null) {
      console.warn(`Unable to execute manhattan algorithm, use orth instead`);
      return main_exports.call(options.fallbackRouter, this, vertices, options, edgeView);
    }
    const leadPoint = partialRoute[0];
    if (leadPoint && leadPoint.equals(tailPoint)) {
      partialRoute.shift();
    }
    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
    newVertices.push(...partialRoute);
  }
  if (options.snapToGrid) {
    return snap(newVertices, edgeView.graph.grid.getGridSize());
  }
  return newVertices;
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/manhattan/index.js
var manhattan = function(vertices, options, edgeView) {
  return main_exports.call(router, this, vertices, Object.assign(Object.assign({}, defaults3), options), edgeView);
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/metro.js
var defaults4 = {
  maxDirectionChange: 45,
  // an array of directions to find next points on the route
  // different from start/end directions
  directions() {
    const step = resolve2(this.step, this);
    const cost = resolve2(this.cost, this);
    const diagonalCost = Math.ceil(Math.sqrt(step * step << 1));
    return [
      { cost, offsetX: step, offsetY: 0 },
      { cost: diagonalCost, offsetX: step, offsetY: step },
      { cost, offsetX: 0, offsetY: step },
      { cost: diagonalCost, offsetX: -step, offsetY: step },
      { cost, offsetX: -step, offsetY: 0 },
      { cost: diagonalCost, offsetX: -step, offsetY: -step },
      { cost, offsetX: 0, offsetY: -step },
      { cost: diagonalCost, offsetX: step, offsetY: -step }
    ];
  },
  // a simple route used in situations when main routing method fails
  // (exceed max number of loop iterations, inaccessible)
  fallbackRoute(from, to, options) {
    const theta = from.theta(to);
    const route = [];
    let a = { x: to.x, y: from.y };
    let b = { x: from.x, y: to.y };
    if (theta % 180 > 90) {
      const t = a;
      a = b;
      b = t;
    }
    const p1 = theta % 90 < 45 ? a : b;
    const l1 = new Line(from, p1);
    const alpha = 90 * Math.ceil(theta / 90);
    const p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1);
    const l2 = new Line(to, p2);
    const intersectionPoint = l1.intersectsWithLine(l2);
    const point = intersectionPoint || to;
    const directionFrom = intersectionPoint ? point : from;
    const quadrant = 360 / options.directions.length;
    const angleTheta = directionFrom.theta(to);
    const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);
    const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
    options.previousDirectionAngle = directionAngle;
    if (point)
      route.push(point.round());
    route.push(to);
    return route;
  }
};
var metro = function(vertices, options, linkView) {
  return main_exports.call(manhattan, this, vertices, Object.assign(Object.assign({}, defaults4), options), linkView);
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/er.js
var er = function(vertices, options, edgeView) {
  const offsetRaw = options.offset || 32;
  const min2 = options.min == null ? 16 : options.min;
  let offset3 = 0;
  let direction = options.direction;
  const sourceBBox = edgeView.sourceBBox;
  const targetBBox = edgeView.targetBBox;
  const sourcePoint = sourceBBox.getCenter();
  const targetPoint = targetBBox.getCenter();
  if (typeof offsetRaw === "number") {
    offset3 = offsetRaw;
  }
  if (direction == null) {
    let dx = targetBBox.left - sourceBBox.right;
    let dy = targetBBox.top - sourceBBox.bottom;
    if (dx >= 0 && dy >= 0) {
      direction = dx >= dy ? "L" : "T";
    } else if (dx <= 0 && dy >= 0) {
      dx = sourceBBox.left - targetBBox.right;
      if (dx >= 0) {
        direction = dx >= dy ? "R" : "T";
      } else {
        direction = "T";
      }
    } else if (dx >= 0 && dy <= 0) {
      dy = sourceBBox.top - targetBBox.bottom;
      if (dy >= 0) {
        direction = dx >= dy ? "L" : "B";
      } else {
        direction = "L";
      }
    } else {
      dx = sourceBBox.left - targetBBox.right;
      dy = sourceBBox.top - targetBBox.bottom;
      if (dx >= 0 && dy >= 0) {
        direction = dx >= dy ? "R" : "B";
      } else if (dx <= 0 && dy >= 0) {
        direction = "B";
      } else if (dx >= 0 && dy <= 0) {
        direction = "R";
      } else {
        direction = Math.abs(dx) > Math.abs(dy) ? "R" : "B";
      }
    }
  }
  if (direction === "H") {
    direction = targetPoint.x - sourcePoint.x >= 0 ? "L" : "R";
  } else if (direction === "V") {
    direction = targetPoint.y - sourcePoint.y >= 0 ? "T" : "B";
  }
  if (offsetRaw === "center") {
    if (direction === "L") {
      offset3 = (targetBBox.left - sourceBBox.right) / 2;
    } else if (direction === "R") {
      offset3 = (sourceBBox.left - targetBBox.right) / 2;
    } else if (direction === "T") {
      offset3 = (targetBBox.top - sourceBBox.bottom) / 2;
    } else if (direction === "B") {
      offset3 = (sourceBBox.top - targetBBox.bottom) / 2;
    }
  }
  let coord;
  let dim;
  let factor;
  const horizontal = direction === "L" || direction === "R";
  if (horizontal) {
    if (targetPoint.y === sourcePoint.y) {
      return [...vertices];
    }
    factor = direction === "L" ? 1 : -1;
    coord = "x";
    dim = "width";
  } else {
    if (targetPoint.x === sourcePoint.x) {
      return [...vertices];
    }
    factor = direction === "T" ? 1 : -1;
    coord = "y";
    dim = "height";
  }
  const source = sourcePoint.clone();
  const target = targetPoint.clone();
  source[coord] += factor * (sourceBBox[dim] / 2 + offset3);
  target[coord] -= factor * (targetBBox[dim] / 2 + offset3);
  if (horizontal) {
    const sourceX = source.x;
    const targetX = target.x;
    const sourceDelta = sourceBBox.width / 2 + min2;
    const targetDelta = targetBBox.width / 2 + min2;
    if (targetPoint.x > sourcePoint.x) {
      if (targetX <= sourceX) {
        source.x = Math.max(targetX, sourcePoint.x + sourceDelta);
        target.x = Math.min(sourceX, targetPoint.x - targetDelta);
      }
    } else if (targetX >= sourceX) {
      source.x = Math.min(targetX, sourcePoint.x - sourceDelta);
      target.x = Math.max(sourceX, targetPoint.x + targetDelta);
    }
  } else {
    const sourceY = source.y;
    const targetY = target.y;
    const sourceDelta = sourceBBox.height / 2 + min2;
    const targetDelta = targetBBox.height / 2 + min2;
    if (targetPoint.y > sourcePoint.y) {
      if (targetY <= sourceY) {
        source.y = Math.max(targetY, sourcePoint.y + sourceDelta);
        target.y = Math.min(sourceY, targetPoint.y - targetDelta);
      }
    } else if (targetY >= sourceY) {
      source.y = Math.min(targetY, sourcePoint.y - sourceDelta);
      target.y = Math.max(sourceY, targetPoint.y + targetDelta);
    }
  }
  return [source.toJSON(), ...vertices, target.toJSON()];
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/loop.js
function rollup(points, merge2) {
  if (merge2 != null && merge2 !== false) {
    const amount = typeof merge2 === "boolean" ? 0 : merge2;
    if (amount > 0) {
      const center1 = Point.create(points[1]).move(points[2], amount);
      const center2 = Point.create(points[1]).move(points[0], amount);
      return [center1.toJSON(), ...points, center2.toJSON()];
    }
    {
      const center2 = points[1];
      return [Object.assign({}, center2), ...points, Object.assign({}, center2)];
    }
  }
  return points;
}
var loop = function(vertices, options, edgeView) {
  const width2 = options.width || 50;
  const height2 = options.height || 80;
  const halfHeight = height2 / 2;
  const angle = options.angle || "auto";
  const sourceAnchor = edgeView.sourceAnchor;
  const targetAnchor = edgeView.targetAnchor;
  const sourceBBox = edgeView.sourceBBox;
  const targetBBox = edgeView.targetBBox;
  if (sourceAnchor.equals(targetAnchor)) {
    const getVertices = (angle2) => {
      const rad = Angle.toRad(angle2);
      const sin = Math.sin(rad);
      const cos = Math.cos(rad);
      const center3 = new Point(sourceAnchor.x + cos * width2, sourceAnchor.y + sin * width2);
      const ref2 = new Point(center3.x - cos * halfHeight, center3.y - sin * halfHeight);
      const p1 = ref2.clone().rotate(-90, center3);
      const p2 = ref2.clone().rotate(90, center3);
      return [p1.toJSON(), center3.toJSON(), p2.toJSON()];
    };
    const validate = (end) => {
      const start = sourceAnchor.clone().move(end, -1);
      const line2 = new Line(start, end);
      return !sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line2);
    };
    const angles = [0, 90, 180, 270, 45, 135, 225, 315];
    if (typeof angle === "number") {
      return rollup(getVertices(angle), options.merge);
    }
    const center2 = sourceBBox.getCenter();
    if (center2.equals(sourceAnchor)) {
      return rollup(getVertices(0), options.merge);
    }
    const deg = center2.angleBetween(sourceAnchor, center2.clone().translate(1, 0));
    let ret = getVertices(deg);
    if (validate(ret[1])) {
      return rollup(ret, options.merge);
    }
    for (let i = 1, l = angles.length; i < l; i += 1) {
      ret = getVertices(deg + angles[i]);
      if (validate(ret[1])) {
        return rollup(ret, options.merge);
      }
    }
    return rollup(ret, options.merge);
  }
  {
    const line2 = new Line(sourceAnchor, targetAnchor);
    let parallel = line2.parallel(-width2);
    let center2 = parallel.getCenter();
    let p1 = parallel.start.clone().move(parallel.end, halfHeight);
    let p2 = parallel.end.clone().move(parallel.start, halfHeight);
    const ref2 = line2.parallel(-1);
    const line1 = new Line(ref2.start, center2);
    const line22 = new Line(ref2.end, center2);
    if (sourceBBox.containsPoint(center2) || targetBBox.containsPoint(center2) || sourceBBox.intersectsWithLine(line1) || sourceBBox.intersectsWithLine(line22) || targetBBox.intersectsWithLine(line1) || targetBBox.intersectsWithLine(line22)) {
      parallel = line2.parallel(width2);
      center2 = parallel.getCenter();
      p1 = parallel.start.clone().move(parallel.end, halfHeight);
      p2 = parallel.end.clone().move(parallel.start, halfHeight);
    }
    if (options.merge) {
      const line3 = new Line(sourceAnchor, targetAnchor);
      const normal3 = new Line(center2, line3.center).setLength(Number.MAX_SAFE_INTEGER);
      const intersects1 = sourceBBox.intersectsWithLine(normal3);
      const intersects2 = targetBBox.intersectsWithLine(normal3);
      const intersects = intersects1 ? Array.isArray(intersects1) ? intersects1 : [intersects1] : [];
      if (intersects2) {
        if (Array.isArray(intersects2)) {
          intersects.push(...intersects2);
        } else {
          intersects.push(intersects2);
        }
      }
      const anchor2 = line3.center.closest(intersects);
      if (anchor2) {
        edgeView.sourceAnchor = anchor2.clone();
        edgeView.targetAnchor = anchor2.clone();
      } else {
        edgeView.sourceAnchor = line3.center.clone();
        edgeView.targetAnchor = line3.center.clone();
      }
    }
    return rollup([p1.toJSON(), center2.toJSON(), p2.toJSON()], options.merge);
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/router/index.js
var Router;
(function(Router2) {
  Router2.presets = main_exports16;
  Router2.registry = Registry.create({
    type: "router"
  });
  Router2.registry.register(Router2.presets, true);
})(Router || (Router = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connector/main.js
var main_exports17 = {};
__export(main_exports17, {
  jumpover: () => jumpover,
  loop: () => loop2,
  normal: () => normal2,
  rounded: () => rounded,
  smooth: () => smooth
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connector/normal.js
var normal2 = function(sourcePoint, targetPoint, routePoints, options = {}) {
  const points = [sourcePoint, ...routePoints, targetPoint];
  const polyline = new Polyline(points);
  const path2 = new Path(polyline);
  return options.raw ? path2 : path2.serialize();
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connector/loop.js
var loop2 = function(sourcePoint, targetPoint, routePoints, options = {}) {
  const fix = routePoints.length === 3 ? 0 : 1;
  const p1 = Point.create(routePoints[0 + fix]);
  const p2 = Point.create(routePoints[2 + fix]);
  const center2 = Point.create(routePoints[1 + fix]);
  if (!Point.equals(sourcePoint, targetPoint)) {
    const middle = new Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);
    const angle = middle.angleBetween(Point.create(sourcePoint).rotate(90, middle), center2);
    if (angle > 1) {
      p1.rotate(180 - angle, middle);
      p2.rotate(180 - angle, middle);
      center2.rotate(180 - angle, middle);
    }
  }
  const pathData = `
     M ${sourcePoint.x} ${sourcePoint.y}
     Q ${p1.x} ${p1.y} ${center2.x} ${center2.y}
     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}
  `;
  return options.raw ? Path.parse(pathData) : pathData;
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connector/rounded.js
var rounded = function(sourcePoint, targetPoint, routePoints, options = {}) {
  const path2 = new Path();
  path2.appendSegment(Path.createSegment("M", sourcePoint));
  const f13 = 1 / 3;
  const f23 = 2 / 3;
  const radius = options.radius || 10;
  let prevDistance;
  let nextDistance;
  for (let i = 0, ii = routePoints.length; i < ii; i += 1) {
    const curr = Point.create(routePoints[i]);
    const prev = routePoints[i - 1] || sourcePoint;
    const next = routePoints[i + 1] || targetPoint;
    prevDistance = nextDistance || curr.distance(prev) / 2;
    nextDistance = curr.distance(next) / 2;
    const startMove = -Math.min(radius, prevDistance);
    const endMove = -Math.min(radius, nextDistance);
    const roundedStart = curr.clone().move(prev, startMove).round();
    const roundedEnd = curr.clone().move(next, endMove).round();
    const control1 = new Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);
    const control2 = new Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);
    path2.appendSegment(Path.createSegment("L", roundedStart));
    path2.appendSegment(Path.createSegment("C", control1, control2, roundedEnd));
  }
  path2.appendSegment(Path.createSegment("L", targetPoint));
  return options.raw ? path2 : path2.serialize();
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connector/smooth.js
var smooth = function(sourcePoint, targetPoint, routePoints, options = {}) {
  let path2;
  let direction = options.direction;
  if (routePoints && routePoints.length !== 0) {
    const points = [sourcePoint, ...routePoints, targetPoint];
    const curves = Curve.throughPoints(points);
    path2 = new Path(curves);
  } else {
    path2 = new Path();
    path2.appendSegment(Path.createSegment("M", sourcePoint));
    if (!direction) {
      direction = Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y) ? "H" : "V";
    }
    if (direction === "H") {
      const controlPointX = (sourcePoint.x + targetPoint.x) / 2;
      path2.appendSegment(Path.createSegment("C", controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));
    } else {
      const controlPointY = (sourcePoint.y + targetPoint.y) / 2;
      path2.appendSegment(Path.createSegment("C", sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));
    }
  }
  return options.raw ? path2 : path2.serialize();
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connector/jumpover.js
var CLOSE_PROXIMITY_PADDING = 1;
var F13 = 1 / 3;
var F23 = 2 / 3;
function setupUpdating(view) {
  let updateList = view.graph._jumpOverUpdateList;
  if (updateList == null) {
    updateList = view.graph._jumpOverUpdateList = [];
    view.graph.on("cell:mouseup", () => {
      const list = view.graph._jumpOverUpdateList;
      setTimeout(() => {
        for (let i = 0; i < list.length; i += 1) {
          list[i].update();
        }
      });
    });
    view.graph.on("model:reseted", () => {
      updateList = view.graph._jumpOverUpdateList = [];
    });
  }
  if (updateList.indexOf(view) < 0) {
    updateList.push(view);
    const clean2 = () => updateList.splice(updateList.indexOf(view), 1);
    view.cell.once("change:connector", clean2);
    view.cell.once("removed", clean2);
  }
}
function createLines(sourcePoint, targetPoint, route = []) {
  const points = [sourcePoint, ...route, targetPoint];
  const lines = [];
  points.forEach((point, idx) => {
    const next = points[idx + 1];
    if (next != null) {
      lines.push(new Line(point, next));
    }
  });
  return lines;
}
function findLineIntersections(line2, crossCheckLines) {
  const intersections = [];
  crossCheckLines.forEach((crossCheckLine) => {
    const intersection2 = line2.intersectsWithLine(crossCheckLine);
    if (intersection2) {
      intersections.push(intersection2);
    }
  });
  return intersections;
}
function getDistence(p1, p2) {
  return new Line(p1, p2).squaredLength();
}
function createJumps(line2, intersections, jumpSize) {
  return intersections.reduce((memo, point, idx) => {
    if (skippedPoints.includes(point)) {
      return memo;
    }
    const lastLine = memo.pop() || line2;
    const jumpStart = Point.create(point).move(lastLine.start, -jumpSize);
    let jumpEnd = Point.create(point).move(lastLine.start, +jumpSize);
    const nextPoint = intersections[idx + 1];
    if (nextPoint != null) {
      const distance = jumpEnd.distance(nextPoint);
      if (distance <= jumpSize) {
        jumpEnd = nextPoint.move(lastLine.start, distance);
        skippedPoints.push(nextPoint);
      }
    } else {
      const endDistance = jumpStart.distance(lastLine.end);
      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
        memo.push(lastLine);
        return memo;
      }
    }
    const startDistance = jumpEnd.distance(lastLine.start);
    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
      memo.push(lastLine);
      return memo;
    }
    const jumpLine = new Line(jumpStart, jumpEnd);
    jumppedLines.push(jumpLine);
    memo.push(new Line(lastLine.start, jumpStart), jumpLine, new Line(jumpEnd, lastLine.end));
    return memo;
  }, []);
}
function buildPath(lines, jumpSize, jumpType, radius) {
  const path2 = new Path();
  let segment;
  segment = Path.createSegment("M", lines[0].start);
  path2.appendSegment(segment);
  lines.forEach((line2, index2) => {
    if (jumppedLines.includes(line2)) {
      let angle;
      let diff;
      let control1;
      let control2;
      if (jumpType === "arc") {
        angle = -90;
        diff = line2.start.diff(line2.end);
        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;
        if (xAxisRotate) {
          angle += 180;
        }
        const center2 = line2.getCenter();
        const centerLine = new Line(center2, line2.end).rotate(angle, center2);
        let halfLine;
        halfLine = new Line(line2.start, center2);
        control1 = halfLine.pointAt(2 / 3).rotate(angle, line2.start);
        control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);
        segment = Path.createSegment("C", control1, control2, centerLine.end);
        path2.appendSegment(segment);
        halfLine = new Line(center2, line2.end);
        control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);
        control2 = halfLine.pointAt(1 / 3).rotate(-angle, line2.end);
        segment = Path.createSegment("C", control1, control2, line2.end);
        path2.appendSegment(segment);
      } else if (jumpType === "gap") {
        segment = Path.createSegment("M", line2.end);
        path2.appendSegment(segment);
      } else if (jumpType === "cubic") {
        angle = line2.start.theta(line2.end);
        const xOffset = jumpSize * 0.6;
        let yOffset = jumpSize * 1.35;
        diff = line2.start.diff(line2.end);
        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;
        if (xAxisRotate) {
          yOffset *= -1;
        }
        control1 = new Point(line2.start.x + xOffset, line2.start.y + yOffset).rotate(angle, line2.start);
        control2 = new Point(line2.end.x - xOffset, line2.end.y + yOffset).rotate(angle, line2.end);
        segment = Path.createSegment("C", control1, control2, line2.end);
        path2.appendSegment(segment);
      }
    } else {
      const nextLine = lines[index2 + 1];
      if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {
        segment = Path.createSegment("L", line2.end);
        path2.appendSegment(segment);
      } else {
        buildRoundedSegment(radius, path2, line2.end, line2.start, nextLine.end);
      }
    }
  });
  return path2;
}
function buildRoundedSegment(offset3, path2, curr, prev, next) {
  const prevDistance = curr.distance(prev) / 2;
  const nextDistance = curr.distance(next) / 2;
  const startMove = -Math.min(offset3, prevDistance);
  const endMove = -Math.min(offset3, nextDistance);
  const roundedStart = curr.clone().move(prev, startMove).round();
  const roundedEnd = curr.clone().move(next, endMove).round();
  const control1 = new Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);
  const control2 = new Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);
  let segment;
  segment = Path.createSegment("L", roundedStart);
  path2.appendSegment(segment);
  segment = Path.createSegment("C", control1, control2, roundedEnd);
  path2.appendSegment(segment);
}
var jumppedLines;
var skippedPoints;
var jumpover = function(sourcePoint, targetPoint, routePoints, options = {}) {
  jumppedLines = [];
  skippedPoints = [];
  setupUpdating(this);
  const jumpSize = options.size || 5;
  const jumpType = options.type || "arc";
  const radius = options.radius || 0;
  const ignoreConnectors = options.ignoreConnectors || ["smooth"];
  const graph = this.graph;
  const model = graph.model;
  const allLinks = model.getEdges();
  if (allLinks.length === 1) {
    return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);
  }
  const edge = this.cell;
  const thisIndex = allLinks.indexOf(edge);
  const defaultConnector = graph.options.connecting.connector || {};
  const edges = allLinks.filter((link, idx) => {
    const connector = link.getConnector() || defaultConnector;
    if (ignoreConnectors.includes(connector.name)) {
      return false;
    }
    if (idx > thisIndex) {
      return connector.name !== "jumpover";
    }
    return true;
  });
  const linkViews = edges.map((edge2) => {
    return graph.findViewByCell(edge2);
  });
  const thisLines = createLines(sourcePoint, targetPoint, routePoints);
  const linkLines = linkViews.map((linkView) => {
    if (linkView == null) {
      return [];
    }
    if (linkView === this) {
      return thisLines;
    }
    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);
  });
  const jumpingLines = [];
  thisLines.forEach((line2) => {
    const intersections = edges.reduce((memo, link, i) => {
      if (link !== edge) {
        const lineIntersections = findLineIntersections(line2, linkLines[i]);
        memo.push(...lineIntersections);
      }
      return memo;
    }, []).sort((a, b) => getDistence(line2.start, a) - getDistence(line2.start, b));
    if (intersections.length > 0) {
      jumpingLines.push(...createJumps(line2, intersections, jumpSize));
    } else {
      jumpingLines.push(line2);
    }
  });
  const path2 = buildPath(jumpingLines, jumpSize, jumpType, radius);
  jumppedLines = [];
  skippedPoints = [];
  return options.raw ? path2 : path2.serialize();
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/registry/connector/index.js
var Connector;
(function(Connector2) {
  Connector2.presets = main_exports17;
  Connector2.registry = Registry.create({
    type: "connector"
  });
  Connector2.registry.register(Connector2.presets, true);
})(Connector || (Connector = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/model/store.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Store2 = class extends Basecoat {
  constructor(data2 = {}) {
    super();
    this.pending = false;
    this.changing = false;
    this.data = {};
    this.mutate(object_exports.cloneDeep(data2));
    this.changed = {};
  }
  mutate(data2, options = {}) {
    const unset2 = options.unset === true;
    const silent = options.silent === true;
    const changes = [];
    const changing = this.changing;
    this.changing = true;
    if (!changing) {
      this.previous = object_exports.cloneDeep(this.data);
      this.changed = {};
    }
    const current = this.data;
    const previous = this.previous;
    const changed = this.changed;
    Object.keys(data2).forEach((k) => {
      const key = k;
      const newValue = data2[key];
      if (!object_exports.isEqual(current[key], newValue)) {
        changes.push(key);
      }
      if (!object_exports.isEqual(previous[key], newValue)) {
        changed[key] = newValue;
      } else {
        delete changed[key];
      }
      if (unset2) {
        delete current[key];
      } else {
        current[key] = newValue;
      }
    });
    if (!silent && changes.length > 0) {
      this.pending = true;
      this.pendingOptions = options;
      changes.forEach((key) => {
        this.emit("change:*", {
          key,
          options,
          store: this,
          current: current[key],
          previous: previous[key]
        });
      });
    }
    if (changing) {
      return this;
    }
    if (!silent) {
      while (this.pending) {
        this.pending = false;
        this.emit("changed", {
          current,
          previous,
          store: this,
          options: this.pendingOptions
        });
      }
    }
    this.pending = false;
    this.changing = false;
    this.pendingOptions = null;
    return this;
  }
  get(key, defaultValue) {
    if (key == null) {
      return this.data;
    }
    const ret = this.data[key];
    return ret == null ? defaultValue : ret;
  }
  getPrevious(key) {
    if (this.previous) {
      const ret = this.previous[key];
      return ret == null ? void 0 : ret;
    }
    return void 0;
  }
  set(key, value, options) {
    if (key != null) {
      if (typeof key === "object") {
        this.mutate(key, value);
      } else {
        this.mutate({ [key]: value }, options);
      }
    }
    return this;
  }
  remove(key, options) {
    const empty2 = void 0;
    const subset = {};
    let opts;
    if (typeof key === "string") {
      subset[key] = empty2;
      opts = options;
    } else if (Array.isArray(key)) {
      key.forEach((k) => subset[k] = empty2);
      opts = options;
    } else {
      for (const key2 in this.data) {
        subset[key2] = empty2;
      }
      opts = key;
    }
    this.mutate(subset, Object.assign(Object.assign({}, opts), { unset: true }));
    return this;
  }
  getByPath(path2) {
    return object_exports.getByPath(this.data, path2, "/");
  }
  setByPath(path2, value, options = {}) {
    const delim = "/";
    const pathArray = Array.isArray(path2) ? [...path2] : path2.split(delim);
    const pathString = Array.isArray(path2) ? path2.join(delim) : path2;
    const property2 = pathArray[0];
    const pathArrayLength = pathArray.length;
    options.propertyPath = pathString;
    options.propertyValue = value;
    options.propertyPathArray = pathArray;
    if (pathArrayLength === 1) {
      this.set(property2, value, options);
    } else {
      const update2 = {};
      let diver = update2;
      let nextKey = property2;
      for (let i = 1; i < pathArrayLength; i += 1) {
        const key = pathArray[i];
        const isArrayIndex = Number.isFinite(Number(key));
        diver = diver[nextKey] = isArrayIndex ? [] : {};
        nextKey = key;
      }
      object_exports.setByPath(update2, pathArray, value, delim);
      const data2 = object_exports.cloneDeep(this.data);
      if (options.rewrite) {
        object_exports.unsetByPath(data2, path2, delim);
      }
      const merged = object_exports.merge(data2, update2);
      this.set(property2, merged[property2], options);
    }
    return this;
  }
  removeByPath(path2, options) {
    const keys2 = Array.isArray(path2) ? path2 : path2.split("/");
    const key = keys2[0];
    if (keys2.length === 1) {
      this.remove(key, options);
    } else {
      const paths = keys2.slice(1);
      const prop2 = object_exports.cloneDeep(this.get(key));
      if (prop2) {
        object_exports.unsetByPath(prop2, paths);
      }
      this.set(key, prop2, options);
    }
    return this;
  }
  hasChanged(key) {
    if (key == null) {
      return Object.keys(this.changed).length > 0;
    }
    return key in this.changed;
  }
  /**
   * Returns an object containing all the data that have changed,
   * or `null` if there are no changes. Useful for determining what
   * parts of a view need to be updated.
   */
  getChanges(diff) {
    if (diff == null) {
      return this.hasChanged() ? object_exports.cloneDeep(this.changed) : null;
    }
    const old = this.changing ? this.previous : this.data;
    const changed = {};
    let hasChanged;
    for (const key in diff) {
      const val = diff[key];
      if (!object_exports.isEqual(old[key], val)) {
        changed[key] = val;
        hasChanged = true;
      }
    }
    return hasChanged ? object_exports.cloneDeep(changed) : null;
  }
  /**
   * Returns a copy of the store's `data` object.
   */
  toJSON() {
    return object_exports.cloneDeep(this.data);
  }
  clone() {
    const constructor = this.constructor;
    return new constructor(this.data);
  }
  dispose() {
    this.off();
    this.data = {};
    this.previous = {};
    this.changed = {};
    this.pending = false;
    this.changing = false;
    this.pendingOptions = null;
    this.trigger("disposed", { store: this });
  }
};
__decorate4([
  Basecoat.dispose()
], Store2.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/model/animation.js
var Animation = class _Animation {
  constructor(cell) {
    this.cell = cell;
    this.ids = {};
    this.cache = {};
  }
  get() {
    return Object.keys(this.ids);
  }
  start(path2, targetValue, options = {}, delim = "/") {
    const startValue = this.cell.getPropByPath(path2);
    const localOptions = object_exports.defaults(options, _Animation.defaultOptions);
    const timing = this.getTiming(localOptions.timing);
    const interpolate = this.getInterp(localOptions.interp, startValue, targetValue);
    let startTime = 0;
    const key = Array.isArray(path2) ? path2.join(delim) : path2;
    const paths = Array.isArray(path2) ? path2 : path2.split(delim);
    const iterate = () => {
      const now2 = (/* @__PURE__ */ new Date()).getTime();
      if (startTime === 0) {
        startTime = now2;
      }
      const elaspe = now2 - startTime;
      let progress = elaspe / localOptions.duration;
      if (progress < 1) {
        this.ids[key] = requestAnimationFrame(iterate);
      } else {
        progress = 1;
      }
      const currentValue = interpolate(timing(progress));
      this.cell.setPropByPath(paths, currentValue);
      if (options.progress) {
        options.progress(Object.assign({ progress, currentValue }, this.getArgs(key)));
      }
      if (progress === 1) {
        this.cell.notify("transition:complete", this.getArgs(key));
        options.complete && options.complete(this.getArgs(key));
        this.cell.notify("transition:finish", this.getArgs(key));
        options.finish && options.finish(this.getArgs(key));
        this.clean(key);
      }
    };
    setTimeout(() => {
      this.stop(path2, void 0, delim);
      this.cache[key] = { startValue, targetValue, options: localOptions };
      this.ids[key] = requestAnimationFrame(iterate);
      this.cell.notify("transition:start", this.getArgs(key));
      options.start && options.start(this.getArgs(key));
    }, options.delay);
    return this.stop.bind(this, path2, delim, options);
  }
  stop(path2, options = {}, delim = "/") {
    const paths = Array.isArray(path2) ? path2 : path2.split(delim);
    Object.keys(this.ids).filter((key) => object_exports.isEqual(paths, key.split(delim).slice(0, paths.length))).forEach((key) => {
      cancelAnimationFrame(this.ids[key]);
      const data2 = this.cache[key];
      const commonArgs = this.getArgs(key);
      const localOptions = Object.assign(Object.assign({}, data2.options), options);
      const jumpedToEnd = localOptions.jumpedToEnd;
      if (jumpedToEnd && data2.targetValue != null) {
        this.cell.setPropByPath(key, data2.targetValue);
        this.cell.notify("transition:end", Object.assign({}, commonArgs));
        this.cell.notify("transition:complete", Object.assign({}, commonArgs));
        localOptions.complete && localOptions.complete(Object.assign({}, commonArgs));
      }
      const stopArgs = Object.assign({ jumpedToEnd }, commonArgs);
      this.cell.notify("transition:stop", Object.assign({}, stopArgs));
      localOptions.stop && localOptions.stop(Object.assign({}, stopArgs));
      this.cell.notify("transition:finish", Object.assign({}, commonArgs));
      localOptions.finish && localOptions.finish(Object.assign({}, commonArgs));
      this.clean(key);
    });
    return this;
  }
  clean(key) {
    delete this.ids[key];
    delete this.cache[key];
  }
  getTiming(timing) {
    return typeof timing === "string" ? Timing[timing] : timing;
  }
  getInterp(interp, startValue, targetValue) {
    if (interp) {
      return interp(startValue, targetValue);
    }
    if (typeof targetValue === "number") {
      return Interp.number(startValue, targetValue);
    }
    if (typeof targetValue === "string") {
      if (targetValue[0] === "#") {
        return Interp.color(startValue, targetValue);
      }
      return Interp.unit(startValue, targetValue);
    }
    return Interp.object(startValue, targetValue);
  }
  getArgs(key) {
    const data2 = this.cache[key];
    return {
      path: key,
      startValue: data2.startValue,
      targetValue: data2.targetValue,
      cell: this.cell
    };
  }
};
(function(Animation2) {
  Animation2.defaultOptions = {
    delay: 10,
    duration: 100,
    timing: "linear"
  };
})(Animation || (Animation = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/model/cell.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest15 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Cell = class _Cell extends Basecoat {
  static config(presets) {
    const { markup, propHooks, attrHooks } = presets, others = __rest15(presets, ["markup", "propHooks", "attrHooks"]);
    if (markup != null) {
      this.markup = markup;
    }
    if (propHooks) {
      this.propHooks = this.propHooks.slice();
      if (Array.isArray(propHooks)) {
        this.propHooks.push(...propHooks);
      } else if (typeof propHooks === "function") {
        this.propHooks.push(propHooks);
      } else {
        Object.values(propHooks).forEach((hook) => {
          if (typeof hook === "function") {
            this.propHooks.push(hook);
          }
        });
      }
    }
    if (attrHooks) {
      this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);
    }
    this.defaults = object_exports.merge({}, this.defaults, others);
  }
  static getMarkup() {
    return this.markup;
  }
  static getDefaults(raw2) {
    return raw2 ? this.defaults : object_exports.cloneDeep(this.defaults);
  }
  static getAttrHooks() {
    return this.attrHooks;
  }
  static applyPropHooks(cell, metadata) {
    return this.propHooks.reduce((memo, hook) => {
      return hook ? main_exports.call(hook, cell, memo) : memo;
    }, metadata);
  }
  // #endregion
  get [Symbol.toStringTag]() {
    return _Cell.toStringTag;
  }
  constructor(metadata = {}) {
    super();
    const ctor = this.constructor;
    const defaults5 = ctor.getDefaults(true);
    const props = object_exports.merge({}, this.preprocess(defaults5), this.preprocess(metadata));
    this.id = props.id || string_exports.uuid();
    this.store = new Store2(props);
    this.animation = new Animation(this);
    this.setup();
    this.init();
    this.postprocess(metadata);
  }
  init() {
  }
  // #region model
  get model() {
    return this._model;
  }
  set model(model) {
    if (this._model !== model) {
      this._model = model;
    }
  }
  // #endregion
  preprocess(metadata, ignoreIdCheck) {
    const id = metadata.id;
    const ctor = this.constructor;
    const props = ctor.applyPropHooks(this, metadata);
    if (id == null && ignoreIdCheck !== true) {
      props.id = string_exports.uuid();
    }
    return props;
  }
  postprocess(metadata) {
  }
  // eslint-disable-line
  setup() {
    this.store.on("change:*", (metadata) => {
      const { key, current, previous, options } = metadata;
      this.notify("change:*", {
        key,
        options,
        current,
        previous,
        cell: this
      });
      this.notify(`change:${key}`, {
        options,
        current,
        previous,
        cell: this
      });
      const type = key;
      if (type === "source" || type === "target") {
        this.notify(`change:terminal`, {
          type,
          current,
          previous,
          options,
          cell: this
        });
      }
    });
    this.store.on("changed", ({ options }) => this.notify("changed", { options, cell: this }));
  }
  notify(name, args) {
    this.trigger(name, args);
    const model = this.model;
    if (model) {
      model.notify(`cell:${name}`, args);
      if (this.isNode()) {
        model.notify(`node:${name}`, Object.assign(Object.assign({}, args), { node: this }));
      } else if (this.isEdge()) {
        model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: this }));
      }
    }
    return this;
  }
  isNode() {
    return false;
  }
  isEdge() {
    return false;
  }
  isSameStore(cell) {
    return this.store === cell.store;
  }
  get view() {
    return this.store.get("view");
  }
  get shape() {
    return this.store.get("shape", "");
  }
  getProp(key, defaultValue) {
    if (key == null) {
      return this.store.get();
    }
    return this.store.get(key, defaultValue);
  }
  setProp(key, value, options) {
    if (typeof key === "string") {
      this.store.set(key, value, options);
    } else {
      const props = this.preprocess(key, true);
      this.store.set(object_exports.merge({}, this.getProp(), props), value);
      this.postprocess(key);
    }
    return this;
  }
  removeProp(key, options) {
    if (typeof key === "string" || Array.isArray(key)) {
      this.store.removeByPath(key, options);
    } else {
      this.store.remove(options);
    }
    return this;
  }
  hasChanged(key) {
    return key == null ? this.store.hasChanged() : this.store.hasChanged(key);
  }
  getPropByPath(path2) {
    return this.store.getByPath(path2);
  }
  setPropByPath(path2, value, options = {}) {
    if (this.model) {
      if (path2 === "children") {
        this._children = value ? value.map((id) => this.model.getCell(id)).filter((child) => child != null) : null;
      } else if (path2 === "parent") {
        this._parent = value ? this.model.getCell(value) : null;
      }
    }
    this.store.setByPath(path2, value, options);
    return this;
  }
  removePropByPath(path2, options = {}) {
    const paths = Array.isArray(path2) ? path2 : path2.split("/");
    if (paths[0] === "attrs") {
      options.dirty = true;
    }
    this.store.removeByPath(paths, options);
    return this;
  }
  prop(key, value, options) {
    if (key == null) {
      return this.getProp();
    }
    if (typeof key === "string" || Array.isArray(key)) {
      if (arguments.length === 1) {
        return this.getPropByPath(key);
      }
      if (value == null) {
        return this.removePropByPath(key, options || {});
      }
      return this.setPropByPath(key, value, options || {});
    }
    return this.setProp(key, value || {});
  }
  previous(name) {
    return this.store.getPrevious(name);
  }
  // #endregion
  // #region zIndex
  get zIndex() {
    return this.getZIndex();
  }
  set zIndex(z) {
    if (z == null) {
      this.removeZIndex();
    } else {
      this.setZIndex(z);
    }
  }
  getZIndex() {
    return this.store.get("zIndex");
  }
  setZIndex(z, options = {}) {
    this.store.set("zIndex", z, options);
    return this;
  }
  removeZIndex(options = {}) {
    this.store.remove("zIndex", options);
    return this;
  }
  toFront(options = {}) {
    const model = this.model;
    if (model) {
      let z = model.getMaxZIndex();
      let cells;
      if (options.deep) {
        cells = this.getDescendants({ deep: true, breadthFirst: true });
        cells.unshift(this);
      } else {
        cells = [this];
      }
      z = z - cells.length + 1;
      const count = model.total();
      let changed = model.indexOf(this) !== count - cells.length;
      if (!changed) {
        changed = cells.some((cell, index2) => cell.getZIndex() !== z + index2);
      }
      if (changed) {
        this.batchUpdate("to-front", () => {
          z += cells.length;
          cells.forEach((cell, index2) => {
            cell.setZIndex(z + index2, options);
          });
        });
      }
    }
    return this;
  }
  toBack(options = {}) {
    const model = this.model;
    if (model) {
      let z = model.getMinZIndex();
      let cells;
      if (options.deep) {
        cells = this.getDescendants({ deep: true, breadthFirst: true });
        cells.unshift(this);
      } else {
        cells = [this];
      }
      let changed = model.indexOf(this) !== 0;
      if (!changed) {
        changed = cells.some((cell, index2) => cell.getZIndex() !== z + index2);
      }
      if (changed) {
        this.batchUpdate("to-back", () => {
          z -= cells.length;
          cells.forEach((cell, index2) => {
            cell.setZIndex(z + index2, options);
          });
        });
      }
    }
    return this;
  }
  // #endregion
  // #region markup
  get markup() {
    return this.getMarkup();
  }
  set markup(value) {
    if (value == null) {
      this.removeMarkup();
    } else {
      this.setMarkup(value);
    }
  }
  getMarkup() {
    let markup = this.store.get("markup");
    if (markup == null) {
      const ctor = this.constructor;
      markup = ctor.getMarkup();
    }
    return markup;
  }
  setMarkup(markup, options = {}) {
    this.store.set("markup", markup, options);
    return this;
  }
  removeMarkup(options = {}) {
    this.store.remove("markup", options);
    return this;
  }
  // #endregion
  // #region attrs
  get attrs() {
    return this.getAttrs();
  }
  set attrs(value) {
    if (value == null) {
      this.removeAttrs();
    } else {
      this.setAttrs(value);
    }
  }
  getAttrs() {
    const result2 = this.store.get("attrs");
    return result2 ? Object.assign({}, result2) : {};
  }
  setAttrs(attrs, options = {}) {
    if (attrs == null) {
      this.removeAttrs(options);
    } else {
      const set2 = (attrs2) => this.store.set("attrs", attrs2, options);
      if (options.overwrite === true) {
        set2(attrs);
      } else {
        const prev = this.getAttrs();
        if (options.deep === false) {
          set2(Object.assign(Object.assign({}, prev), attrs));
        } else {
          set2(object_exports.merge({}, prev, attrs));
        }
      }
    }
    return this;
  }
  replaceAttrs(attrs, options = {}) {
    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { overwrite: true }));
  }
  updateAttrs(attrs, options = {}) {
    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { deep: false }));
  }
  removeAttrs(options = {}) {
    this.store.remove("attrs", options);
    return this;
  }
  getAttrDefinition(attrName) {
    if (!attrName) {
      return null;
    }
    const ctor = this.constructor;
    const hooks = ctor.getAttrHooks() || {};
    let definition = hooks[attrName] || Attr.registry.get(attrName);
    if (!definition) {
      const name = string_exports.camelCase(attrName);
      definition = hooks[name] || Attr.registry.get(name);
    }
    return definition || null;
  }
  getAttrByPath(path2) {
    if (path2 == null || path2 === "") {
      return this.getAttrs();
    }
    return this.getPropByPath(this.prefixAttrPath(path2));
  }
  setAttrByPath(path2, value, options = {}) {
    this.setPropByPath(this.prefixAttrPath(path2), value, options);
    return this;
  }
  removeAttrByPath(path2, options = {}) {
    this.removePropByPath(this.prefixAttrPath(path2), options);
    return this;
  }
  prefixAttrPath(path2) {
    return Array.isArray(path2) ? ["attrs"].concat(path2) : `attrs/${path2}`;
  }
  attr(path2, value, options) {
    if (path2 == null) {
      return this.getAttrByPath();
    }
    if (typeof path2 === "string" || Array.isArray(path2)) {
      if (arguments.length === 1) {
        return this.getAttrByPath(path2);
      }
      if (value == null) {
        return this.removeAttrByPath(path2, options || {});
      }
      return this.setAttrByPath(path2, value, options || {});
    }
    return this.setAttrs(path2, value || {});
  }
  // #endregion
  // #region visible
  get visible() {
    return this.isVisible();
  }
  set visible(value) {
    this.setVisible(value);
  }
  setVisible(visible, options = {}) {
    this.store.set("visible", visible, options);
    return this;
  }
  isVisible() {
    return this.store.get("visible") !== false;
  }
  show(options = {}) {
    if (!this.isVisible()) {
      this.setVisible(true, options);
    }
    return this;
  }
  hide(options = {}) {
    if (this.isVisible()) {
      this.setVisible(false, options);
    }
    return this;
  }
  toggleVisible(isVisible, options = {}) {
    const visible = typeof isVisible === "boolean" ? isVisible : !this.isVisible();
    const localOptions = typeof isVisible === "boolean" ? options : isVisible;
    if (visible) {
      this.show(localOptions);
    } else {
      this.hide(localOptions);
    }
    return this;
  }
  // #endregion
  // #region data
  get data() {
    return this.getData();
  }
  set data(val) {
    this.setData(val);
  }
  getData() {
    return this.store.get("data");
  }
  setData(data2, options = {}) {
    if (data2 == null) {
      this.removeData(options);
    } else {
      const set2 = (data3) => this.store.set("data", data3, options);
      if (options.overwrite === true) {
        set2(data2);
      } else {
        const prev = this.getData();
        if (options.deep === false) {
          set2(typeof data2 === "object" ? Object.assign(Object.assign({}, prev), data2) : data2);
        } else {
          set2(object_exports.merge({}, prev, data2));
        }
      }
    }
    return this;
  }
  replaceData(data2, options = {}) {
    return this.setData(data2, Object.assign(Object.assign({}, options), { overwrite: true }));
  }
  updateData(data2, options = {}) {
    return this.setData(data2, Object.assign(Object.assign({}, options), { deep: false }));
  }
  removeData(options = {}) {
    this.store.remove("data", options);
    return this;
  }
  // #endregion
  // #region parent children
  get parent() {
    return this.getParent();
  }
  get children() {
    return this.getChildren();
  }
  getParentId() {
    return this.store.get("parent");
  }
  getParent() {
    const parentId = this.getParentId();
    if (parentId && this.model) {
      const parent2 = this.model.getCell(parentId);
      this._parent = parent2;
      return parent2;
    }
    return null;
  }
  getChildren() {
    const childrenIds = this.store.get("children");
    if (childrenIds && childrenIds.length && this.model) {
      const children2 = childrenIds.map((id) => {
        var _a;
        return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id);
      }).filter((cell) => cell != null);
      this._children = children2;
      return [...children2];
    }
    return null;
  }
  hasParent() {
    return this.parent != null;
  }
  isParentOf(child) {
    return child != null && child.getParent() === this;
  }
  isChildOf(parent2) {
    return parent2 != null && this.getParent() === parent2;
  }
  eachChild(iterator, context) {
    if (this.children) {
      this.children.forEach(iterator, context);
    }
    return this;
  }
  filterChild(filter3, context) {
    return this.children ? this.children.filter(filter3, context) : [];
  }
  getChildCount() {
    return this.children == null ? 0 : this.children.length;
  }
  getChildIndex(child) {
    return this.children == null ? -1 : this.children.indexOf(child);
  }
  getChildAt(index2) {
    return this.children != null && index2 >= 0 ? this.children[index2] : null;
  }
  getAncestors(options = {}) {
    const ancestors = [];
    let parent2 = this.getParent();
    while (parent2) {
      ancestors.push(parent2);
      parent2 = options.deep !== false ? parent2.getParent() : null;
    }
    return ancestors;
  }
  getDescendants(options = {}) {
    if (options.deep !== false) {
      if (options.breadthFirst) {
        const cells = [];
        const queue = this.getChildren() || [];
        while (queue.length > 0) {
          const parent2 = queue.shift();
          const children2 = parent2.getChildren();
          cells.push(parent2);
          if (children2) {
            queue.push(...children2);
          }
        }
        return cells;
      }
      {
        const cells = this.getChildren() || [];
        cells.forEach((cell) => {
          cells.push(...cell.getDescendants(options));
        });
        return cells;
      }
    }
    return this.getChildren() || [];
  }
  isDescendantOf(ancestor, options = {}) {
    if (ancestor == null) {
      return false;
    }
    if (options.deep !== false) {
      let current = this.getParent();
      while (current) {
        if (current === ancestor) {
          return true;
        }
        current = current.getParent();
      }
      return false;
    }
    return this.isChildOf(ancestor);
  }
  isAncestorOf(descendant, options = {}) {
    if (descendant == null) {
      return false;
    }
    return descendant.isDescendantOf(this, options);
  }
  contains(cell) {
    return this.isAncestorOf(cell);
  }
  getCommonAncestor(...cells) {
    return _Cell.getCommonAncestor(this, ...cells);
  }
  setParent(parent2, options = {}) {
    this._parent = parent2;
    if (parent2) {
      this.store.set("parent", parent2.id, options);
    } else {
      this.store.remove("parent", options);
    }
    return this;
  }
  setChildren(children2, options = {}) {
    this._children = children2;
    if (children2 != null) {
      this.store.set("children", children2.map((child) => child.id), options);
    } else {
      this.store.remove("children", options);
    }
    return this;
  }
  unembed(child, options = {}) {
    const children2 = this.children;
    if (children2 != null && child != null) {
      const index2 = this.getChildIndex(child);
      if (index2 !== -1) {
        children2.splice(index2, 1);
        child.setParent(null, options);
        this.setChildren(children2, options);
      }
    }
    return this;
  }
  embed(child, options = {}) {
    child.addTo(this, options);
    return this;
  }
  addTo(target, options = {}) {
    if (_Cell.isCell(target)) {
      target.addChild(this, options);
    } else {
      target.addCell(this, options);
    }
    return this;
  }
  insertTo(parent2, index2, options = {}) {
    parent2.insertChild(this, index2, options);
    return this;
  }
  addChild(child, options = {}) {
    return this.insertChild(child, void 0, options);
  }
  insertChild(child, index2, options = {}) {
    if (child != null && child !== this) {
      const oldParent = child.getParent();
      const changed = this !== oldParent;
      let pos = index2;
      if (pos == null) {
        pos = this.getChildCount();
        if (!changed) {
          pos -= 1;
        }
      }
      if (oldParent) {
        const children3 = oldParent.getChildren();
        if (children3) {
          const index3 = children3.indexOf(child);
          if (index3 >= 0) {
            child.setParent(null, options);
            children3.splice(index3, 1);
            oldParent.setChildren(children3, options);
          }
        }
      }
      let children2 = this.children;
      if (children2 == null) {
        children2 = [];
        children2.push(child);
      } else {
        children2.splice(pos, 0, child);
      }
      child.setParent(this, options);
      this.setChildren(children2, options);
      if (changed && this.model) {
        const incomings = this.model.getIncomingEdges(this);
        const outgoings = this.model.getOutgoingEdges(this);
        if (incomings) {
          incomings.forEach((edge) => edge.updateParent(options));
        }
        if (outgoings) {
          outgoings.forEach((edge) => edge.updateParent(options));
        }
      }
      if (this.model) {
        this.model.addCell(child, options);
      }
    }
    return this;
  }
  removeFromParent(options = {}) {
    const parent2 = this.getParent();
    if (parent2 != null) {
      const index2 = parent2.getChildIndex(this);
      parent2.removeChildAt(index2, options);
    }
    return this;
  }
  removeChild(child, options = {}) {
    const index2 = this.getChildIndex(child);
    return this.removeChildAt(index2, options);
  }
  removeChildAt(index2, options = {}) {
    const child = this.getChildAt(index2);
    const children2 = this.children;
    if (children2 != null && child != null) {
      this.unembed(child, options);
      child.remove(options);
    }
    return child;
  }
  remove(options = {}) {
    this.batchUpdate("remove", () => {
      const parent2 = this.getParent();
      if (parent2) {
        parent2.removeChild(this, options);
      }
      if (options.deep !== false) {
        this.eachChild((child) => child.remove(options));
      }
      if (this.model) {
        this.model.removeCell(this, options);
      }
    });
    return this;
  }
  transition(path2, target, options = {}, delim = "/") {
    return this.animation.start(path2, target, options, delim);
  }
  stopTransition(path2, options, delim = "/") {
    this.animation.stop(path2, options, delim);
    return this;
  }
  getTransitions() {
    return this.animation.get();
  }
  // #endregion
  // #region transform
  // eslint-disable-next-line
  translate(tx, ty, options) {
    return this;
  }
  scale(sx, sy, origin, options) {
    return this;
  }
  addTools(items, obj, options) {
    const toolItems = Array.isArray(items) ? items : [items];
    const name = typeof obj === "string" ? obj : null;
    const config = typeof obj === "object" ? obj : typeof options === "object" ? options : {};
    if (config.reset) {
      return this.setTools({ name, items: toolItems, local: config.local }, config);
    }
    let tools = object_exports.cloneDeep(this.getTools());
    if (tools == null || name == null || tools.name === name) {
      if (tools == null) {
        tools = {};
      }
      if (!tools.items) {
        tools.items = [];
      }
      tools.name = name;
      tools.items = [...tools.items, ...toolItems];
      return this.setTools(Object.assign({}, tools), config);
    }
  }
  setTools(tools, options = {}) {
    if (tools == null) {
      this.removeTools();
    } else {
      this.store.set("tools", _Cell.normalizeTools(tools), options);
    }
    return this;
  }
  getTools() {
    return this.store.get("tools");
  }
  removeTools(options = {}) {
    this.store.remove("tools", options);
    return this;
  }
  hasTools(name) {
    const tools = this.getTools();
    if (tools == null) {
      return false;
    }
    if (name == null) {
      return true;
    }
    return tools.name === name;
  }
  hasTool(name) {
    const tools = this.getTools();
    if (tools == null) {
      return false;
    }
    return tools.items.some((item) => typeof item === "string" ? item === name : item.name === name);
  }
  removeTool(nameOrIndex, options = {}) {
    const tools = object_exports.cloneDeep(this.getTools());
    if (tools) {
      let updated = false;
      const items = tools.items.slice();
      const remove3 = (index2) => {
        items.splice(index2, 1);
        updated = true;
      };
      if (typeof nameOrIndex === "number") {
        remove3(nameOrIndex);
      } else {
        for (let i = items.length - 1; i >= 0; i -= 1) {
          const item = items[i];
          const exist = typeof item === "string" ? item === nameOrIndex : item.name === nameOrIndex;
          if (exist) {
            remove3(i);
          }
        }
      }
      if (updated) {
        tools.items = items;
        this.setTools(tools, options);
      }
    }
    return this;
  }
  // #endregion
  // #region common
  // eslint-disable-next-line
  getBBox(options) {
    return new Rectangle();
  }
  // eslint-disable-next-line
  getConnectionPoint(edge, type) {
    return new Point();
  }
  toJSON(options = {}) {
    const props = Object.assign({}, this.store.get());
    const toString2 = Object.prototype.toString;
    const cellType = this.isNode() ? "node" : this.isEdge() ? "edge" : "cell";
    if (!props.shape) {
      const ctor2 = this.constructor;
      throw new Error(`Unable to serialize ${cellType} missing "shape" prop, check the ${cellType} "${ctor2.name || toString2.call(ctor2)}"`);
    }
    const ctor = this.constructor;
    const diff = options.diff === true;
    const attrs = props.attrs || {};
    const presets = ctor.getDefaults(true);
    const defaults5 = diff ? this.preprocess(presets, true) : presets;
    const defaultAttrs = defaults5.attrs || {};
    const finalAttrs = {};
    Object.entries(props).forEach(([key, val]) => {
      if (val != null && !Array.isArray(val) && typeof val === "object" && !object_exports.isPlainObject(val)) {
        throw new Error(`Can only serialize ${cellType} with plain-object props, but got a "${toString2.call(val)}" type of key "${key}" on ${cellType} "${this.id}"`);
      }
      if (key !== "attrs" && key !== "shape" && diff) {
        const preset = defaults5[key];
        if (object_exports.isEqual(val, preset)) {
          delete props[key];
        }
      }
    });
    Object.keys(attrs).forEach((key) => {
      const attr2 = attrs[key];
      const defaultAttr = defaultAttrs[key];
      Object.keys(attr2).forEach((name) => {
        const value = attr2[name];
        const defaultValue = defaultAttr ? defaultAttr[name] : null;
        if (value != null && typeof value === "object" && !Array.isArray(value)) {
          Object.keys(value).forEach((subName) => {
            const subValue = value[subName];
            if (defaultAttr == null || defaultValue == null || !object_exports.isObject(defaultValue) || !object_exports.isEqual(defaultValue[subName], subValue)) {
              if (finalAttrs[key] == null) {
                finalAttrs[key] = {};
              }
              if (finalAttrs[key][name] == null) {
                finalAttrs[key][name] = {};
              }
              const tmp = finalAttrs[key][name];
              tmp[subName] = subValue;
            }
          });
        } else if (defaultAttr == null || !object_exports.isEqual(defaultValue, value)) {
          if (finalAttrs[key] == null) {
            finalAttrs[key] = {};
          }
          finalAttrs[key][name] = value;
        }
      });
    });
    const finalProps = Object.assign(Object.assign({}, props), { attrs: object_exports.isEmpty(finalAttrs) ? void 0 : finalAttrs });
    if (finalProps.attrs == null) {
      delete finalProps.attrs;
    }
    const ret = finalProps;
    if (ret.angle === 0) {
      delete ret.angle;
    }
    return object_exports.cloneDeep(ret);
  }
  clone(options = {}) {
    if (!options.deep) {
      const data2 = Object.assign({}, this.store.get());
      if (!options.keepId) {
        delete data2.id;
      }
      delete data2.parent;
      delete data2.children;
      const ctor = this.constructor;
      return new ctor(data2);
    }
    const map2 = _Cell.deepClone(this);
    return map2[this.id];
  }
  findView(graph) {
    return graph.findViewByCell(this);
  }
  // #endregion
  // #region batch
  startBatch(name, data2 = {}, model = this.model) {
    this.notify("batch:start", { name, data: data2, cell: this });
    if (model) {
      model.startBatch(name, Object.assign(Object.assign({}, data2), { cell: this }));
    }
    return this;
  }
  stopBatch(name, data2 = {}, model = this.model) {
    if (model) {
      model.stopBatch(name, Object.assign(Object.assign({}, data2), { cell: this }));
    }
    this.notify("batch:stop", { name, data: data2, cell: this });
    return this;
  }
  batchUpdate(name, execute, data2) {
    const model = this.model;
    this.startBatch(name, data2, model);
    const result2 = execute();
    this.stopBatch(name, data2, model);
    return result2;
  }
  // #endregion
  // #region IDisposable
  dispose() {
    this.removeFromParent();
    this.store.dispose();
  }
};
Cell.defaults = {};
Cell.attrHooks = {};
Cell.propHooks = [];
__decorate5([
  Basecoat.dispose()
], Cell.prototype, "dispose", null);
(function(Cell2) {
  function normalizeTools(raw2) {
    if (typeof raw2 === "string") {
      return { items: [raw2] };
    }
    if (Array.isArray(raw2)) {
      return { items: raw2 };
    }
    if (raw2.items) {
      return raw2;
    }
    return {
      items: [raw2]
    };
  }
  Cell2.normalizeTools = normalizeTools;
})(Cell || (Cell = {}));
(function(Cell2) {
  Cell2.toStringTag = `X6.${Cell2.name}`;
  function isCell(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Cell2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const cell = instance;
    if ((tag == null || tag === Cell2.toStringTag) && typeof cell.isNode === "function" && typeof cell.isEdge === "function" && typeof cell.prop === "function" && typeof cell.attr === "function") {
      return true;
    }
    return false;
  }
  Cell2.isCell = isCell;
})(Cell || (Cell = {}));
(function(Cell2) {
  function getCommonAncestor(...cells) {
    const ancestors = cells.filter((cell) => cell != null).map((cell) => cell.getAncestors()).sort((a, b) => {
      return a.length - b.length;
    });
    const first = ancestors.shift();
    return first.find((cell) => ancestors.every((item) => item.includes(cell))) || null;
  }
  Cell2.getCommonAncestor = getCommonAncestor;
  function getCellsBBox(cells, options = {}) {
    let bbox2 = null;
    for (let i = 0, ii = cells.length; i < ii; i += 1) {
      const cell = cells[i];
      let rect2 = cell.getBBox(options);
      if (rect2) {
        if (cell.isNode()) {
          const angle = cell.getAngle();
          if (angle != null && angle !== 0) {
            rect2 = rect2.bbox(angle);
          }
        }
        bbox2 = bbox2 == null ? rect2 : bbox2.union(rect2);
      }
    }
    return bbox2;
  }
  Cell2.getCellsBBox = getCellsBBox;
  function deepClone(cell) {
    const cells = [cell, ...cell.getDescendants({ deep: true })];
    return Cell2.cloneCells(cells);
  }
  Cell2.deepClone = deepClone;
  function cloneCells(cells) {
    const inputs = array_exports.uniq(cells);
    const cloneMap = inputs.reduce((map2, cell) => {
      map2[cell.id] = cell.clone();
      return map2;
    }, {});
    inputs.forEach((cell) => {
      const clone2 = cloneMap[cell.id];
      if (clone2.isEdge()) {
        const sourceId = clone2.getSourceCellId();
        const targetId = clone2.getTargetCellId();
        if (sourceId && cloneMap[sourceId]) {
          clone2.setSource(Object.assign(Object.assign({}, clone2.getSource()), { cell: cloneMap[sourceId].id }));
        }
        if (targetId && cloneMap[targetId]) {
          clone2.setTarget(Object.assign(Object.assign({}, clone2.getTarget()), { cell: cloneMap[targetId].id }));
        }
      }
      const parent2 = cell.getParent();
      if (parent2 && cloneMap[parent2.id]) {
        clone2.setParent(cloneMap[parent2.id]);
      }
      const children2 = cell.getChildren();
      if (children2 && children2.length) {
        const embeds = children2.reduce((memo, child) => {
          if (cloneMap[child.id]) {
            memo.push(cloneMap[child.id]);
          }
          return memo;
        }, []);
        if (embeds.length > 0) {
          clone2.setChildren(embeds);
        }
      }
    });
    return cloneMap;
  }
  Cell2.cloneCells = cloneCells;
})(Cell || (Cell = {}));
(function(Cell2) {
  Cell2.config({
    propHooks(_a) {
      var { tools } = _a, metadata = __rest15(_a, ["tools"]);
      if (tools) {
        metadata.tools = Cell2.normalizeTools(tools);
      }
      return metadata;
    }
  });
})(Cell || (Cell = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/model/registry.js
var ShareRegistry;
(function(ShareRegistry2) {
  let edgeRegistry;
  let nodeRegistry;
  function exist(name, isNode) {
    return isNode ? edgeRegistry != null && edgeRegistry.exist(name) : nodeRegistry != null && nodeRegistry.exist(name);
  }
  ShareRegistry2.exist = exist;
  function setEdgeRegistry(registry) {
    edgeRegistry = registry;
  }
  ShareRegistry2.setEdgeRegistry = setEdgeRegistry;
  function setNodeRegistry(registry) {
    nodeRegistry = registry;
  }
  ShareRegistry2.setNodeRegistry = setNodeRegistry;
})(ShareRegistry || (ShareRegistry = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/model/port.js
var PortManager = class {
  constructor(data2) {
    this.ports = [];
    this.groups = {};
    this.init(object_exports.cloneDeep(data2));
  }
  getPorts() {
    return this.ports;
  }
  getGroup(groupName) {
    return groupName != null ? this.groups[groupName] : null;
  }
  getPortsByGroup(groupName) {
    return this.ports.filter((p) => p.group === groupName || p.group == null && groupName == null);
  }
  getPortsLayoutByGroup(groupName, elemBBox) {
    const ports = this.getPortsByGroup(groupName);
    const group = groupName ? this.getGroup(groupName) : null;
    const groupPosition = group ? group.position : null;
    const groupPositionName = groupPosition ? groupPosition.name : null;
    let layoutFn;
    if (groupPositionName != null) {
      const fn = PortLayout.registry.get(groupPositionName);
      if (fn == null) {
        return PortLayout.registry.onNotFound(groupPositionName);
      }
      layoutFn = fn;
    } else {
      layoutFn = PortLayout.presets.left;
    }
    const portsArgs = ports.map((port2) => port2 && port2.position && port2.position.args || {});
    const groupArgs = groupPosition && groupPosition.args || {};
    const layouts = layoutFn(portsArgs, elemBBox, groupArgs);
    return layouts.map((portLayout, index2) => {
      const port2 = ports[index2];
      return {
        portLayout,
        portId: port2.id,
        portSize: port2.size,
        portAttrs: port2.attrs,
        labelSize: port2.label.size,
        labelLayout: this.getPortLabelLayout(port2, Point.create(portLayout.position), elemBBox)
      };
    });
  }
  init(data2) {
    const { groups, items } = data2;
    if (groups != null) {
      Object.keys(groups).forEach((key) => {
        this.groups[key] = this.parseGroup(groups[key]);
      });
    }
    if (Array.isArray(items)) {
      items.forEach((item) => {
        this.ports.push(this.parsePort(item));
      });
    }
  }
  parseGroup(group) {
    return Object.assign(Object.assign({}, group), { label: this.getLabel(group, true), position: this.getPortPosition(group.position, true) });
  }
  parsePort(port2) {
    const result2 = Object.assign({}, port2);
    const group = this.getGroup(port2.group) || {};
    result2.markup = result2.markup || group.markup;
    result2.attrs = object_exports.merge({}, group.attrs, result2.attrs);
    result2.position = this.createPosition(group, result2);
    result2.label = object_exports.merge({}, group.label, this.getLabel(result2));
    result2.zIndex = this.getZIndex(group, result2);
    result2.size = Object.assign(Object.assign({}, group.size), result2.size);
    return result2;
  }
  getZIndex(group, port2) {
    if (typeof port2.zIndex === "number") {
      return port2.zIndex;
    }
    if (typeof group.zIndex === "number" || group.zIndex === "auto") {
      return group.zIndex;
    }
    return "auto";
  }
  createPosition(group, port2) {
    return object_exports.merge({
      name: "left",
      args: {}
    }, group.position, { args: port2.args });
  }
  getPortPosition(position2, setDefault = false) {
    if (position2 == null) {
      if (setDefault) {
        return { name: "left", args: {} };
      }
    } else {
      if (typeof position2 === "string") {
        return {
          name: position2,
          args: {}
        };
      }
      if (Array.isArray(position2)) {
        return {
          name: "absolute",
          args: { x: position2[0], y: position2[1] }
        };
      }
      if (typeof position2 === "object") {
        return position2;
      }
    }
    return { args: {} };
  }
  getPortLabelPosition(position2, setDefault = false) {
    if (position2 == null) {
      if (setDefault) {
        return { name: "left", args: {} };
      }
    } else {
      if (typeof position2 === "string") {
        return {
          name: position2,
          args: {}
        };
      }
      if (typeof position2 === "object") {
        return position2;
      }
    }
    return { args: {} };
  }
  getLabel(item, setDefaults = false) {
    const label = item.label || {};
    label.position = this.getPortLabelPosition(label.position, setDefaults);
    return label;
  }
  getPortLabelLayout(port2, portPosition, elemBBox) {
    const name = port2.label.position.name || "left";
    const args = port2.label.position.args || {};
    const layoutFn = PortLabelLayout.registry.get(name) || PortLabelLayout.presets.left;
    if (layoutFn) {
      return layoutFn(portPosition, elemBBox, args);
    }
    return null;
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/model/node.js
var __rest16 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Node2 = class _Node extends Cell {
  get [Symbol.toStringTag]() {
    return _Node.toStringTag;
  }
  constructor(metadata = {}) {
    super(metadata);
    this.initPorts();
  }
  preprocess(metadata, ignoreIdCheck) {
    const { x, y, width: width2, height: height2 } = metadata, others = __rest16(metadata, ["x", "y", "width", "height"]);
    if (x != null || y != null) {
      const position2 = others.position;
      others.position = Object.assign(Object.assign({}, position2), { x: x != null ? x : position2 ? position2.x : 0, y: y != null ? y : position2 ? position2.y : 0 });
    }
    if (width2 != null || height2 != null) {
      const size2 = others.size;
      others.size = Object.assign(Object.assign({}, size2), { width: width2 != null ? width2 : size2 ? size2.width : 0, height: height2 != null ? height2 : size2 ? size2.height : 0 });
    }
    return super.preprocess(others, ignoreIdCheck);
  }
  isNode() {
    return true;
  }
  size(width2, height2, options) {
    if (width2 === void 0) {
      return this.getSize();
    }
    if (typeof width2 === "number") {
      return this.setSize(width2, height2, options);
    }
    return this.setSize(width2, height2);
  }
  getSize() {
    const size2 = this.store.get("size");
    return size2 ? Object.assign({}, size2) : { width: 1, height: 1 };
  }
  setSize(width2, height2, options) {
    if (typeof width2 === "object") {
      this.resize(width2.width, width2.height, height2);
    } else {
      this.resize(width2, height2, options);
    }
    return this;
  }
  resize(width2, height2, options = {}) {
    this.startBatch("resize", options);
    const direction = options.direction;
    if (direction) {
      const currentSize = this.getSize();
      switch (direction) {
        case "left":
        case "right":
          height2 = currentSize.height;
          break;
        case "top":
        case "bottom":
          width2 = currentSize.width;
          break;
        default:
          break;
      }
      const map2 = {
        right: 0,
        "top-right": 0,
        top: 1,
        "top-left": 1,
        left: 2,
        "bottom-left": 2,
        bottom: 3,
        "bottom-right": 3
      };
      let quadrant = map2[direction];
      const angle = Angle.normalize(this.getAngle() || 0);
      if (options.absolute) {
        quadrant += Math.floor((angle + 45) / 90);
        quadrant %= 4;
      }
      const bbox2 = this.getBBox();
      let fixedPoint;
      if (quadrant === 0) {
        fixedPoint = bbox2.getBottomLeft();
      } else if (quadrant === 1) {
        fixedPoint = bbox2.getCorner();
      } else if (quadrant === 2) {
        fixedPoint = bbox2.getTopRight();
      } else {
        fixedPoint = bbox2.getOrigin();
      }
      const imageFixedPoint = fixedPoint.clone().rotate(-angle, bbox2.getCenter());
      const radius = Math.sqrt(width2 * width2 + height2 * height2) / 2;
      let alpha = quadrant * Math.PI / 2;
      alpha += Math.atan(quadrant % 2 === 0 ? height2 / width2 : width2 / height2);
      alpha -= Angle.toRad(angle);
      const center2 = Point.fromPolar(radius, alpha, imageFixedPoint);
      const origin = center2.clone().translate(width2 / -2, height2 / -2);
      this.store.set("size", { width: width2, height: height2 }, options);
      this.setPosition(origin.x, origin.y, options);
    } else {
      this.store.set("size", { width: width2, height: height2 }, options);
    }
    this.stopBatch("resize", options);
    return this;
  }
  scale(sx, sy, origin, options = {}) {
    const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? void 0 : origin);
    this.startBatch("scale", options);
    this.setPosition(scaledBBox.x, scaledBBox.y, options);
    this.resize(scaledBBox.width, scaledBBox.height, options);
    this.stopBatch("scale");
    return this;
  }
  position(arg0, arg1, arg2) {
    if (typeof arg0 === "number") {
      return this.setPosition(arg0, arg1, arg2);
    }
    return this.getPosition(arg0);
  }
  getPosition(options = {}) {
    if (options.relative) {
      const parent2 = this.getParent();
      if (parent2 != null && parent2.isNode()) {
        const currentPosition = this.getPosition();
        const parentPosition = parent2.getPosition();
        return {
          x: currentPosition.x - parentPosition.x,
          y: currentPosition.y - parentPosition.y
        };
      }
    }
    const pos = this.store.get("position");
    return pos ? Object.assign({}, pos) : { x: 0, y: 0 };
  }
  setPosition(arg0, arg1, arg2 = {}) {
    let x;
    let y;
    let options;
    if (typeof arg0 === "object") {
      x = arg0.x;
      y = arg0.y;
      options = arg1 || {};
    } else {
      x = arg0;
      y = arg1;
      options = arg2 || {};
    }
    if (options.relative) {
      const parent2 = this.getParent();
      if (parent2 != null && parent2.isNode()) {
        const parentPosition = parent2.getPosition();
        x += parentPosition.x;
        y += parentPosition.y;
      }
    }
    if (options.deep) {
      const currentPosition = this.getPosition();
      this.translate(x - currentPosition.x, y - currentPosition.y, options);
    } else {
      this.store.set("position", { x, y }, options);
    }
    return this;
  }
  translate(tx = 0, ty = 0, options = {}) {
    if (tx === 0 && ty === 0) {
      return this;
    }
    options.translateBy = options.translateBy || this.id;
    const position2 = this.getPosition();
    if (options.restrict != null && options.translateBy === this.id) {
      const bbox2 = this.getBBox({ deep: true });
      const ra = options.restrict;
      const dx = position2.x - bbox2.x;
      const dy = position2.y - bbox2.y;
      const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox2.width, position2.x + tx));
      const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox2.height, position2.y + ty));
      tx = x - position2.x;
      ty = y - position2.y;
    }
    const translatedPosition = {
      x: position2.x + tx,
      y: position2.y + ty
    };
    options.tx = tx;
    options.ty = ty;
    if (options.transition) {
      if (typeof options.transition !== "object") {
        options.transition = {};
      }
      this.transition("position", translatedPosition, Object.assign(Object.assign({}, options.transition), { interp: Interp.object }));
      this.eachChild((child) => {
        var _a;
        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);
        if (!excluded) {
          child.translate(tx, ty, options);
        }
      });
    } else {
      this.startBatch("translate", options);
      this.store.set("position", translatedPosition, options);
      this.eachChild((child) => {
        var _a;
        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);
        if (!excluded) {
          child.translate(tx, ty, options);
        }
      });
      this.stopBatch("translate", options);
    }
    return this;
  }
  angle(val, options) {
    if (val == null) {
      return this.getAngle();
    }
    return this.rotate(val, options);
  }
  getAngle() {
    return this.store.get("angle", 0);
  }
  rotate(angle, options = {}) {
    const currentAngle = this.getAngle();
    if (options.center) {
      const size2 = this.getSize();
      const position2 = this.getPosition();
      const center2 = this.getBBox().getCenter();
      center2.rotate(currentAngle - angle, options.center);
      const dx = center2.x - size2.width / 2 - position2.x;
      const dy = center2.y - size2.height / 2 - position2.y;
      this.startBatch("rotate", { angle, options });
      this.setPosition(position2.x + dx, position2.y + dy, options);
      this.rotate(angle, Object.assign(Object.assign({}, options), { center: null }));
      this.stopBatch("rotate");
    } else {
      this.store.set("angle", options.absolute ? angle : (currentAngle + angle) % 360, options);
    }
    return this;
  }
  // #endregion
  // #region common
  getBBox(options = {}) {
    if (options.deep) {
      const cells = this.getDescendants({ deep: true, breadthFirst: true });
      cells.push(this);
      return Cell.getCellsBBox(cells);
    }
    return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());
  }
  getConnectionPoint(edge, type) {
    const bbox2 = this.getBBox();
    const center2 = bbox2.getCenter();
    const terminal = edge.getTerminal(type);
    if (terminal == null) {
      return center2;
    }
    const portId = terminal.port;
    if (!portId || !this.hasPort(portId)) {
      return center2;
    }
    const port2 = this.getPort(portId);
    if (!port2 || !port2.group) {
      return center2;
    }
    const layouts = this.getPortsPosition(port2.group);
    const position2 = layouts[portId].position;
    const portCenter = Point.create(position2).translate(bbox2.getOrigin());
    const angle = this.getAngle();
    if (angle) {
      portCenter.rotate(-angle, center2);
    }
    return portCenter;
  }
  /**
   * Sets cell's size and position based on the children bbox and given padding.
   */
  fit(options = {}) {
    const children2 = this.getChildren() || [];
    const embeds = children2.filter((cell) => cell.isNode());
    if (embeds.length === 0) {
      return this;
    }
    this.startBatch("fit-embeds", options);
    if (options.deep) {
      embeds.forEach((cell) => cell.fit(options));
    }
    let { x, y, width: width2, height: height2 } = Cell.getCellsBBox(embeds);
    const padding = number_exports.normalizeSides(options.padding);
    x -= padding.left;
    y -= padding.top;
    width2 += padding.left + padding.right;
    height2 += padding.bottom + padding.top;
    this.store.set({
      position: { x, y },
      size: { width: width2, height: height2 }
    }, options);
    this.stopBatch("fit-embeds");
    return this;
  }
  // #endregion
  // #region ports
  get portContainerMarkup() {
    return this.getPortContainerMarkup();
  }
  set portContainerMarkup(markup) {
    this.setPortContainerMarkup(markup);
  }
  getDefaultPortContainerMarkup() {
    return this.store.get("defaultPortContainerMarkup") || Markup.getPortContainerMarkup();
  }
  getPortContainerMarkup() {
    return this.store.get("portContainerMarkup") || this.getDefaultPortContainerMarkup();
  }
  setPortContainerMarkup(markup, options = {}) {
    this.store.set("portContainerMarkup", Markup.clone(markup), options);
    return this;
  }
  get portMarkup() {
    return this.getPortMarkup();
  }
  set portMarkup(markup) {
    this.setPortMarkup(markup);
  }
  getDefaultPortMarkup() {
    return this.store.get("defaultPortMarkup") || Markup.getPortMarkup();
  }
  getPortMarkup() {
    return this.store.get("portMarkup") || this.getDefaultPortMarkup();
  }
  setPortMarkup(markup, options = {}) {
    this.store.set("portMarkup", Markup.clone(markup), options);
    return this;
  }
  get portLabelMarkup() {
    return this.getPortLabelMarkup();
  }
  set portLabelMarkup(markup) {
    this.setPortLabelMarkup(markup);
  }
  getDefaultPortLabelMarkup() {
    return this.store.get("defaultPortLabelMarkup") || Markup.getPortLabelMarkup();
  }
  getPortLabelMarkup() {
    return this.store.get("portLabelMarkup") || this.getDefaultPortLabelMarkup();
  }
  setPortLabelMarkup(markup, options = {}) {
    this.store.set("portLabelMarkup", Markup.clone(markup), options);
    return this;
  }
  get ports() {
    const res = this.store.get("ports", { items: [] });
    if (res.items == null) {
      res.items = [];
    }
    return res;
  }
  getPorts() {
    return object_exports.cloneDeep(this.ports.items);
  }
  getPortsByGroup(groupName) {
    return this.getPorts().filter((port2) => port2.group === groupName);
  }
  getPort(portId) {
    return object_exports.cloneDeep(this.ports.items.find((port2) => port2.id && port2.id === portId));
  }
  getPortAt(index2) {
    return this.ports.items[index2] || null;
  }
  hasPorts() {
    return this.ports.items.length > 0;
  }
  hasPort(portId) {
    return this.getPortIndex(portId) !== -1;
  }
  getPortIndex(port2) {
    const portId = typeof port2 === "string" ? port2 : port2.id;
    return portId != null ? this.ports.items.findIndex((item) => item.id === portId) : -1;
  }
  getPortsPosition(groupName) {
    const size2 = this.getSize();
    const layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size2.width, size2.height));
    return layouts.reduce((memo, item) => {
      const layout = item.portLayout;
      memo[item.portId] = {
        position: Object.assign({}, layout.position),
        angle: layout.angle || 0
      };
      return memo;
    }, {});
  }
  getPortProp(portId, path2) {
    return this.getPropByPath(this.prefixPortPath(portId, path2));
  }
  setPortProp(portId, arg1, arg2, arg3) {
    if (typeof arg1 === "string" || Array.isArray(arg1)) {
      const path3 = this.prefixPortPath(portId, arg1);
      const value2 = arg2;
      return this.setPropByPath(path3, value2, arg3);
    }
    const path2 = this.prefixPortPath(portId);
    const value = arg1;
    return this.setPropByPath(path2, value, arg2);
  }
  removePortProp(portId, path2, options) {
    if (typeof path2 === "string" || Array.isArray(path2)) {
      return this.removePropByPath(this.prefixPortPath(portId, path2), options);
    }
    return this.removePropByPath(this.prefixPortPath(portId), path2);
  }
  portProp(portId, path2, value, options) {
    if (path2 == null) {
      return this.getPortProp(portId);
    }
    if (typeof path2 === "string" || Array.isArray(path2)) {
      if (arguments.length === 2) {
        return this.getPortProp(portId, path2);
      }
      if (value == null) {
        return this.removePortProp(portId, path2, options);
      }
      return this.setPortProp(portId, path2, value, options);
    }
    return this.setPortProp(portId, path2, value);
  }
  prefixPortPath(portId, path2) {
    const index2 = this.getPortIndex(portId);
    if (index2 === -1) {
      throw new Error(`Unable to find port with id: "${portId}"`);
    }
    if (path2 == null || path2 === "") {
      return ["ports", "items", `${index2}`];
    }
    if (Array.isArray(path2)) {
      return ["ports", "items", `${index2}`, ...path2];
    }
    return `ports/items/${index2}/${path2}`;
  }
  addPort(port2, options) {
    const ports = [...this.ports.items];
    ports.push(port2);
    this.setPropByPath("ports/items", ports, options);
    return this;
  }
  addPorts(ports, options) {
    this.setPropByPath("ports/items", [...this.ports.items, ...ports], options);
    return this;
  }
  insertPort(index2, port2, options) {
    const ports = [...this.ports.items];
    ports.splice(index2, 0, port2);
    this.setPropByPath("ports/items", ports, options);
    return this;
  }
  removePort(port2, options = {}) {
    return this.removePortAt(this.getPortIndex(port2), options);
  }
  removePortAt(index2, options = {}) {
    if (index2 >= 0) {
      const ports = [...this.ports.items];
      ports.splice(index2, 1);
      options.rewrite = true;
      this.setPropByPath("ports/items", ports, options);
    }
    return this;
  }
  removePorts(portsForRemoval, opt) {
    let options;
    if (Array.isArray(portsForRemoval)) {
      options = opt || {};
      if (portsForRemoval.length) {
        options.rewrite = true;
        const currentPorts = [...this.ports.items];
        const remainingPorts = currentPorts.filter((cp) => !portsForRemoval.some((p) => {
          const id = typeof p === "string" ? p : p.id;
          return cp.id === id;
        }));
        this.setPropByPath("ports/items", remainingPorts, options);
      }
    } else {
      options = portsForRemoval || {};
      options.rewrite = true;
      this.setPropByPath("ports/items", [], options);
    }
    return this;
  }
  getParsedPorts() {
    return this.port.getPorts();
  }
  getParsedGroups() {
    return this.port.groups;
  }
  getPortsLayoutByGroup(groupName, bbox2) {
    return this.port.getPortsLayoutByGroup(groupName, bbox2);
  }
  initPorts() {
    this.updatePortData();
    this.on("change:ports", () => {
      this.processRemovedPort();
      this.updatePortData();
    });
  }
  processRemovedPort() {
    const current = this.ports;
    const currentItemsMap = {};
    current.items.forEach((item) => {
      if (item.id) {
        currentItemsMap[item.id] = true;
      }
    });
    const removed = {};
    const previous = this.store.getPrevious("ports") || {
      items: []
    };
    previous.items.forEach((item) => {
      if (item.id && !currentItemsMap[item.id]) {
        removed[item.id] = true;
      }
    });
    const model = this.model;
    if (model && !object_exports.isEmpty(removed)) {
      const incomings = model.getConnectedEdges(this, { incoming: true });
      incomings.forEach((edge) => {
        const portId = edge.getTargetPortId();
        if (portId && removed[portId]) {
          edge.remove();
        }
      });
      const outgoings = model.getConnectedEdges(this, { outgoing: true });
      outgoings.forEach((edge) => {
        const portId = edge.getSourcePortId();
        if (portId && removed[portId]) {
          edge.remove();
        }
      });
    }
  }
  validatePorts() {
    const ids = {};
    const errors = [];
    this.ports.items.forEach((p) => {
      if (typeof p !== "object") {
        errors.push(`Invalid port ${p}.`);
      }
      if (p.id == null) {
        p.id = this.generatePortId();
      }
      if (ids[p.id]) {
        errors.push("Duplicitied port id.");
      }
      ids[p.id] = true;
    });
    return errors;
  }
  generatePortId() {
    return string_exports.uuid();
  }
  updatePortData() {
    const err = this.validatePorts();
    if (err.length > 0) {
      this.store.set("ports", this.store.getPrevious("ports"));
      throw new Error(err.join(" "));
    }
    const prev = this.port ? this.port.getPorts() : null;
    this.port = new PortManager(this.ports);
    const curr = this.port.getPorts();
    const added = prev ? curr.filter((item) => {
      if (!prev.find((prevPort) => prevPort.id === item.id)) {
        return item;
      }
      return null;
    }) : [...curr];
    const removed = prev ? prev.filter((item) => {
      if (!curr.find((curPort) => curPort.id === item.id)) {
        return item;
      }
      return null;
    }) : [];
    if (added.length > 0) {
      this.notify("ports:added", { added, cell: this, node: this });
    }
    if (removed.length > 0) {
      this.notify("ports:removed", { removed, cell: this, node: this });
    }
  }
};
Node2.defaults = {
  angle: 0,
  position: { x: 0, y: 0 },
  size: { width: 1, height: 1 }
};
(function(Node3) {
  Node3.toStringTag = `X6.${Node3.name}`;
  function isNode(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Node3) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const node = instance;
    if ((tag == null || tag === Node3.toStringTag) && typeof node.isNode === "function" && typeof node.isEdge === "function" && typeof node.prop === "function" && typeof node.attr === "function" && typeof node.size === "function" && typeof node.position === "function") {
      return true;
    }
    return false;
  }
  Node3.isNode = isNode;
})(Node2 || (Node2 = {}));
(function(Node3) {
  Node3.config({
    propHooks(_a) {
      var { ports } = _a, metadata = __rest16(_a, ["ports"]);
      if (ports) {
        metadata.ports = Array.isArray(ports) ? { items: ports } : ports;
      }
      return metadata;
    }
  });
})(Node2 || (Node2 = {}));
(function(Node3) {
  Node3.registry = Registry.create({
    type: "node",
    process(shape, options) {
      if (ShareRegistry.exist(shape, true)) {
        throw new Error(`Node with name '${shape}' was registered by anthor Edge`);
      }
      if (typeof options === "function") {
        options.config({ shape });
        return options;
      }
      let parent2 = Node3;
      const { inherit: inherit2 } = options, config = __rest16(options, ["inherit"]);
      if (inherit2) {
        if (typeof inherit2 === "string") {
          const base = this.get(inherit2);
          if (base == null) {
            this.onNotFound(inherit2, "inherited");
          } else {
            parent2 = base;
          }
        } else {
          parent2 = inherit2;
        }
      }
      if (config.constructorName == null) {
        config.constructorName = shape;
      }
      const ctor = parent2.define.call(parent2, config);
      ctor.config({ shape });
      return ctor;
    }
  });
  ShareRegistry.setNodeRegistry(Node3.registry);
})(Node2 || (Node2 = {}));
(function(Node3) {
  let counter = 0;
  function getClassName(name) {
    if (name) {
      return string_exports.pascalCase(name);
    }
    counter += 1;
    return `CustomNode${counter}`;
  }
  function define(config) {
    const { constructorName, overwrite } = config, others = __rest16(config, ["constructorName", "overwrite"]);
    const ctor = object_exports.createClass(getClassName(constructorName || others.shape), this);
    ctor.config(others);
    if (others.shape) {
      Node3.registry.register(others.shape, ctor, overwrite);
    }
    return ctor;
  }
  Node3.define = define;
  function create2(options) {
    const shape = options.shape || "rect";
    const Ctor = Node3.registry.get(shape);
    if (Ctor) {
      return new Ctor(options);
    }
    return Node3.registry.onNotFound(shape);
  }
  Node3.create = create2;
})(Node2 || (Node2 = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/model/edge.js
var __rest17 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Edge = class _Edge extends Cell {
  get [Symbol.toStringTag]() {
    return _Edge.toStringTag;
  }
  constructor(metadata = {}) {
    super(metadata);
  }
  preprocess(metadata, ignoreIdCheck) {
    const { source, sourceCell, sourcePort, sourcePoint, target, targetCell, targetPort, targetPoint } = metadata, others = __rest17(metadata, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]);
    const data2 = others;
    const isValidId = (val) => typeof val === "string" || typeof val === "number";
    if (source != null) {
      if (Cell.isCell(source)) {
        data2.source = { cell: source.id };
      } else if (isValidId(source)) {
        data2.source = { cell: source };
      } else if (Point.isPoint(source)) {
        data2.source = source.toJSON();
      } else if (Array.isArray(source)) {
        data2.source = { x: source[0], y: source[1] };
      } else {
        const cell = source.cell;
        if (Cell.isCell(cell)) {
          data2.source = Object.assign(Object.assign({}, source), { cell: cell.id });
        } else {
          data2.source = source;
        }
      }
    }
    if (sourceCell != null || sourcePort != null) {
      let terminal = data2.source;
      if (sourceCell != null) {
        const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;
        if (terminal) {
          terminal.cell = id;
        } else {
          terminal = data2.source = { cell: id };
        }
      }
      if (sourcePort != null && terminal) {
        terminal.port = sourcePort;
      }
    } else if (sourcePoint != null) {
      data2.source = Point.create(sourcePoint).toJSON();
    }
    if (target != null) {
      if (Cell.isCell(target)) {
        data2.target = { cell: target.id };
      } else if (isValidId(target)) {
        data2.target = { cell: target };
      } else if (Point.isPoint(target)) {
        data2.target = target.toJSON();
      } else if (Array.isArray(target)) {
        data2.target = { x: target[0], y: target[1] };
      } else {
        const cell = target.cell;
        if (Cell.isCell(cell)) {
          data2.target = Object.assign(Object.assign({}, target), { cell: cell.id });
        } else {
          data2.target = target;
        }
      }
    }
    if (targetCell != null || targetPort != null) {
      let terminal = data2.target;
      if (targetCell != null) {
        const id = isValidId(targetCell) ? targetCell : targetCell.id;
        if (terminal) {
          terminal.cell = id;
        } else {
          terminal = data2.target = { cell: id };
        }
      }
      if (targetPort != null && terminal) {
        terminal.port = targetPort;
      }
    } else if (targetPoint != null) {
      data2.target = Point.create(targetPoint).toJSON();
    }
    return super.preprocess(data2, ignoreIdCheck);
  }
  setup() {
    super.setup();
    this.on("change:labels", (args) => this.onLabelsChanged(args));
    this.on("change:vertices", (args) => this.onVertexsChanged(args));
  }
  isEdge() {
    return true;
  }
  // #region terminal
  disconnect(options = {}) {
    this.store.set({
      source: { x: 0, y: 0 },
      target: { x: 0, y: 0 }
    }, options);
    return this;
  }
  get source() {
    return this.getSource();
  }
  set source(data2) {
    this.setSource(data2);
  }
  getSource() {
    return this.getTerminal("source");
  }
  getSourceCellId() {
    return this.source.cell;
  }
  getSourcePortId() {
    return this.source.port;
  }
  setSource(source, args, options = {}) {
    return this.setTerminal("source", source, args, options);
  }
  get target() {
    return this.getTarget();
  }
  set target(data2) {
    this.setTarget(data2);
  }
  getTarget() {
    return this.getTerminal("target");
  }
  getTargetCellId() {
    return this.target.cell;
  }
  getTargetPortId() {
    return this.target.port;
  }
  setTarget(target, args, options = {}) {
    return this.setTerminal("target", target, args, options);
  }
  getTerminal(type) {
    return Object.assign({}, this.store.get(type));
  }
  setTerminal(type, terminal, args, options = {}) {
    if (Cell.isCell(terminal)) {
      this.store.set(type, object_exports.merge({}, args, { cell: terminal.id }), options);
      return this;
    }
    const p = terminal;
    if (Point.isPoint(terminal) || p.x != null && p.y != null) {
      this.store.set(type, object_exports.merge({}, args, { x: p.x, y: p.y }), options);
      return this;
    }
    this.store.set(type, object_exports.cloneDeep(terminal), options);
    return this;
  }
  getSourcePoint() {
    return this.getTerminalPoint("source");
  }
  getTargetPoint() {
    return this.getTerminalPoint("target");
  }
  getTerminalPoint(type) {
    const terminal = this[type];
    if (Point.isPointLike(terminal)) {
      return Point.create(terminal);
    }
    const cell = this.getTerminalCell(type);
    if (cell) {
      return cell.getConnectionPoint(this, type);
    }
    return new Point();
  }
  getSourceCell() {
    return this.getTerminalCell("source");
  }
  getTargetCell() {
    return this.getTerminalCell("target");
  }
  getTerminalCell(type) {
    if (this.model) {
      const cellId = type === "source" ? this.getSourceCellId() : this.getTargetCellId();
      if (cellId) {
        return this.model.getCell(cellId);
      }
    }
    return null;
  }
  getSourceNode() {
    return this.getTerminalNode("source");
  }
  getTargetNode() {
    return this.getTerminalNode("target");
  }
  getTerminalNode(type) {
    let cell = this;
    const visited = {};
    while (cell && cell.isEdge()) {
      if (visited[cell.id]) {
        return null;
      }
      visited[cell.id] = true;
      cell = cell.getTerminalCell(type);
    }
    return cell && cell.isNode() ? cell : null;
  }
  // #endregion
  // #region router
  get router() {
    return this.getRouter();
  }
  set router(data2) {
    if (data2 == null) {
      this.removeRouter();
    } else {
      this.setRouter(data2);
    }
  }
  getRouter() {
    return this.store.get("router");
  }
  setRouter(name, args, options) {
    if (typeof name === "object") {
      this.store.set("router", name, args);
    } else {
      this.store.set("router", { name, args }, options);
    }
    return this;
  }
  removeRouter(options = {}) {
    this.store.remove("router", options);
    return this;
  }
  // #endregion
  // #region connector
  get connector() {
    return this.getConnector();
  }
  set connector(data2) {
    if (data2 == null) {
      this.removeConnector();
    } else {
      this.setConnector(data2);
    }
  }
  getConnector() {
    return this.store.get("connector");
  }
  setConnector(name, args, options) {
    if (typeof name === "object") {
      this.store.set("connector", name, args);
    } else {
      this.store.set("connector", { name, args }, options);
    }
    return this;
  }
  removeConnector(options = {}) {
    return this.store.remove("connector", options);
  }
  // #endregion
  // #region labels
  getDefaultLabel() {
    const ctor = this.constructor;
    const defaults5 = this.store.get("defaultLabel") || ctor.defaultLabel || {};
    return object_exports.cloneDeep(defaults5);
  }
  get labels() {
    return this.getLabels();
  }
  set labels(labels) {
    this.setLabels(labels);
  }
  getLabels() {
    return [...this.store.get("labels", [])].map((item) => this.parseLabel(item));
  }
  setLabels(labels, options = {}) {
    this.store.set("labels", Array.isArray(labels) ? labels : [labels], options);
    return this;
  }
  insertLabel(label, index2, options = {}) {
    const labels = this.getLabels();
    const len = labels.length;
    let idx = index2 != null && Number.isFinite(index2) ? index2 : len;
    if (idx < 0) {
      idx = len + idx + 1;
    }
    labels.splice(idx, 0, this.parseLabel(label));
    return this.setLabels(labels, options);
  }
  appendLabel(label, options = {}) {
    return this.insertLabel(label, -1, options);
  }
  getLabelAt(index2) {
    const labels = this.getLabels();
    if (index2 != null && Number.isFinite(index2)) {
      return this.parseLabel(labels[index2]);
    }
    return null;
  }
  setLabelAt(index2, label, options = {}) {
    if (index2 != null && Number.isFinite(index2)) {
      const labels = this.getLabels();
      labels[index2] = this.parseLabel(label);
      this.setLabels(labels, options);
    }
    return this;
  }
  removeLabelAt(index2, options = {}) {
    const labels = this.getLabels();
    const idx = index2 != null && Number.isFinite(index2) ? index2 : -1;
    const removed = labels.splice(idx, 1);
    this.setLabels(labels, options);
    return removed.length ? removed[0] : null;
  }
  parseLabel(label) {
    if (typeof label === "string") {
      const ctor = this.constructor;
      return ctor.parseStringLabel(label);
    }
    return label;
  }
  onLabelsChanged({ previous, current }) {
    const added = previous && current ? current.filter((label1) => {
      if (!previous.find((label2) => label1 === label2 || object_exports.isEqual(label1, label2))) {
        return label1;
      }
      return null;
    }) : current ? [...current] : [];
    const removed = previous && current ? previous.filter((label1) => {
      if (!current.find((label2) => label1 === label2 || object_exports.isEqual(label1, label2))) {
        return label1;
      }
      return null;
    }) : previous ? [...previous] : [];
    if (added.length > 0) {
      this.notify("labels:added", { added, cell: this, edge: this });
    }
    if (removed.length > 0) {
      this.notify("labels:removed", { removed, cell: this, edge: this });
    }
  }
  // #endregion
  // #region vertices
  get vertices() {
    return this.getVertices();
  }
  set vertices(vertices) {
    this.setVertices(vertices);
  }
  getVertices() {
    return [...this.store.get("vertices", [])];
  }
  setVertices(vertices, options = {}) {
    const points = Array.isArray(vertices) ? vertices : [vertices];
    this.store.set("vertices", points.map((p) => Point.toJSON(p)), options);
    return this;
  }
  insertVertex(vertice, index2, options = {}) {
    const vertices = this.getVertices();
    const len = vertices.length;
    let idx = index2 != null && Number.isFinite(index2) ? index2 : len;
    if (idx < 0) {
      idx = len + idx + 1;
    }
    vertices.splice(idx, 0, Point.toJSON(vertice));
    return this.setVertices(vertices, options);
  }
  appendVertex(vertex, options = {}) {
    return this.insertVertex(vertex, -1, options);
  }
  getVertexAt(index2) {
    if (index2 != null && Number.isFinite(index2)) {
      const vertices = this.getVertices();
      return vertices[index2];
    }
    return null;
  }
  setVertexAt(index2, vertice, options = {}) {
    if (index2 != null && Number.isFinite(index2)) {
      const vertices = this.getVertices();
      vertices[index2] = vertice;
      this.setVertices(vertices, options);
    }
    return this;
  }
  removeVertexAt(index2, options = {}) {
    const vertices = this.getVertices();
    const idx = index2 != null && Number.isFinite(index2) ? index2 : -1;
    vertices.splice(idx, 1);
    return this.setVertices(vertices, options);
  }
  onVertexsChanged({ previous, current }) {
    const added = previous && current ? current.filter((p1) => {
      if (!previous.find((p2) => Point.equals(p1, p2))) {
        return p1;
      }
      return null;
    }) : current ? [...current] : [];
    const removed = previous && current ? previous.filter((p1) => {
      if (!current.find((p2) => Point.equals(p1, p2))) {
        return p1;
      }
      return null;
    }) : previous ? [...previous] : [];
    if (added.length > 0) {
      this.notify("vertexs:added", { added, cell: this, edge: this });
    }
    if (removed.length > 0) {
      this.notify("vertexs:removed", { removed, cell: this, edge: this });
    }
  }
  // #endregion
  // #region markup
  getDefaultMarkup() {
    return this.store.get("defaultMarkup") || Markup.getEdgeMarkup();
  }
  getMarkup() {
    return super.getMarkup() || this.getDefaultMarkup();
  }
  // #endregion
  // #region transform
  /**
   * Translate the edge vertices (and source and target if they are points)
   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
   */
  translate(tx, ty, options = {}) {
    options.translateBy = options.translateBy || this.id;
    options.tx = tx;
    options.ty = ty;
    return this.applyToPoints((p) => ({
      x: (p.x || 0) + tx,
      y: (p.y || 0) + ty
    }), options);
  }
  /**
   * Scales the edge's points (vertices) relative to the given origin.
   */
  scale(sx, sy, origin, options = {}) {
    return this.applyToPoints((p) => {
      return Point.create(p).scale(sx, sy, origin).toJSON();
    }, options);
  }
  applyToPoints(worker, options = {}) {
    const attrs = {};
    const source = this.getSource();
    const target = this.getTarget();
    if (Point.isPointLike(source)) {
      attrs.source = worker(source);
    }
    if (Point.isPointLike(target)) {
      attrs.target = worker(target);
    }
    const vertices = this.getVertices();
    if (vertices.length > 0) {
      attrs.vertices = vertices.map(worker);
    }
    this.store.set(attrs, options);
    return this;
  }
  // #endregion
  // #region common
  getBBox() {
    return this.getPolyline().bbox();
  }
  getConnectionPoint() {
    return this.getPolyline().pointAt(0.5);
  }
  getPolyline() {
    const points = [
      this.getSourcePoint(),
      ...this.getVertices().map((vertice) => Point.create(vertice)),
      this.getTargetPoint()
    ];
    return new Polyline(points);
  }
  updateParent(options) {
    let newParent = null;
    const source = this.getSourceCell();
    const target = this.getTargetCell();
    const prevParent = this.getParent();
    if (source && target) {
      if (source === target || source.isDescendantOf(target)) {
        newParent = target;
      } else if (target.isDescendantOf(source)) {
        newParent = source;
      } else {
        newParent = Cell.getCommonAncestor(source, target);
      }
    }
    if (prevParent && newParent && newParent.id !== prevParent.id) {
      prevParent.unembed(this, options);
    }
    if (newParent && (!prevParent || prevParent.id !== newParent.id)) {
      newParent.embed(this, options);
    }
    return newParent;
  }
  hasLoop(options = {}) {
    const source = this.getSource();
    const target = this.getTarget();
    const sourceId = source.cell;
    const targetId = target.cell;
    if (!sourceId || !targetId) {
      return false;
    }
    let loop3 = sourceId === targetId;
    if (!loop3 && options.deep && this._model) {
      const sourceCell = this.getSourceCell();
      const targetCell = this.getTargetCell();
      if (sourceCell && targetCell) {
        loop3 = sourceCell.isAncestorOf(targetCell, options) || targetCell.isAncestorOf(sourceCell, options);
      }
    }
    return loop3;
  }
  getFragmentAncestor() {
    const cells = [this, this.getSourceNode(), this.getTargetNode()].filter((item) => item != null);
    return this.getCommonAncestor(...cells);
  }
  isFragmentDescendantOf(cell) {
    const ancestor = this.getFragmentAncestor();
    return !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell));
  }
};
Edge.defaults = {};
(function(Edge3) {
  function equalTerminals(a, b) {
    const a1 = a;
    const b1 = b;
    if (a1.cell === b1.cell) {
      return a1.port === b1.port || a1.port == null && b1.port == null;
    }
    return false;
  }
  Edge3.equalTerminals = equalTerminals;
})(Edge || (Edge = {}));
(function(Edge3) {
  Edge3.defaultLabel = {
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      text: {
        fill: "#000",
        fontSize: 14,
        textAnchor: "middle",
        textVerticalAnchor: "middle",
        pointerEvents: "none"
      },
      rect: {
        ref: "label",
        fill: "#fff",
        rx: 3,
        ry: 3,
        refWidth: 1,
        refHeight: 1,
        refX: 0,
        refY: 0
      }
    },
    position: {
      distance: 0.5
    }
  };
  function parseStringLabel(text3) {
    return {
      attrs: { label: { text: text3 } }
    };
  }
  Edge3.parseStringLabel = parseStringLabel;
})(Edge || (Edge = {}));
(function(Edge3) {
  Edge3.toStringTag = `X6.${Edge3.name}`;
  function isEdge(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Edge3) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const edge = instance;
    if ((tag == null || tag === Edge3.toStringTag) && typeof edge.isNode === "function" && typeof edge.isEdge === "function" && typeof edge.prop === "function" && typeof edge.attr === "function" && typeof edge.disconnect === "function" && typeof edge.getSource === "function" && typeof edge.getTarget === "function") {
      return true;
    }
    return false;
  }
  Edge3.isEdge = isEdge;
})(Edge || (Edge = {}));
(function(Edge3) {
  Edge3.registry = Registry.create({
    type: "edge",
    process(shape, options) {
      if (ShareRegistry.exist(shape, false)) {
        throw new Error(`Edge with name '${shape}' was registered by anthor Node`);
      }
      if (typeof options === "function") {
        options.config({ shape });
        return options;
      }
      let parent2 = Edge3;
      const { inherit: inherit2 = "edge" } = options, others = __rest17(options, ["inherit"]);
      if (typeof inherit2 === "string") {
        const base = this.get(inherit2 || "edge");
        if (base == null && inherit2) {
          this.onNotFound(inherit2, "inherited");
        } else {
          parent2 = base;
        }
      } else {
        parent2 = inherit2;
      }
      if (others.constructorName == null) {
        others.constructorName = shape;
      }
      const ctor = parent2.define.call(parent2, others);
      ctor.config({ shape });
      return ctor;
    }
  });
  ShareRegistry.setEdgeRegistry(Edge3.registry);
})(Edge || (Edge = {}));
(function(Edge3) {
  let counter = 0;
  function getClassName(name) {
    if (name) {
      return string_exports.pascalCase(name);
    }
    counter += 1;
    return `CustomEdge${counter}`;
  }
  function define(config) {
    const { constructorName, overwrite } = config, others = __rest17(config, ["constructorName", "overwrite"]);
    const ctor = object_exports.createClass(getClassName(constructorName || others.shape), this);
    ctor.config(others);
    if (others.shape) {
      Edge3.registry.register(others.shape, ctor, overwrite);
    }
    return ctor;
  }
  Edge3.define = define;
  function create2(options) {
    const shape = options.shape || "edge";
    const Ctor = Edge3.registry.get(shape);
    if (Ctor) {
      return new Ctor(options);
    }
    return Edge3.registry.onNotFound(shape);
  }
  Edge3.create = create2;
})(Edge || (Edge = {}));
(function(Edge3) {
  const shape = "basic.edge";
  Edge3.config({
    shape,
    propHooks(metadata) {
      const { label, vertices } = metadata, others = __rest17(metadata, ["label", "vertices"]);
      if (label) {
        if (others.labels == null) {
          others.labels = [];
        }
        const formated = typeof label === "string" ? Edge3.parseStringLabel(label) : label;
        others.labels.push(formated);
      }
      if (vertices) {
        if (Array.isArray(vertices)) {
          others.vertices = vertices.map((item) => Point.create(item).toJSON());
        }
      }
      return others;
    }
  });
  Edge3.registry.register(shape, Edge3);
})(Edge || (Edge = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/model/collection.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Collection = class extends Basecoat {
  constructor(cells, options = {}) {
    super();
    this.length = 0;
    this.comparator = options.comparator || "zIndex";
    this.clean();
    if (cells) {
      this.reset(cells, { silent: true });
    }
  }
  toJSON() {
    return this.cells.map((cell) => cell.toJSON());
  }
  add(cells, index2, options) {
    let localIndex;
    let localOptions;
    if (typeof index2 === "number") {
      localIndex = index2;
      localOptions = Object.assign({ merge: false }, options);
    } else {
      localIndex = this.length;
      localOptions = Object.assign({ merge: false }, index2);
    }
    if (localIndex > this.length) {
      localIndex = this.length;
    }
    if (localIndex < 0) {
      localIndex += this.length + 1;
    }
    const entities = Array.isArray(cells) ? cells : [cells];
    const sortable = this.comparator && typeof index2 !== "number" && localOptions.sort !== false;
    const sortAttr = this.comparator || null;
    let sort = false;
    const added = [];
    const merged = [];
    entities.forEach((cell) => {
      const existing = this.get(cell);
      if (existing) {
        if (localOptions.merge && !cell.isSameStore(existing)) {
          existing.setProp(cell.getProp(), options);
          merged.push(existing);
          if (sortable && !sort) {
            if (sortAttr == null || typeof sortAttr === "function") {
              sort = existing.hasChanged();
            } else if (typeof sortAttr === "string") {
              sort = existing.hasChanged(sortAttr);
            } else {
              sort = sortAttr.some((key) => existing.hasChanged(key));
            }
          }
        }
      } else {
        added.push(cell);
        this.reference(cell);
      }
    });
    if (added.length) {
      if (sortable) {
        sort = true;
      }
      this.cells.splice(localIndex, 0, ...added);
      this.length = this.cells.length;
    }
    if (sort) {
      this.sort({ silent: true });
    }
    if (!localOptions.silent) {
      added.forEach((cell, i) => {
        const args = {
          cell,
          index: localIndex + i,
          options: localOptions
        };
        this.trigger("added", args);
        if (!localOptions.dryrun) {
          cell.notify("added", Object.assign({}, args));
        }
      });
      if (sort) {
        this.trigger("sorted");
      }
      if (added.length || merged.length) {
        this.trigger("updated", {
          added,
          merged,
          removed: [],
          options: localOptions
        });
      }
    }
    return this;
  }
  remove(cells, options = {}) {
    const arr = Array.isArray(cells) ? cells : [cells];
    const removed = this.removeCells(arr, options);
    if (!options.silent && removed.length > 0) {
      this.trigger("updated", {
        options,
        removed,
        added: [],
        merged: []
      });
    }
    return Array.isArray(cells) ? removed : removed[0];
  }
  removeCells(cells, options) {
    const removed = [];
    for (let i = 0; i < cells.length; i += 1) {
      const cell = this.get(cells[i]);
      if (cell == null) {
        continue;
      }
      const index2 = this.cells.indexOf(cell);
      this.cells.splice(index2, 1);
      this.length -= 1;
      delete this.map[cell.id];
      removed.push(cell);
      this.unreference(cell);
      if (!options.dryrun) {
        cell.remove();
      }
      if (!options.silent) {
        this.trigger("removed", { cell, index: index2, options });
        if (!options.dryrun) {
          cell.notify("removed", { cell, index: index2, options });
        }
      }
    }
    return removed;
  }
  reset(cells, options = {}) {
    const previous = this.cells.slice();
    previous.forEach((cell) => this.unreference(cell));
    this.clean();
    this.add(cells, Object.assign({ silent: true }, options));
    if (!options.silent) {
      const current = this.cells.slice();
      this.trigger("reseted", {
        options,
        previous,
        current
      });
      const added = [];
      const removed = [];
      current.forEach((a) => {
        const exist = previous.some((b) => b.id === a.id);
        if (!exist) {
          added.push(a);
        }
      });
      previous.forEach((a) => {
        const exist = current.some((b) => b.id === a.id);
        if (!exist) {
          removed.push(a);
        }
      });
      this.trigger("updated", { options, added, removed, merged: [] });
    }
    return this;
  }
  push(cell, options) {
    return this.add(cell, this.length, options);
  }
  pop(options) {
    const cell = this.at(this.length - 1);
    return this.remove(cell, options);
  }
  unshift(cell, options) {
    return this.add(cell, 0, options);
  }
  shift(options) {
    const cell = this.at(0);
    return this.remove(cell, options);
  }
  get(cell) {
    if (cell == null) {
      return null;
    }
    const id = typeof cell === "string" || typeof cell === "number" ? cell : cell.id;
    return this.map[id] || null;
  }
  has(cell) {
    return this.get(cell) != null;
  }
  at(index2) {
    if (index2 < 0) {
      index2 += this.length;
    }
    return this.cells[index2] || null;
  }
  first() {
    return this.at(0);
  }
  last() {
    return this.at(-1);
  }
  indexOf(cell) {
    return this.cells.indexOf(cell);
  }
  toArray() {
    return this.cells.slice();
  }
  sort(options = {}) {
    if (this.comparator != null) {
      this.cells = array_exports.sortBy(this.cells, this.comparator);
      if (!options.silent) {
        this.trigger("sorted");
      }
    }
    return this;
  }
  clone() {
    const constructor = this.constructor;
    return new constructor(this.cells.slice(), {
      comparator: this.comparator
    });
  }
  reference(cell) {
    this.map[cell.id] = cell;
    cell.on("*", this.notifyCellEvent, this);
  }
  unreference(cell) {
    cell.off("*", this.notifyCellEvent, this);
    delete this.map[cell.id];
  }
  notifyCellEvent(name, args) {
    const cell = args.cell;
    this.trigger(`cell:${name}`, args);
    if (cell) {
      if (cell.isNode()) {
        this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), { node: cell }));
      } else if (cell.isEdge()) {
        this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: cell }));
      }
    }
  }
  clean() {
    this.length = 0;
    this.cells = [];
    this.map = {};
  }
  dispose() {
    this.reset([]);
  }
};
__decorate6([
  Collection.dispose()
], Collection.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/model/model.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Model = class _Model extends Basecoat {
  get [Symbol.toStringTag]() {
    return _Model.toStringTag;
  }
  constructor(cells = []) {
    super();
    this.batches = {};
    this.addings = /* @__PURE__ */ new WeakMap();
    this.nodes = {};
    this.edges = {};
    this.outgoings = {};
    this.incomings = {};
    this.collection = new Collection(cells);
    this.setup();
  }
  notify(name, args) {
    this.trigger(name, args);
    const graph = this.graph;
    if (graph) {
      if (name === "sorted" || name === "reseted" || name === "updated") {
        graph.trigger(`model:${name}`, args);
      } else {
        graph.trigger(name, args);
      }
    }
    return this;
  }
  setup() {
    const collection = this.collection;
    collection.on("sorted", () => this.notify("sorted", null));
    collection.on("updated", (args) => this.notify("updated", args));
    collection.on("cell:change:zIndex", () => this.sortOnChangeZ());
    collection.on("added", ({ cell }) => {
      this.onCellAdded(cell);
    });
    collection.on("removed", (args) => {
      const cell = args.cell;
      this.onCellRemoved(cell, args.options);
      this.notify("cell:removed", args);
      if (cell.isNode()) {
        this.notify("node:removed", Object.assign(Object.assign({}, args), { node: cell }));
      } else if (cell.isEdge()) {
        this.notify("edge:removed", Object.assign(Object.assign({}, args), { edge: cell }));
      }
    });
    collection.on("reseted", (args) => {
      this.onReset(args.current);
      this.notify("reseted", args);
    });
    collection.on("edge:change:source", ({ edge }) => this.onEdgeTerminalChanged(edge, "source"));
    collection.on("edge:change:target", ({ edge }) => {
      this.onEdgeTerminalChanged(edge, "target");
    });
  }
  sortOnChangeZ() {
    this.collection.sort();
  }
  onCellAdded(cell) {
    const cellId = cell.id;
    if (cell.isEdge()) {
      cell.updateParent();
      this.edges[cellId] = true;
      this.onEdgeTerminalChanged(cell, "source");
      this.onEdgeTerminalChanged(cell, "target");
    } else {
      this.nodes[cellId] = true;
    }
  }
  onCellRemoved(cell, options) {
    const cellId = cell.id;
    if (cell.isEdge()) {
      delete this.edges[cellId];
      const source = cell.getSource();
      const target = cell.getTarget();
      if (source && source.cell) {
        const cache = this.outgoings[source.cell];
        const index2 = cache ? cache.indexOf(cellId) : -1;
        if (index2 >= 0) {
          cache.splice(index2, 1);
          if (cache.length === 0) {
            delete this.outgoings[source.cell];
          }
        }
      }
      if (target && target.cell) {
        const cache = this.incomings[target.cell];
        const index2 = cache ? cache.indexOf(cellId) : -1;
        if (index2 >= 0) {
          cache.splice(index2, 1);
          if (cache.length === 0) {
            delete this.incomings[target.cell];
          }
        }
      }
    } else {
      delete this.nodes[cellId];
    }
    if (!options.clear) {
      if (options.disconnectEdges) {
        this.disconnectConnectedEdges(cell, options);
      } else {
        this.removeConnectedEdges(cell, options);
      }
    }
    if (cell.model === this) {
      cell.model = null;
    }
  }
  onReset(cells) {
    this.nodes = {};
    this.edges = {};
    this.outgoings = {};
    this.incomings = {};
    cells.forEach((cell) => this.onCellAdded(cell));
  }
  onEdgeTerminalChanged(edge, type) {
    const ref2 = type === "source" ? this.outgoings : this.incomings;
    const prev = edge.previous(type);
    if (prev && prev.cell) {
      const cellId = Cell.isCell(prev.cell) ? prev.cell.id : prev.cell;
      const cache = ref2[cellId];
      const index2 = cache ? cache.indexOf(edge.id) : -1;
      if (index2 >= 0) {
        cache.splice(index2, 1);
        if (cache.length === 0) {
          delete ref2[cellId];
        }
      }
    }
    const terminal = edge.getTerminal(type);
    if (terminal && terminal.cell) {
      const terminalId = Cell.isCell(terminal.cell) ? terminal.cell.id : terminal.cell;
      const cache = ref2[terminalId] || [];
      const index2 = cache.indexOf(edge.id);
      if (index2 === -1) {
        cache.push(edge.id);
      }
      ref2[terminalId] = cache;
    }
  }
  prepareCell(cell, options) {
    if (!cell.model && (!options || !options.dryrun)) {
      cell.model = this;
    }
    if (cell.zIndex == null) {
      cell.setZIndex(this.getMaxZIndex() + 1, { silent: true });
    }
    return cell;
  }
  resetCells(cells, options = {}) {
    cells.map((cell) => this.prepareCell(cell, Object.assign(Object.assign({}, options), { dryrun: true })));
    this.collection.reset(cells, options);
    cells.map((cell) => this.prepareCell(cell, { options }));
    return this;
  }
  clear(options = {}) {
    const raw2 = this.getCells();
    if (raw2.length === 0) {
      return this;
    }
    const localOptions = Object.assign(Object.assign({}, options), { clear: true });
    this.batchUpdate("clear", () => {
      const cells = raw2.sort((a, b) => {
        const v1 = a.isEdge() ? 1 : 2;
        const v2 = b.isEdge() ? 1 : 2;
        return v1 - v2;
      });
      while (cells.length > 0) {
        const cell = cells.shift();
        if (cell) {
          cell.remove(localOptions);
        }
      }
    }, localOptions);
    return this;
  }
  addNode(metadata, options = {}) {
    const node = Node2.isNode(metadata) ? metadata : this.createNode(metadata);
    this.addCell(node, options);
    return node;
  }
  updateNode(metadata, options = {}) {
    const node = this.createNode(metadata);
    const prop2 = node.getProp();
    node.dispose();
    return this.updateCell(prop2, options);
  }
  createNode(metadata) {
    return Node2.create(metadata);
  }
  addEdge(metadata, options = {}) {
    const edge = Edge.isEdge(metadata) ? metadata : this.createEdge(metadata);
    this.addCell(edge, options);
    return edge;
  }
  createEdge(metadata) {
    return Edge.create(metadata);
  }
  updateEdge(metadata, options = {}) {
    const edge = this.createEdge(metadata);
    const prop2 = edge.getProp();
    edge.dispose();
    return this.updateCell(prop2, options);
  }
  addCell(cell, options = {}) {
    if (Array.isArray(cell)) {
      return this.addCells(cell, options);
    }
    if (!this.collection.has(cell) && !this.addings.has(cell)) {
      this.addings.set(cell, true);
      this.collection.add(this.prepareCell(cell, options), options);
      cell.eachChild((child) => this.addCell(child, options));
      this.addings.delete(cell);
    }
    return this;
  }
  addCells(cells, options = {}) {
    const count = cells.length;
    if (count === 0) {
      return this;
    }
    const localOptions = Object.assign(Object.assign({}, options), { position: count - 1, maxPosition: count - 1 });
    this.startBatch("add", Object.assign(Object.assign({}, localOptions), { cells }));
    cells.forEach((cell) => {
      this.addCell(cell, localOptions);
      localOptions.position -= 1;
    });
    this.stopBatch("add", Object.assign(Object.assign({}, localOptions), { cells }));
    return this;
  }
  updateCell(prop2, options = {}) {
    const existing = prop2.id && this.getCell(prop2.id);
    if (existing) {
      return this.batchUpdate("update", () => {
        Object.entries(prop2).forEach(([key, val]) => existing.setProp(key, val, options));
        return true;
      }, prop2);
    }
    return false;
  }
  removeCell(obj, options = {}) {
    const cell = typeof obj === "string" ? this.getCell(obj) : obj;
    if (cell && this.has(cell)) {
      return this.collection.remove(cell, options);
    }
    return null;
  }
  updateCellId(cell, newId) {
    if (cell.id === newId)
      return;
    this.startBatch("update", { id: newId });
    cell.prop("id", newId);
    const newCell = cell.clone({ keepId: true });
    this.addCell(newCell);
    const edges = this.getConnectedEdges(cell);
    edges.forEach((edge) => {
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();
      if (sourceCell === cell) {
        edge.setSource(Object.assign(Object.assign({}, edge.getSource()), { cell: newId }));
      }
      if (targetCell === cell) {
        edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { cell: newId }));
      }
    });
    this.removeCell(cell);
    this.stopBatch("update", { id: newId });
    return newCell;
  }
  removeCells(cells, options = {}) {
    if (cells.length) {
      return this.batchUpdate("remove", () => {
        return cells.map((cell) => this.removeCell(cell, options));
      });
    }
    return [];
  }
  removeConnectedEdges(cell, options = {}) {
    const edges = this.getConnectedEdges(cell);
    edges.forEach((edge) => {
      edge.remove(options);
    });
    return edges;
  }
  disconnectConnectedEdges(cell, options = {}) {
    const cellId = typeof cell === "string" ? cell : cell.id;
    this.getConnectedEdges(cell).forEach((edge) => {
      const sourceCellId = edge.getSourceCellId();
      const targetCellId = edge.getTargetCellId();
      if (sourceCellId === cellId) {
        edge.setSource({ x: 0, y: 0 }, options);
      }
      if (targetCellId === cellId) {
        edge.setTarget({ x: 0, y: 0 }, options);
      }
    });
  }
  has(obj) {
    return this.collection.has(obj);
  }
  total() {
    return this.collection.length;
  }
  indexOf(cell) {
    return this.collection.indexOf(cell);
  }
  /**
   * Returns a cell from the graph by its id.
   */
  getCell(id) {
    return this.collection.get(id);
  }
  /**
   * Returns all the nodes and edges in the graph.
   */
  getCells() {
    return this.collection.toArray();
  }
  /**
   * Returns the first cell (node or edge) in the graph. The first cell is
   * defined as the cell with the lowest `zIndex`.
   */
  getFirstCell() {
    return this.collection.first();
  }
  /**
   * Returns the last cell (node or edge) in the graph. The last cell is
   * defined as the cell with the highest `zIndex`.
   */
  getLastCell() {
    return this.collection.last();
  }
  /**
   * Returns the lowest `zIndex` value in the graph.
   */
  getMinZIndex() {
    const first = this.collection.first();
    return first ? first.getZIndex() || 0 : 0;
  }
  /**
   * Returns the highest `zIndex` value in the graph.
   */
  getMaxZIndex() {
    const last2 = this.collection.last();
    return last2 ? last2.getZIndex() || 0 : 0;
  }
  getCellsFromCache(cache) {
    return cache ? Object.keys(cache).map((id) => this.getCell(id)).filter((cell) => cell != null) : [];
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.getCellsFromCache(this.nodes);
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.getCellsFromCache(this.edges);
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(cell) {
    const cellId = typeof cell === "string" ? cell : cell.id;
    const cellIds = this.outgoings[cellId];
    return cellIds ? cellIds.map((id) => this.getCell(id)).filter((cell2) => cell2 && cell2.isEdge()) : null;
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(cell) {
    const cellId = typeof cell === "string" ? cell : cell.id;
    const cellIds = this.incomings[cellId];
    return cellIds ? cellIds.map((id) => this.getCell(id)).filter((cell2) => cell2 && cell2.isEdge()) : null;
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(cell, options = {}) {
    const result2 = [];
    const node = typeof cell === "string" ? this.getCell(cell) : cell;
    if (node == null) {
      return result2;
    }
    const cache = {};
    const indirect = options.indirect;
    let incoming = options.incoming;
    let outgoing = options.outgoing;
    if (incoming == null && outgoing == null) {
      incoming = outgoing = true;
    }
    const collect = (cell2, isOutgoing) => {
      const edges = isOutgoing ? this.getOutgoingEdges(cell2) : this.getIncomingEdges(cell2);
      if (edges != null) {
        edges.forEach((edge) => {
          if (cache[edge.id]) {
            return;
          }
          result2.push(edge);
          cache[edge.id] = true;
          if (indirect) {
            if (incoming) {
              collect(edge, false);
            }
            if (outgoing) {
              collect(edge, true);
            }
          }
        });
      }
      if (indirect && cell2.isEdge()) {
        const terminal = isOutgoing ? cell2.getTargetCell() : cell2.getSourceCell();
        if (terminal && terminal.isEdge()) {
          if (!cache[terminal.id]) {
            result2.push(terminal);
            collect(terminal, isOutgoing);
          }
        }
      }
    };
    if (outgoing) {
      collect(node, true);
    }
    if (incoming) {
      collect(node, false);
    }
    if (options.deep) {
      const descendants = node.getDescendants({ deep: true });
      const embedsCache = {};
      descendants.forEach((cell2) => {
        if (cell2.isNode()) {
          embedsCache[cell2.id] = true;
        }
      });
      const collectSub = (cell2, isOutgoing) => {
        const edges = isOutgoing ? this.getOutgoingEdges(cell2.id) : this.getIncomingEdges(cell2.id);
        if (edges != null) {
          edges.forEach((edge) => {
            if (!cache[edge.id]) {
              const sourceCell = edge.getSourceCell();
              const targetCell = edge.getTargetCell();
              if (!options.enclosed && sourceCell && embedsCache[sourceCell.id] && targetCell && embedsCache[targetCell.id]) {
                return;
              }
              result2.push(edge);
              cache[edge.id] = true;
            }
          });
        }
      };
      descendants.forEach((cell2) => {
        if (cell2.isEdge()) {
          return;
        }
        if (outgoing) {
          collectSub(cell2, true);
        }
        if (incoming) {
          collectSub(cell2, false);
        }
      });
    }
    return result2;
  }
  isBoundary(cell, isOrigin) {
    const node = typeof cell === "string" ? this.getCell(cell) : cell;
    const arr = isOrigin ? this.getIncomingEdges(node) : this.getOutgoingEdges(node);
    return arr == null || arr.length === 0;
  }
  getBoundaryNodes(isOrigin) {
    const result2 = [];
    Object.keys(this.nodes).forEach((nodeId) => {
      if (this.isBoundary(nodeId, isOrigin)) {
        const node = this.getCell(nodeId);
        if (node) {
          result2.push(node);
        }
      }
    });
    return result2;
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRoots() {
    return this.getBoundaryNodes(true);
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafs() {
    return this.getBoundaryNodes(false);
  }
  /**
   * Returns `true` if the node is a root node, i.e. there is no edges
   * coming to the node.
   */
  isRoot(cell) {
    return this.isBoundary(cell, true);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e. there is no edges
   * going out from the node.
   */
  isLeaf(cell) {
    return this.isBoundary(cell, false);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(cell, options = {}) {
    let incoming = options.incoming;
    let outgoing = options.outgoing;
    if (incoming == null && outgoing == null) {
      incoming = outgoing = true;
    }
    const edges = this.getConnectedEdges(cell, options);
    const map2 = edges.reduce((memo, edge) => {
      const hasLoop = edge.hasLoop(options);
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();
      if (incoming && sourceCell && sourceCell.isNode() && !memo[sourceCell.id]) {
        if (hasLoop || sourceCell !== cell && (!options.deep || !sourceCell.isDescendantOf(cell))) {
          memo[sourceCell.id] = sourceCell;
        }
      }
      if (outgoing && targetCell && targetCell.isNode() && !memo[targetCell.id]) {
        if (hasLoop || targetCell !== cell && (!options.deep || !targetCell.isDescendantOf(cell))) {
          memo[targetCell.id] = targetCell;
        }
      }
      return memo;
    }, {});
    if (cell.isEdge()) {
      if (incoming) {
        const sourceCell = cell.getSourceCell();
        if (sourceCell && sourceCell.isNode() && !map2[sourceCell.id]) {
          map2[sourceCell.id] = sourceCell;
        }
      }
      if (outgoing) {
        const targetCell = cell.getTargetCell();
        if (targetCell && targetCell.isNode() && !map2[targetCell.id]) {
          map2[targetCell.id] = targetCell;
        }
      }
    }
    return Object.keys(map2).map((id) => map2[id]);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(cell1, cell2, options = {}) {
    let incoming = options.incoming;
    let outgoing = options.outgoing;
    if (incoming == null && outgoing == null) {
      incoming = outgoing = true;
    }
    return this.getConnectedEdges(cell1, options).some((edge) => {
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();
      if (incoming && sourceCell && sourceCell.id === cell2.id) {
        return true;
      }
      if (outgoing && targetCell && targetCell.id === cell2.id) {
        return true;
      }
      return false;
    });
  }
  getSuccessors(cell, options = {}) {
    const successors = [];
    this.search(cell, (curr, distance) => {
      if (curr !== cell && this.matchDistance(distance, options.distance)) {
        successors.push(curr);
      }
    }, Object.assign(Object.assign({}, options), { outgoing: true }));
    return successors;
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(cell1, cell2, options = {}) {
    let result2 = false;
    this.search(cell1, (curr, distance) => {
      if (curr === cell2 && curr !== cell1 && this.matchDistance(distance, options.distance)) {
        result2 = true;
        return false;
      }
    }, Object.assign(Object.assign({}, options), { outgoing: true }));
    return result2;
  }
  getPredecessors(cell, options = {}) {
    const predecessors = [];
    this.search(cell, (curr, distance) => {
      if (curr !== cell && this.matchDistance(distance, options.distance)) {
        predecessors.push(curr);
      }
    }, Object.assign(Object.assign({}, options), { incoming: true }));
    return predecessors;
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(cell1, cell2, options = {}) {
    let result2 = false;
    this.search(cell1, (curr, distance) => {
      if (curr === cell2 && curr !== cell1 && this.matchDistance(distance, options.distance)) {
        result2 = true;
        return false;
      }
    }, Object.assign(Object.assign({}, options), { incoming: true }));
    return result2;
  }
  matchDistance(distance, preset) {
    if (preset == null) {
      return true;
    }
    if (typeof preset === "function") {
      return preset(distance);
    }
    if (Array.isArray(preset) && preset.includes(distance)) {
      return true;
    }
    return distance === preset;
  }
  /**
   * Returns the common ancestor of the passed cells.
   */
  getCommonAncestor(...cells) {
    const arr = [];
    cells.forEach((item) => {
      if (item) {
        if (Array.isArray(item)) {
          arr.push(...item);
        } else {
          arr.push(item);
        }
      }
    });
    return Cell.getCommonAncestor(...arr);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(cells, options = {}) {
    const subgraph = [];
    const cache = {};
    const nodes = [];
    const edges = [];
    const collect = (cell) => {
      if (!cache[cell.id]) {
        subgraph.push(cell);
        cache[cell.id] = cell;
        if (cell.isEdge()) {
          edges.push(cell);
        }
        if (cell.isNode()) {
          nodes.push(cell);
        }
      }
    };
    cells.forEach((cell) => {
      collect(cell);
      if (options.deep) {
        const descendants = cell.getDescendants({ deep: true });
        descendants.forEach((descendant) => collect(descendant));
      }
    });
    edges.forEach((edge) => {
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();
      if (sourceCell && !cache[sourceCell.id]) {
        subgraph.push(sourceCell);
        cache[sourceCell.id] = sourceCell;
        if (sourceCell.isNode()) {
          nodes.push(sourceCell);
        }
      }
      if (targetCell && !cache[targetCell.id]) {
        subgraph.push(targetCell);
        cache[targetCell.id] = targetCell;
        if (targetCell.isNode()) {
          nodes.push(targetCell);
        }
      }
    });
    nodes.forEach((node) => {
      const edges2 = this.getConnectedEdges(node, options);
      edges2.forEach((edge) => {
        const sourceCell = edge.getSourceCell();
        const targetCell = edge.getTargetCell();
        if (!cache[edge.id] && sourceCell && cache[sourceCell.id] && targetCell && cache[targetCell.id]) {
          subgraph.push(edge);
          cache[edge.id] = edge;
        }
      });
    });
    return subgraph;
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(cells, options = {}) {
    const subgraph = this.getSubGraph(cells, options);
    return this.cloneCells(subgraph);
  }
  cloneCells(cells) {
    return Cell.cloneCells(cells);
  }
  getNodesFromPoint(x, y) {
    const p = typeof x === "number" ? { x, y: y || 0 } : x;
    return this.getNodes().filter((node) => {
      return node.getBBox().containsPoint(p);
    });
  }
  getNodesInArea(x, y, w, h, options) {
    const rect2 = typeof x === "number" ? new Rectangle(x, y, w, h) : Rectangle.create(x);
    const opts = typeof x === "number" ? options : y;
    const strict = opts && opts.strict;
    return this.getNodes().filter((node) => {
      const bbox2 = node.getBBox();
      return strict ? rect2.containsRect(bbox2) : rect2.isIntersectWithRect(bbox2);
    });
  }
  getEdgesInArea(x, y, w, h, options) {
    const rect2 = typeof x === "number" ? new Rectangle(x, y, w, h) : Rectangle.create(x);
    const opts = typeof x === "number" ? options : y;
    const strict = opts && opts.strict;
    return this.getEdges().filter((edge) => {
      const bbox2 = edge.getBBox();
      if (bbox2.width === 0) {
        bbox2.inflate(1, 0);
      } else if (bbox2.height === 0) {
        bbox2.inflate(0, 1);
      }
      return strict ? rect2.containsRect(bbox2) : rect2.isIntersectWithRect(bbox2);
    });
  }
  getNodesUnderNode(node, options = {}) {
    const bbox2 = node.getBBox();
    const nodes = options.by == null || options.by === "bbox" ? this.getNodesInArea(bbox2) : this.getNodesFromPoint(bbox2[options.by]);
    return nodes.filter((curr) => node.id !== curr.id && !curr.isDescendantOf(node));
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.getCellsBBox(this.getCells());
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(cells, options = {}) {
    return Cell.getCellsBBox(cells, options);
  }
  // #region search
  search(cell, iterator, options = {}) {
    if (options.breadthFirst) {
      this.breadthFirstSearch(cell, iterator, options);
    } else {
      this.depthFirstSearch(cell, iterator, options);
    }
  }
  breadthFirstSearch(cell, iterator, options = {}) {
    const queue = [];
    const visited = {};
    const distance = {};
    queue.push(cell);
    distance[cell.id] = 0;
    while (queue.length > 0) {
      const next = queue.shift();
      if (next == null || visited[next.id]) {
        continue;
      }
      visited[next.id] = true;
      if (main_exports.call(iterator, this, next, distance[next.id]) === false) {
        continue;
      }
      const neighbors = this.getNeighbors(next, options);
      neighbors.forEach((neighbor) => {
        distance[neighbor.id] = distance[next.id] + 1;
        queue.push(neighbor);
      });
    }
  }
  depthFirstSearch(cell, iterator, options = {}) {
    const queue = [];
    const visited = {};
    const distance = {};
    queue.push(cell);
    distance[cell.id] = 0;
    while (queue.length > 0) {
      const next = queue.pop();
      if (next == null || visited[next.id]) {
        continue;
      }
      visited[next.id] = true;
      if (main_exports.call(iterator, this, next, distance[next.id]) === false) {
        continue;
      }
      const neighbors = this.getNeighbors(next, options);
      const lastIndex = queue.length;
      neighbors.forEach((neighbor) => {
        distance[neighbor.id] = distance[next.id] + 1;
        queue.splice(lastIndex, 0, neighbor);
      });
    }
  }
  // #endregion
  // #region shortest path
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(source, target, options = {}) {
    const adjacencyList = {};
    this.getEdges().forEach((edge) => {
      const sourceId2 = edge.getSourceCellId();
      const targetId2 = edge.getTargetCellId();
      if (sourceId2 && targetId2) {
        if (!adjacencyList[sourceId2]) {
          adjacencyList[sourceId2] = [];
        }
        if (!adjacencyList[targetId2]) {
          adjacencyList[targetId2] = [];
        }
        adjacencyList[sourceId2].push(targetId2);
        if (!options.directed) {
          adjacencyList[targetId2].push(sourceId2);
        }
      }
    });
    const sourceId = typeof source === "string" ? source : source.id;
    const previous = Dijkstra.run(adjacencyList, sourceId, options.weight);
    const path2 = [];
    let targetId = typeof target === "string" ? target : target.id;
    if (previous[targetId]) {
      path2.push(targetId);
    }
    while (targetId = previous[targetId]) {
      path2.unshift(targetId);
    }
    return path2;
  }
  // #endregion
  // #region transform
  /**
   * Translate all cells in the graph by `tx` and `ty` pixels.
   */
  translate(tx, ty, options) {
    this.getCells().filter((cell) => !cell.hasParent()).forEach((cell) => cell.translate(tx, ty, options));
    return this;
  }
  resize(width2, height2, options) {
    return this.resizeCells(width2, height2, this.getCells(), options);
  }
  resizeCells(width2, height2, cells, options = {}) {
    const bbox2 = this.getCellsBBox(cells);
    if (bbox2) {
      const sx = Math.max(width2 / bbox2.width, 0);
      const sy = Math.max(height2 / bbox2.height, 0);
      const origin = bbox2.getOrigin();
      cells.forEach((cell) => cell.scale(sx, sy, origin, options));
    }
    return this;
  }
  // #endregion
  // #region serialize/deserialize
  toJSON(options = {}) {
    return _Model.toJSON(this.getCells(), options);
  }
  parseJSON(data2) {
    return _Model.fromJSON(data2);
  }
  fromJSON(data2, options = {}) {
    const cells = this.parseJSON(data2);
    this.resetCells(cells, options);
    return this;
  }
  // #endregion
  // #region batch
  startBatch(name, data2 = {}) {
    this.batches[name] = (this.batches[name] || 0) + 1;
    this.notify("batch:start", { name, data: data2 });
    return this;
  }
  stopBatch(name, data2 = {}) {
    this.batches[name] = (this.batches[name] || 0) - 1;
    this.notify("batch:stop", { name, data: data2 });
    return this;
  }
  batchUpdate(name, execute, data2 = {}) {
    this.startBatch(name, data2);
    const result2 = execute();
    this.stopBatch(name, data2);
    return result2;
  }
  hasActiveBatch(name = Object.keys(this.batches)) {
    const names = Array.isArray(name) ? name : [name];
    return names.some((batch) => this.batches[batch] > 0);
  }
  // #endregion
  dispose() {
    this.collection.dispose();
  }
};
__decorate7([
  Model.dispose()
], Model.prototype, "dispose", null);
(function(Model2) {
  Model2.toStringTag = `X6.${Model2.name}`;
  function isModel(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Model2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const model = instance;
    if ((tag == null || tag === Model2.toStringTag) && typeof model.addNode === "function" && typeof model.addEdge === "function" && model.collection != null) {
      return true;
    }
    return false;
  }
  Model2.isModel = isModel;
})(Model || (Model = {}));
(function(Model2) {
  function toJSON(cells, options = {}) {
    return {
      cells: cells.map((cell) => cell.toJSON(options))
    };
  }
  Model2.toJSON = toJSON;
  function fromJSON(data2) {
    const cells = [];
    if (Array.isArray(data2)) {
      cells.push(...data2);
    } else {
      if (data2.cells) {
        cells.push(...data2.cells);
      }
      if (data2.nodes) {
        data2.nodes.forEach((node) => {
          if (node.shape == null) {
            node.shape = "rect";
          }
          cells.push(node);
        });
      }
      if (data2.edges) {
        data2.edges.forEach((edge) => {
          if (edge.shape == null) {
            edge.shape = "edge";
          }
          cells.push(edge);
        });
      }
    }
    return cells.map((cell) => {
      const type = cell.shape;
      if (type) {
        if (Node2.registry.exist(type)) {
          return Node2.create(cell);
        }
        if (Edge.registry.exist(type)) {
          return Edge.create(cell);
        }
      }
      throw new Error("The `shape` should be specified when creating a node/edge instance");
    });
  }
  Model2.fromJSON = fromJSON;
})(Model || (Model = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/base.js
var __rest18 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Base = class extends Node2 {
  get label() {
    return this.getLabel();
  }
  set label(val) {
    this.setLabel(val);
  }
  getLabel() {
    return this.getAttrByPath("text/text");
  }
  setLabel(label, options) {
    if (label == null) {
      this.removeLabel();
    } else {
      this.setAttrByPath("text/text", label, options);
    }
    return this;
  }
  removeLabel() {
    this.removeAttrByPath("text/text");
    return this;
  }
};
(function(Base3) {
  Base3.bodyAttr = {
    fill: "#ffffff",
    stroke: "#333333",
    strokeWidth: 2
  };
  Base3.labelAttr = {
    fontSize: 14,
    fill: "#000000",
    refX: 0.5,
    refY: 0.5,
    textAnchor: "middle",
    textVerticalAnchor: "middle",
    fontFamily: "Arial, helvetica, sans-serif"
  };
  Base3.config({
    attrs: { text: Object.assign({}, Base3.labelAttr) },
    propHooks(metadata) {
      const { label } = metadata, others = __rest18(metadata, ["label"]);
      if (label) {
        object_exports.setByPath(others, "attrs/text/text", label);
      }
      return others;
    },
    visible: true
  });
})(Base || (Base = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/util.js
var __rest19 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function getMarkup(tagName2, selector = "body") {
  return [
    {
      tagName: tagName2,
      selector
    },
    {
      tagName: "text",
      selector: "label"
    }
  ];
}
function getImageUrlHook(attrName = "xlink:href") {
  const hook = (metadata) => {
    const { imageUrl, imageWidth, imageHeight } = metadata, others = __rest19(metadata, ["imageUrl", "imageWidth", "imageHeight"]);
    if (imageUrl != null || imageWidth != null || imageHeight != null) {
      const apply3 = () => {
        if (others.attrs) {
          const image = others.attrs.image;
          if (imageUrl != null) {
            image[attrName] = imageUrl;
          }
          if (imageWidth != null) {
            image.width = imageWidth;
          }
          if (imageHeight != null) {
            image.height = imageHeight;
          }
          others.attrs.image = image;
        }
      };
      if (others.attrs) {
        if (others.attrs.image == null) {
          others.attrs.image = {};
        }
        apply3();
      } else {
        others.attrs = {
          image: {}
        };
        apply3();
      }
    }
    return others;
  };
  return hook;
}
function createShape(shape, config, options = {}) {
  const defaults5 = {
    constructorName: shape,
    markup: getMarkup(shape, options.selector),
    attrs: {
      [shape]: Object.assign({}, Base.bodyAttr)
    }
  };
  const base = options.parent || Base;
  return base.define(object_exports.merge(defaults5, config, { shape }));
}

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/rect.js
var Rect = createShape("rect", {
  attrs: {
    body: {
      refWidth: "100%",
      refHeight: "100%"
    }
  }
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/edge.js
var Edge2 = Edge.define({
  shape: "edge",
  markup: [
    {
      tagName: "path",
      selector: "wrap",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        cursor: "pointer",
        stroke: "transparent",
        strokeLinecap: "round"
      }
    },
    {
      tagName: "path",
      selector: "line",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        pointerEvents: "none"
      }
    }
  ],
  attrs: {
    lines: {
      connection: true,
      strokeLinejoin: "round"
    },
    wrap: {
      strokeWidth: 10
    },
    line: {
      stroke: "#333",
      strokeWidth: 2,
      targetMarker: "classic"
    }
  }
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/ellipse.js
var Ellipse2 = createShape("ellipse", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refRx: "50%",
      refRy: "50%"
    }
  }
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/poly.js
var __rest20 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Poly = class _Poly extends Base {
  get points() {
    return this.getPoints();
  }
  set points(pts) {
    this.setPoints(pts);
  }
  getPoints() {
    return this.getAttrByPath("body/refPoints");
  }
  setPoints(points, options) {
    if (points == null) {
      this.removePoints();
    } else {
      this.setAttrByPath("body/refPoints", _Poly.pointsToString(points), options);
    }
    return this;
  }
  removePoints() {
    this.removeAttrByPath("body/refPoints");
    return this;
  }
};
(function(Poly2) {
  function pointsToString(points) {
    return typeof points === "string" ? points : points.map((p) => {
      if (Array.isArray(p)) {
        return p.join(",");
      }
      if (Point.isPointLike(p)) {
        return `${p.x}, ${p.y}`;
      }
      return "";
    }).join(" ");
  }
  Poly2.pointsToString = pointsToString;
  Poly2.config({
    propHooks(metadata) {
      const { points } = metadata, others = __rest20(metadata, ["points"]);
      if (points) {
        const data2 = pointsToString(points);
        if (data2) {
          object_exports.setByPath(others, "attrs/body/refPoints", data2);
        }
      }
      return others;
    }
  });
})(Poly || (Poly = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/polygon.js
var Polygon = createShape("polygon", {}, { parent: Poly });

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/polyline.js
var Polyline2 = createShape("polyline", {}, { parent: Poly });

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/path.js
var __rest21 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Path2 = Base.define({
  shape: "path",
  markup: [
    {
      tagName: "rect",
      selector: "bg"
    },
    {
      tagName: "path",
      selector: "body"
    },
    {
      tagName: "text",
      selector: "label"
    }
  ],
  attrs: {
    bg: {
      refWidth: "100%",
      refHeight: "100%",
      fill: "none",
      stroke: "none",
      pointerEvents: "all"
    },
    body: {
      fill: "none",
      stroke: "#000",
      strokeWidth: 2
    }
  },
  propHooks(metadata) {
    const { path: path2 } = metadata, others = __rest21(metadata, ["path"]);
    if (path2) {
      object_exports.setByPath(others, "attrs/body/refD", path2);
    }
    return others;
  }
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/text-block.js
var __rest22 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var TextBlock = Base.define({
  shape: "text-block",
  markup: [
    {
      tagName: "rect",
      selector: "body"
    },
    Platform.SUPPORT_FOREIGNOBJECT ? {
      tagName: "foreignObject",
      selector: "foreignObject",
      children: [
        {
          tagName: "div",
          ns: main_exports3.ns.xhtml,
          selector: "label",
          style: {
            width: "100%",
            height: "100%",
            position: "static",
            backgroundColor: "transparent",
            textAlign: "center",
            margin: 0,
            padding: "0px 5px",
            boxSizing: "border-box",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          }
        }
      ]
    } : {
      tagName: "text",
      selector: "label",
      attrs: {
        textAnchor: "middle"
      }
    }
  ],
  attrs: {
    body: Object.assign(Object.assign({}, Base.bodyAttr), { refWidth: "100%", refHeight: "100%" }),
    foreignObject: {
      refWidth: "100%",
      refHeight: "100%"
    },
    label: {
      style: {
        fontSize: 14
      }
    }
  },
  propHooks(metadata) {
    const { text: text3 } = metadata, others = __rest22(metadata, ["text"]);
    if (text3) {
      object_exports.setByPath(others, "attrs/label/text", text3);
    }
    return others;
  },
  attrHooks: {
    text: {
      set(text3, { cell, view, refBBox, elem, attrs }) {
        if (elem instanceof HTMLElement) {
          elem.textContent = text3;
        } else {
          const style2 = attrs.style || {};
          const wrapValue = { text: text3, width: -5, height: "100%" };
          const wrapAttrs = Object.assign({ textVerticalAnchor: "middle" }, style2);
          const textWrap2 = Attr.presets.textWrap;
          main_exports.call(textWrap2.set, this, wrapValue, {
            cell,
            view,
            elem,
            refBBox,
            attrs: wrapAttrs
          });
          return { fill: style2.color || null };
        }
      },
      position(text3, { refBBox, elem }) {
        if (elem instanceof SVGElement) {
          return refBBox.getCenter();
        }
      }
    }
  }
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/image.js
var Image = createShape("image", {
  attrs: {
    image: {
      refWidth: "100%",
      refHeight: "100%"
    }
  },
  propHooks: getImageUrlHook()
}, {
  selector: "image"
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/circle.js
var Circle = createShape("circle", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refR: "50%"
    }
  }
});

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/view/node.js
var NodeView = class _NodeView extends CellView {
  constructor() {
    super(...arguments);
    this.portsCache = {};
  }
  get [Symbol.toStringTag]() {
    return _NodeView.toStringTag;
  }
  getContainerClassName() {
    const classList = [
      super.getContainerClassName(),
      this.prefixClassName("node")
    ];
    if (!this.can("nodeMovable")) {
      classList.push(this.prefixClassName("node-immovable"));
    }
    return classList.join(" ");
  }
  updateClassName(e) {
    const target = e.target;
    if (target.hasAttribute("magnet")) {
      const className3 = this.prefixClassName("port-unconnectable");
      if (this.can("magnetConnectable")) {
        main_exports3.removeClass(target, className3);
      } else {
        main_exports3.addClass(target, className3);
      }
    } else {
      const className3 = this.prefixClassName("node-immovable");
      if (this.can("nodeMovable")) {
        this.removeClass(className3);
      } else {
        this.addClass(className3);
      }
    }
  }
  isNodeView() {
    return true;
  }
  confirmUpdate(flag, options = {}) {
    let ret = flag;
    if (this.hasAction(ret, "ports")) {
      this.removePorts();
      this.cleanPortsCache();
    }
    if (this.hasAction(ret, "render")) {
      this.render();
      ret = this.removeAction(ret, [
        "render",
        "update",
        "resize",
        "translate",
        "rotate",
        "ports",
        "tools"
      ]);
    } else {
      ret = this.handleAction(ret, "resize", () => this.resize(), "update");
      ret = this.handleAction(
        ret,
        "update",
        () => this.update(),
        // `update()` will render ports when useCSSSelectors are enabled
        Config.useCSSSelector ? "ports" : null
      );
      ret = this.handleAction(ret, "translate", () => this.translate());
      ret = this.handleAction(ret, "rotate", () => this.rotate());
      ret = this.handleAction(ret, "ports", () => this.renderPorts());
      ret = this.handleAction(ret, "tools", () => {
        if (this.getFlag("tools") === flag) {
          this.renderTools();
        } else {
          this.updateTools(options);
        }
      });
    }
    return ret;
  }
  update(partialAttrs) {
    this.cleanCache();
    if (Config.useCSSSelector) {
      this.removePorts();
    }
    const node = this.cell;
    const size2 = node.getSize();
    const attrs = node.getAttrs();
    this.updateAttrs(this.container, attrs, {
      attrs: partialAttrs === attrs ? null : partialAttrs,
      rootBBox: new Rectangle(0, 0, size2.width, size2.height),
      selectors: this.selectors
    });
    if (Config.useCSSSelector) {
      this.renderPorts();
    }
  }
  renderMarkup() {
    const markup = this.cell.markup;
    if (markup) {
      if (typeof markup === "string") {
        throw new TypeError("Not support string markup.");
      }
      return this.renderJSONMarkup(markup);
    }
    throw new TypeError("Invalid node markup.");
  }
  renderJSONMarkup(markup) {
    const ret = this.parseJSONMarkup(markup, this.container);
    this.selectors = ret.selectors;
    this.container.appendChild(ret.fragment);
  }
  render() {
    this.empty();
    this.renderMarkup();
    this.resize();
    this.updateTransform();
    if (!Config.useCSSSelector) {
      this.renderPorts();
    }
    this.renderTools();
    return this;
  }
  resize() {
    if (this.cell.getAngle()) {
      this.rotate();
    }
    this.update();
  }
  translate() {
    this.updateTransform();
  }
  rotate() {
    this.updateTransform();
  }
  getTranslationString() {
    const position2 = this.cell.getPosition();
    return `translate(${position2.x},${position2.y})`;
  }
  getRotationString() {
    const angle = this.cell.getAngle();
    if (angle) {
      const size2 = this.cell.getSize();
      return `rotate(${angle},${size2.width / 2},${size2.height / 2})`;
    }
  }
  updateTransform() {
    let transform3 = this.getTranslationString();
    const rot = this.getRotationString();
    if (rot) {
      transform3 += ` ${rot}`;
    }
    this.container.setAttribute("transform", transform3);
  }
  // #region ports
  findPortElem(portId, selector) {
    const cache = portId ? this.portsCache[portId] : null;
    if (!cache) {
      return null;
    }
    const portRoot = cache.portContentElement;
    const portSelectors = cache.portContentSelectors || {};
    return this.findOne(selector, portRoot, portSelectors);
  }
  cleanPortsCache() {
    this.portsCache = {};
  }
  removePorts() {
    Object.values(this.portsCache).forEach((cached) => {
      main_exports3.remove(cached.portElement);
    });
  }
  renderPorts() {
    const container = this.container;
    const references = [];
    container.childNodes.forEach((child) => {
      references.push(child);
    });
    const parsedPorts = this.cell.getParsedPorts();
    const portsGropsByZ = array_exports.groupBy(parsedPorts, "zIndex");
    const autoZIndexKey = "auto";
    if (portsGropsByZ[autoZIndexKey]) {
      portsGropsByZ[autoZIndexKey].forEach((port2) => {
        const portElement = this.getPortElement(port2);
        container.append(portElement);
        references.push(portElement);
      });
    }
    Object.keys(portsGropsByZ).forEach((key) => {
      if (key !== autoZIndexKey) {
        const zIndex = parseInt(key, 10);
        this.appendPorts(portsGropsByZ[key], zIndex, references);
      }
    });
    this.updatePorts();
  }
  appendPorts(ports, zIndex, refs) {
    const elems = ports.map((p) => this.getPortElement(p));
    if (refs[zIndex] || zIndex < 0) {
      main_exports3.before(refs[Math.max(zIndex, 0)], elems);
    } else {
      main_exports3.append(this.container, elems);
    }
  }
  getPortElement(port2) {
    const cached = this.portsCache[port2.id];
    if (cached) {
      return cached.portElement;
    }
    return this.createPortElement(port2);
  }
  createPortElement(port2) {
    let renderResult = Markup.renderMarkup(this.cell.getPortContainerMarkup());
    const portElement = renderResult.elem;
    if (portElement == null) {
      throw new Error("Invalid port container markup.");
    }
    renderResult = Markup.renderMarkup(this.getPortMarkup(port2));
    const portContentElement = renderResult.elem;
    const portContentSelectors = renderResult.selectors;
    if (portContentElement == null) {
      throw new Error("Invalid port markup.");
    }
    this.setAttrs({
      port: port2.id,
      "port-group": port2.group
    }, portContentElement);
    let portClass = "x6-port";
    if (port2.group) {
      portClass += ` x6-port-${port2.group}`;
    }
    main_exports3.addClass(portElement, portClass);
    main_exports3.addClass(portElement, "x6-port");
    main_exports3.addClass(portContentElement, "x6-port-body");
    portElement.appendChild(portContentElement);
    let portSelectors = portContentSelectors;
    let portLabelElement;
    let portLabelSelectors;
    const existLabel = this.existPortLabel(port2);
    if (existLabel) {
      renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port2.label));
      portLabelElement = renderResult.elem;
      portLabelSelectors = renderResult.selectors;
      if (portLabelElement == null) {
        throw new Error("Invalid port label markup.");
      }
      if (portContentSelectors && portLabelSelectors) {
        for (const key in portLabelSelectors) {
          if (portContentSelectors[key] && key !== this.rootSelector) {
            throw new Error("Selectors within port must be unique.");
          }
        }
        portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);
      }
      main_exports3.addClass(portLabelElement, "x6-port-label");
      portElement.appendChild(portLabelElement);
    }
    this.portsCache[port2.id] = {
      portElement,
      portSelectors,
      portLabelElement,
      portLabelSelectors,
      portContentElement,
      portContentSelectors
    };
    if (this.graph.options.onPortRendered) {
      this.graph.options.onPortRendered({
        port: port2,
        node: this.cell,
        container: portElement,
        selectors: portSelectors,
        labelContainer: portLabelElement,
        labelSelectors: portLabelSelectors,
        contentContainer: portContentElement,
        contentSelectors: portContentSelectors
      });
    }
    return portElement;
  }
  updatePorts() {
    const groups = this.cell.getParsedGroups();
    const groupList = Object.keys(groups);
    if (groupList.length === 0) {
      this.updatePortGroup();
    } else {
      groupList.forEach((groupName) => this.updatePortGroup(groupName));
    }
  }
  updatePortGroup(groupName) {
    const bbox2 = Rectangle.fromSize(this.cell.getSize());
    const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox2);
    for (let i = 0, n = metrics.length; i < n; i += 1) {
      const metric = metrics[i];
      const portId = metric.portId;
      const cached = this.portsCache[portId] || {};
      const portLayout = metric.portLayout;
      this.applyPortTransform(cached.portElement, portLayout);
      if (metric.portAttrs != null) {
        const options = {
          selectors: cached.portSelectors || {}
        };
        if (metric.portSize) {
          options.rootBBox = Rectangle.fromSize(metric.portSize);
        }
        this.updateAttrs(cached.portElement, metric.portAttrs, options);
      }
      const labelLayout = metric.labelLayout;
      if (labelLayout && cached.portLabelElement) {
        this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));
        if (labelLayout.attrs) {
          const options = {
            selectors: cached.portLabelSelectors || {}
          };
          if (metric.labelSize) {
            options.rootBBox = Rectangle.fromSize(metric.labelSize);
          }
          this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options);
        }
      }
    }
  }
  applyPortTransform(element, layout, initialAngle = 0) {
    const angle = layout.angle;
    const position2 = layout.position;
    const matrix = main_exports3.createSVGMatrix().rotate(initialAngle).translate(position2.x || 0, position2.y || 0).rotate(angle || 0);
    main_exports3.transform(element, matrix, { absolute: true });
  }
  getPortMarkup(port2) {
    return port2.markup || this.cell.portMarkup;
  }
  getPortLabelMarkup(label) {
    return label.markup || this.cell.portLabelMarkup;
  }
  existPortLabel(port2) {
    return port2.attrs && port2.attrs.text;
  }
  getEventArgs(e, x, y) {
    const view = this;
    const node = view.cell;
    const cell = node;
    if (x == null || y == null) {
      return { e, view, node, cell };
    }
    return { e, x, y, view, node, cell };
  }
  getPortEventArgs(e, port2, pos) {
    const view = this;
    const node = view.cell;
    const cell = node;
    if (pos) {
      return {
        e,
        x: pos.x,
        y: pos.y,
        view,
        node,
        cell,
        port: port2
      };
    }
    return { e, view, node, cell, port: port2 };
  }
  notifyMouseDown(e, x, y) {
    super.onMouseDown(e, x, y);
    this.notify("node:mousedown", this.getEventArgs(e, x, y));
  }
  notifyMouseMove(e, x, y) {
    super.onMouseMove(e, x, y);
    this.notify("node:mousemove", this.getEventArgs(e, x, y));
  }
  notifyMouseUp(e, x, y) {
    super.onMouseUp(e, x, y);
    this.notify("node:mouseup", this.getEventArgs(e, x, y));
  }
  notifyPortEvent(name, e, pos) {
    const port2 = this.findAttr("port", e.target);
    if (port2) {
      const originType = e.type;
      if (name === "node:port:mouseenter") {
        e.type = "mouseenter";
      } else if (name === "node:port:mouseleave") {
        e.type = "mouseleave";
      }
      this.notify(name, this.getPortEventArgs(e, port2, pos));
      e.type = originType;
    }
  }
  onClick(e, x, y) {
    super.onClick(e, x, y);
    this.notify("node:click", this.getEventArgs(e, x, y));
    this.notifyPortEvent("node:port:click", e, { x, y });
  }
  onDblClick(e, x, y) {
    super.onDblClick(e, x, y);
    this.notify("node:dblclick", this.getEventArgs(e, x, y));
    this.notifyPortEvent("node:port:dblclick", e, { x, y });
  }
  onContextMenu(e, x, y) {
    super.onContextMenu(e, x, y);
    this.notify("node:contextmenu", this.getEventArgs(e, x, y));
    this.notifyPortEvent("node:port:contextmenu", e, { x, y });
  }
  onMouseDown(e, x, y) {
    if (this.isPropagationStopped(e)) {
      return;
    }
    this.notifyMouseDown(e, x, y);
    this.notifyPortEvent("node:port:mousedown", e, { x, y });
    this.startNodeDragging(e, x, y);
  }
  onMouseMove(e, x, y) {
    const data2 = this.getEventData(e);
    const action = data2.action;
    if (action === "magnet") {
      this.dragMagnet(e, x, y);
    } else {
      if (action === "move") {
        const meta = data2;
        const view = meta.targetView || this;
        view.dragNode(e, x, y);
        view.notify("node:moving", {
          e,
          x,
          y,
          view,
          cell: view.cell,
          node: view.cell
        });
      }
      this.notifyMouseMove(e, x, y);
      this.notifyPortEvent("node:port:mousemove", e, { x, y });
    }
    this.setEventData(e, data2);
  }
  onMouseUp(e, x, y) {
    const data2 = this.getEventData(e);
    const action = data2.action;
    if (action === "magnet") {
      this.stopMagnetDragging(e, x, y);
    } else {
      this.notifyMouseUp(e, x, y);
      this.notifyPortEvent("node:port:mouseup", e, { x, y });
      if (action === "move") {
        const meta = data2;
        const view = meta.targetView || this;
        view.stopNodeDragging(e, x, y);
      }
    }
    const magnet = data2.targetMagnet;
    if (magnet) {
      this.onMagnetClick(e, magnet, x, y);
    }
    this.checkMouseleave(e);
  }
  onMouseOver(e) {
    super.onMouseOver(e);
    this.notify("node:mouseover", this.getEventArgs(e));
    this.notifyPortEvent("node:port:mouseenter", e);
    this.notifyPortEvent("node:port:mouseover", e);
  }
  onMouseOut(e) {
    super.onMouseOut(e);
    this.notify("node:mouseout", this.getEventArgs(e));
    this.notifyPortEvent("node:port:mouseleave", e);
    this.notifyPortEvent("node:port:mouseout", e);
  }
  onMouseEnter(e) {
    this.updateClassName(e);
    super.onMouseEnter(e);
    this.notify("node:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e);
    this.notify("node:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, x, y, delta) {
    super.onMouseWheel(e, x, y, delta);
    this.notify("node:mousewheel", Object.assign({ delta }, this.getEventArgs(e, x, y)));
  }
  onMagnetClick(e, magnet, x, y) {
    const graph = this.graph;
    const count = graph.view.getMouseMovedCount(e);
    if (count > graph.options.clickThreshold) {
      return;
    }
    this.notify("node:magnet:click", Object.assign({ magnet }, this.getEventArgs(e, x, y)));
  }
  onMagnetDblClick(e, magnet, x, y) {
    this.notify("node:magnet:dblclick", Object.assign({ magnet }, this.getEventArgs(e, x, y)));
  }
  onMagnetContextMenu(e, magnet, x, y) {
    this.notify("node:magnet:contextmenu", Object.assign({ magnet }, this.getEventArgs(e, x, y)));
  }
  onMagnetMouseDown(e, magnet, x, y) {
    this.startMagnetDragging(e, x, y);
  }
  onCustomEvent(e, name, x, y) {
    this.notify("node:customevent", Object.assign({ name }, this.getEventArgs(e, x, y)));
    super.onCustomEvent(e, name, x, y);
  }
  prepareEmbedding(e) {
    const graph = this.graph;
    const data2 = this.getEventData(e);
    const node = data2.cell || this.cell;
    const view = graph.findViewByCell(node);
    const localPoint = graph.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embed", {
      e,
      node,
      view,
      cell: node,
      x: localPoint.x,
      y: localPoint.y,
      currentParent: node.getParent()
    });
  }
  processEmbedding(e, data2) {
    const cell = data2.cell || this.cell;
    const graph = data2.graph || this.graph;
    const options = graph.options.embedding;
    const findParent = options.findParent;
    let candidates = typeof findParent === "function" ? main_exports.call(findParent, graph, {
      view: this,
      node: this.cell
    }).filter((c) => {
      return Cell.isCell(c) && this.cell.id !== c.id && !c.isDescendantOf(this.cell);
    }) : graph.model.getNodesUnderNode(cell, {
      by: findParent
    });
    if (options.frontOnly) {
      if (candidates.length > 0) {
        const zIndexMap = array_exports.groupBy(candidates, "zIndex");
        const maxZIndex = array_exports.max(Object.keys(zIndexMap).map((z) => parseInt(z, 10)));
        if (maxZIndex) {
          candidates = zIndexMap[maxZIndex];
        }
      }
    }
    candidates = candidates.filter((candidate) => candidate.visible);
    let newCandidateView = null;
    const prevCandidateView = data2.candidateEmbedView;
    const validateEmbeding = options.validate;
    for (let i = candidates.length - 1; i >= 0; i -= 1) {
      const candidate = candidates[i];
      if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {
        newCandidateView = prevCandidateView;
        break;
      } else {
        const view = candidate.findView(graph);
        if (validateEmbeding && main_exports.call(validateEmbeding, graph, {
          child: this.cell,
          parent: view.cell,
          childView: this,
          parentView: view
        })) {
          newCandidateView = view;
          break;
        }
      }
    }
    this.clearEmbedding(data2);
    if (newCandidateView) {
      newCandidateView.highlight(null, { type: "embedding" });
    }
    data2.candidateEmbedView = newCandidateView;
    const localPoint = graph.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embedding", {
      e,
      cell,
      node: cell,
      view: graph.findViewByCell(cell),
      x: localPoint.x,
      y: localPoint.y,
      currentParent: cell.getParent(),
      candidateParent: newCandidateView ? newCandidateView.cell : null
    });
  }
  clearEmbedding(data2) {
    const candidateView = data2.candidateEmbedView;
    if (candidateView) {
      candidateView.unhighlight(null, { type: "embedding" });
      data2.candidateEmbedView = null;
    }
  }
  finalizeEmbedding(e, data2) {
    this.graph.startBatch("embedding");
    const cell = data2.cell || this.cell;
    const graph = data2.graph || this.graph;
    const view = graph.findViewByCell(cell);
    const parent2 = cell.getParent();
    const candidateView = data2.candidateEmbedView;
    if (candidateView) {
      candidateView.unhighlight(null, { type: "embedding" });
      data2.candidateEmbedView = null;
      if (parent2 == null || parent2.id !== candidateView.cell.id) {
        candidateView.cell.insertChild(cell, void 0, { ui: true });
      }
    } else if (parent2) {
      parent2.unembed(cell, { ui: true });
    }
    graph.model.getConnectedEdges(cell, { deep: true }).forEach((edge) => {
      edge.updateParent({ ui: true });
    });
    if (view && candidateView) {
      const localPoint = graph.snapToGrid(e.clientX, e.clientY);
      view.notify("node:embedded", {
        e,
        cell,
        x: localPoint.x,
        y: localPoint.y,
        node: cell,
        view: graph.findViewByCell(cell),
        previousParent: parent2,
        currentParent: cell.getParent()
      });
    }
    this.graph.stopBatch("embedding");
  }
  getDelegatedView() {
    let cell = this.cell;
    let view = this;
    while (view) {
      if (cell.isEdge()) {
        break;
      }
      if (!cell.hasParent() || view.can("stopDelegateOnDragging")) {
        return view;
      }
      cell = cell.getParent();
      view = this.graph.findViewByCell(cell);
    }
    return null;
  }
  validateMagnet(cellView, magnet, e) {
    if (magnet.getAttribute("magnet") !== "passive") {
      const validate = this.graph.options.connecting.validateMagnet;
      if (validate) {
        return main_exports.call(validate, this.graph, {
          e,
          magnet,
          view: cellView,
          cell: cellView.cell
        });
      }
      return true;
    }
    return false;
  }
  startMagnetDragging(e, x, y) {
    if (!this.can("magnetConnectable")) {
      return;
    }
    e.stopPropagation();
    const magnet = e.currentTarget;
    const graph = this.graph;
    this.setEventData(e, {
      targetMagnet: magnet
    });
    if (this.validateMagnet(this, magnet, e)) {
      if (graph.options.magnetThreshold <= 0) {
        this.startConnectting(e, magnet, x, y);
      }
      this.setEventData(e, {
        action: "magnet"
      });
      this.stopPropagation(e);
    } else {
      this.onMouseDown(e, x, y);
    }
    graph.view.delegateDragEvents(e, this);
  }
  startConnectting(e, magnet, x, y) {
    this.graph.model.startBatch("add-edge");
    const edgeView = this.createEdgeFromMagnet(magnet, x, y);
    edgeView.setEventData(e, edgeView.prepareArrowheadDragging("target", {
      x,
      y,
      isNewEdge: true,
      fallbackAction: "remove"
    }));
    this.setEventData(e, { edgeView });
    edgeView.notifyMouseDown(e, x, y);
  }
  getDefaultEdge(sourceView, sourceMagnet) {
    let edge;
    const create2 = this.graph.options.connecting.createEdge;
    if (create2) {
      edge = main_exports.call(create2, this.graph, {
        sourceMagnet,
        sourceView,
        sourceCell: sourceView.cell
      });
    }
    return edge;
  }
  createEdgeFromMagnet(magnet, x, y) {
    const graph = this.graph;
    const model = graph.model;
    const edge = this.getDefaultEdge(this, magnet);
    edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, "source")));
    edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { x, y }));
    edge.addTo(model, { async: false, ui: true });
    return edge.findView(graph);
  }
  dragMagnet(e, x, y) {
    const data2 = this.getEventData(e);
    const edgeView = data2.edgeView;
    if (edgeView) {
      edgeView.onMouseMove(e, x, y);
      this.autoScrollGraph(e.clientX, e.clientY);
    } else {
      const graph = this.graph;
      const magnetThreshold = graph.options.magnetThreshold;
      const currentTarget = this.getEventTarget(e);
      const targetMagnet = data2.targetMagnet;
      if (magnetThreshold === "onleave") {
        if (targetMagnet === currentTarget || targetMagnet.contains(currentTarget)) {
          return;
        }
      } else {
        if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {
          return;
        }
      }
      this.startConnectting(e, targetMagnet, x, y);
    }
  }
  stopMagnetDragging(e, x, y) {
    const data2 = this.eventData(e);
    const edgeView = data2.edgeView;
    if (edgeView) {
      edgeView.onMouseUp(e, x, y);
      this.graph.model.stopBatch("add-edge");
    }
  }
  notifyUnhandledMouseDown(e, x, y) {
    this.notify("node:unhandled:mousedown", {
      e,
      x,
      y,
      view: this,
      cell: this.cell,
      node: this.cell
    });
  }
  notifyNodeMove(name, e, x, y, cell) {
    let cells = [cell];
    const selection = this.graph.getPlugin("selection");
    if (selection && selection.isSelectionMovable()) {
      const selectedCells = selection.getSelectedCells();
      if (selectedCells.includes(cell)) {
        cells = selectedCells.filter((c) => c.isNode());
      }
    }
    cells.forEach((c) => {
      this.notify(name, {
        e,
        x,
        y,
        cell: c,
        node: c,
        view: c.findView(this.graph)
      });
    });
  }
  getRestrictArea(view) {
    const restrict = this.graph.options.translating.restrict;
    const area = typeof restrict === "function" ? main_exports.call(restrict, this.graph, view) : restrict;
    if (typeof area === "number") {
      return this.graph.transform.getGraphArea().inflate(area);
    }
    if (area === true) {
      return this.graph.transform.getGraphArea();
    }
    return area || null;
  }
  startNodeDragging(e, x, y) {
    const targetView = this.getDelegatedView();
    if (targetView == null || !targetView.can("nodeMovable")) {
      return this.notifyUnhandledMouseDown(e, x, y);
    }
    this.setEventData(e, {
      targetView,
      action: "move"
    });
    const position2 = Point.create(targetView.cell.getPosition());
    targetView.setEventData(e, {
      moving: false,
      offset: position2.diff(x, y),
      restrict: this.getRestrictArea(targetView)
    });
  }
  dragNode(e, x, y) {
    const node = this.cell;
    const graph = this.graph;
    const gridSize = graph.getGridSize();
    const data2 = this.getEventData(e);
    const offset3 = data2.offset;
    const restrict = data2.restrict;
    if (!data2.moving) {
      data2.moving = true;
      this.addClass("node-moving");
      this.notifyNodeMove("node:move", e, x, y, this.cell);
    }
    this.autoScrollGraph(e.clientX, e.clientY);
    const posX = GeometryUtil.snapToGrid(x + offset3.x, gridSize);
    const posY = GeometryUtil.snapToGrid(y + offset3.y, gridSize);
    node.setPosition(posX, posY, {
      restrict,
      deep: true,
      ui: true
    });
    if (graph.options.embedding.enabled) {
      if (!data2.embedding) {
        this.prepareEmbedding(e);
        data2.embedding = true;
      }
      this.processEmbedding(e, data2);
    }
  }
  stopNodeDragging(e, x, y) {
    const data2 = this.getEventData(e);
    if (data2.embedding) {
      this.finalizeEmbedding(e, data2);
    }
    if (data2.moving) {
      this.removeClass("node-moving");
      this.notifyNodeMove("node:moved", e, x, y, this.cell);
    }
    data2.moving = false;
    data2.embedding = false;
  }
  // eslint-disable-next-line
  autoScrollGraph(x, y) {
    const scroller = this.graph.getPlugin("scroller");
    if (scroller) {
      scroller.autoScroll(x, y);
    }
  }
};
(function(NodeView2) {
  NodeView2.toStringTag = `X6.${NodeView2.name}`;
  function isNodeView(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof NodeView2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const view = instance;
    if ((tag == null || tag === NodeView2.toStringTag) && typeof view.isNodeView === "function" && typeof view.isEdgeView === "function" && typeof view.confirmUpdate === "function" && typeof view.update === "function" && typeof view.findPortElem === "function" && typeof view.resize === "function" && typeof view.rotate === "function" && typeof view.translate === "function") {
      return true;
    }
    return false;
  }
  NodeView2.isNodeView = isNodeView;
})(NodeView || (NodeView = {}));
NodeView.config({
  isSvgElement: true,
  priority: 0,
  bootstrap: ["render"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    size: ["resize", "ports", "tools"],
    angle: ["rotate", "tools"],
    position: ["translate", "tools"],
    ports: ["ports"],
    tools: ["tools"]
  }
});
NodeView.registry.register("node", NodeView, true);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/view/edge.js
var __rest23 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var EdgeView = class _EdgeView extends CellView {
  constructor() {
    super(...arguments);
    this.POINT_ROUNDING = 2;
    this.labelDestroyFn = {};
  }
  get [Symbol.toStringTag]() {
    return _EdgeView.toStringTag;
  }
  getContainerClassName() {
    return [super.getContainerClassName(), this.prefixClassName("edge")].join(" ");
  }
  get sourceBBox() {
    const sourceView = this.sourceView;
    if (!sourceView) {
      const sourceDef = this.cell.getSource();
      return new Rectangle(sourceDef.x, sourceDef.y);
    }
    const sourceMagnet = this.sourceMagnet;
    if (sourceView.isEdgeElement(sourceMagnet)) {
      return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);
    }
    return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);
  }
  get targetBBox() {
    const targetView = this.targetView;
    if (!targetView) {
      const targetDef = this.cell.getTarget();
      return new Rectangle(targetDef.x, targetDef.y);
    }
    const targetMagnet = this.targetMagnet;
    if (targetView.isEdgeElement(targetMagnet)) {
      return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);
    }
    return targetView.getBBoxOfElement(targetMagnet || targetView.container);
  }
  isEdgeView() {
    return true;
  }
  confirmUpdate(flag, options = {}) {
    let ref2 = flag;
    if (this.hasAction(ref2, "source")) {
      if (!this.updateTerminalProperties("source")) {
        return ref2;
      }
      ref2 = this.removeAction(ref2, "source");
    }
    if (this.hasAction(ref2, "target")) {
      if (!this.updateTerminalProperties("target")) {
        return ref2;
      }
      ref2 = this.removeAction(ref2, "target");
    }
    if (this.hasAction(ref2, "render")) {
      this.render();
      ref2 = this.removeAction(ref2, ["render", "update", "labels", "tools"]);
      return ref2;
    }
    ref2 = this.handleAction(ref2, "update", () => this.update(options));
    ref2 = this.handleAction(ref2, "labels", () => this.onLabelsChange(options));
    ref2 = this.handleAction(ref2, "tools", () => this.renderTools());
    return ref2;
  }
  // #region render
  render() {
    this.empty();
    this.renderMarkup();
    this.labelContainer = null;
    this.renderLabels();
    this.update();
    this.renderTools();
    return this;
  }
  renderMarkup() {
    const markup = this.cell.markup;
    if (markup) {
      if (typeof markup === "string") {
        throw new TypeError("Not support string markup.");
      }
      return this.renderJSONMarkup(markup);
    }
    throw new TypeError("Invalid edge markup.");
  }
  renderJSONMarkup(markup) {
    const ret = this.parseJSONMarkup(markup, this.container);
    this.selectors = ret.selectors;
    this.container.append(ret.fragment);
  }
  customizeLabels() {
    if (this.labelContainer) {
      const edge = this.cell;
      const labels = edge.labels;
      for (let i = 0, n = labels.length; i < n; i += 1) {
        const label = labels[i];
        const container = this.labelCache[i];
        const selectors = this.labelSelectors[i];
        const onEdgeLabelRendered = this.graph.options.onEdgeLabelRendered;
        if (onEdgeLabelRendered) {
          const fn = onEdgeLabelRendered({
            edge,
            label,
            container,
            selectors
          });
          if (fn) {
            this.labelDestroyFn[i] = fn;
          }
        }
      }
    }
  }
  destroyCustomizeLabels() {
    const labels = this.cell.labels;
    if (this.labelCache && this.labelSelectors && this.labelDestroyFn) {
      for (let i = 0, n = labels.length; i < n; i += 1) {
        const fn = this.labelDestroyFn[i];
        const container = this.labelCache[i];
        const selectors = this.labelSelectors[i];
        if (fn && container && selectors) {
          fn({
            edge: this.cell,
            label: labels[i],
            container,
            selectors
          });
        }
      }
    }
    this.labelDestroyFn = {};
  }
  renderLabels() {
    const edge = this.cell;
    const labels = edge.getLabels();
    const count = labels.length;
    let container = this.labelContainer;
    this.labelCache = {};
    this.labelSelectors = {};
    if (count <= 0) {
      if (container && container.parentNode) {
        container.parentNode.removeChild(container);
      }
      return this;
    }
    if (container) {
      this.empty(container);
    } else {
      container = main_exports3.createSvgElement("g");
      this.addClass(this.prefixClassName("edge-labels"), container);
      this.labelContainer = container;
    }
    for (let i = 0, ii = labels.length; i < ii; i += 1) {
      const label = labels[i];
      const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));
      let labelNode;
      let selectors;
      if (normalized) {
        labelNode = normalized.node;
        selectors = normalized.selectors;
      } else {
        const defaultLabel = edge.getDefaultLabel();
        const normalized2 = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));
        labelNode = normalized2.node;
        selectors = normalized2.selectors;
      }
      labelNode.setAttribute("data-index", `${i}`);
      container.appendChild(labelNode);
      const rootSelector = this.rootSelector;
      if (selectors[rootSelector]) {
        throw new Error("Ambiguous label root selector.");
      }
      selectors[rootSelector] = labelNode;
      this.labelCache[i] = labelNode;
      this.labelSelectors[i] = selectors;
    }
    if (container.parentNode == null) {
      this.container.appendChild(container);
    }
    this.updateLabels();
    this.customizeLabels();
    return this;
  }
  onLabelsChange(options = {}) {
    this.destroyCustomizeLabels();
    if (this.shouldRerenderLabels(options)) {
      this.renderLabels();
    } else {
      this.updateLabels();
    }
    this.updateLabelPositions();
  }
  shouldRerenderLabels(options = {}) {
    const previousLabels = this.cell.previous("labels");
    if (previousLabels == null) {
      return true;
    }
    if ("propertyPathArray" in options && "propertyValue" in options) {
      const pathArray = options.propertyPathArray || [];
      const pathLength = pathArray.length;
      if (pathLength > 1) {
        const index2 = pathArray[1];
        if (previousLabels[index2]) {
          if (pathLength === 2) {
            return typeof options.propertyValue === "object" && object_exports.has(options.propertyValue, "markup");
          }
          if (pathArray[2] !== "markup") {
            return false;
          }
        }
      }
    }
    return true;
  }
  parseLabelMarkup(markup) {
    if (markup) {
      if (typeof markup === "string") {
        return this.parseLabelStringMarkup(markup);
      }
      return this.parseJSONMarkup(markup);
    }
    return null;
  }
  parseLabelStringMarkup(labelMarkup) {
    const children2 = Vector.createVectors(labelMarkup);
    const fragment = document.createDocumentFragment();
    for (let i = 0, n = children2.length; i < n; i += 1) {
      const currentChild = children2[i].node;
      fragment.appendChild(currentChild);
    }
    return { fragment, selectors: {} };
  }
  normalizeLabelMarkup(markup) {
    if (markup == null) {
      return;
    }
    const fragment = markup.fragment;
    if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {
      throw new Error("Invalid label markup.");
    }
    let vel;
    const childNodes = fragment.childNodes;
    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== "G") {
      vel = Vector.create("g").append(fragment);
    } else {
      vel = Vector.create(childNodes[0]);
    }
    vel.addClass(this.prefixClassName("edge-label"));
    return {
      node: vel.node,
      selectors: markup.selectors
    };
  }
  updateLabels() {
    if (this.labelContainer) {
      const edge = this.cell;
      const labels = edge.labels;
      const canLabelMove = this.can("edgeLabelMovable");
      const defaultLabel = edge.getDefaultLabel();
      for (let i = 0, n = labels.length; i < n; i += 1) {
        const elem = this.labelCache[i];
        const selectors = this.labelSelectors[i];
        elem.setAttribute("cursor", canLabelMove ? "move" : "default");
        const label = labels[i];
        const attrs = object_exports.merge({}, defaultLabel.attrs, label.attrs);
        this.updateAttrs(elem, attrs, {
          selectors,
          rootBBox: label.size ? Rectangle.fromSize(label.size) : void 0
        });
      }
    }
  }
  renderTools() {
    const tools = this.cell.getTools();
    this.addTools(tools);
    return this;
  }
  // #endregion
  // #region updating
  update(options = {}) {
    this.cleanCache();
    this.updateConnection(options);
    const _a = this.cell.getAttrs(), { text: text3 } = _a, attrs = __rest23(_a, ["text"]);
    if (attrs != null) {
      this.updateAttrs(this.container, attrs, {
        selectors: this.selectors
      });
    }
    this.updateLabelPositions();
    this.updateTools(options);
    return this;
  }
  removeRedundantLinearVertices(options = {}) {
    const edge = this.cell;
    const vertices = edge.getVertices();
    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];
    const rawCount = routePoints.length;
    const polyline = new Polyline(routePoints);
    polyline.simplify({ threshold: 0.01 });
    const simplifiedPoints = polyline.points.map((point) => point.toJSON());
    const simplifiedCount = simplifiedPoints.length;
    if (rawCount === simplifiedCount) {
      return 0;
    }
    edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);
    return rawCount - simplifiedCount;
  }
  getTerminalView(type) {
    switch (type) {
      case "source":
        return this.sourceView || null;
      case "target":
        return this.targetView || null;
      default:
        throw new Error(`Unknown terminal type '${type}'`);
    }
  }
  getTerminalAnchor(type) {
    switch (type) {
      case "source":
        return Point.create(this.sourceAnchor);
      case "target":
        return Point.create(this.targetAnchor);
      default:
        throw new Error(`Unknown terminal type '${type}'`);
    }
  }
  getTerminalConnectionPoint(type) {
    switch (type) {
      case "source":
        return Point.create(this.sourcePoint);
      case "target":
        return Point.create(this.targetPoint);
      default:
        throw new Error(`Unknown terminal type '${type}'`);
    }
  }
  getTerminalMagnet(type, options = {}) {
    switch (type) {
      case "source": {
        if (options.raw) {
          return this.sourceMagnet;
        }
        const sourceView = this.sourceView;
        if (!sourceView) {
          return null;
        }
        return this.sourceMagnet || sourceView.container;
      }
      case "target": {
        if (options.raw) {
          return this.targetMagnet;
        }
        const targetView = this.targetView;
        if (!targetView) {
          return null;
        }
        return this.targetMagnet || targetView.container;
      }
      default: {
        throw new Error(`Unknown terminal type '${type}'`);
      }
    }
  }
  updateConnection(options = {}) {
    const edge = this.cell;
    if (options.translateBy && edge.isFragmentDescendantOf(options.translateBy)) {
      const tx = options.tx || 0;
      const ty = options.ty || 0;
      this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;
      this.translateConnectionPoints(tx, ty);
      this.path.translate(tx, ty);
    } else {
      const vertices = edge.getVertices();
      const anchors = this.findAnchors(vertices);
      this.sourceAnchor = anchors.source;
      this.targetAnchor = anchors.target;
      this.routePoints = this.findRoutePoints(vertices);
      const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
      this.sourcePoint = connectionPoints.source;
      this.targetPoint = connectionPoints.target;
      const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);
      this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);
    }
    this.cleanCache();
  }
  findAnchors(vertices) {
    const edge = this.cell;
    const source = edge.source;
    const target = edge.target;
    const firstVertex = vertices[0];
    const lastVertex = vertices[vertices.length - 1];
    if (target.priority && !source.priority) {
      return this.findAnchorsOrdered("target", lastVertex, "source", firstVertex);
    }
    return this.findAnchorsOrdered("source", firstVertex, "target", lastVertex);
  }
  findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {
    let firstAnchor;
    let secondAnchor;
    const edge = this.cell;
    const firstTerminal = edge[firstType];
    const secondTerminal = edge[secondType];
    const firstView = this.getTerminalView(firstType);
    const secondView = this.getTerminalView(secondType);
    const firstMagnet = this.getTerminalMagnet(firstType);
    const secondMagnet = this.getTerminalMagnet(secondType);
    if (firstView) {
      let firstRef;
      if (firstPoint) {
        firstRef = Point.create(firstPoint);
      } else if (secondView) {
        firstRef = secondMagnet;
      } else {
        firstRef = Point.create(secondTerminal);
      }
      firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);
    } else {
      firstAnchor = Point.create(firstTerminal);
    }
    if (secondView) {
      const secondRef = Point.create(secondPoint || firstAnchor);
      secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);
    } else {
      secondAnchor = Point.isPointLike(secondTerminal) ? Point.create(secondTerminal) : new Point();
    }
    return {
      [firstType]: firstAnchor,
      [secondType]: secondAnchor
    };
  }
  getAnchor(def, cellView, magnet, ref2, terminalType) {
    const isEdge = cellView.isEdgeElement(magnet);
    const connecting = this.graph.options.connecting;
    let config = typeof def === "string" ? { name: def } : def;
    if (!config) {
      const defaults5 = isEdge ? (terminalType === "source" ? connecting.sourceEdgeAnchor : connecting.targetEdgeAnchor) || connecting.edgeAnchor : (terminalType === "source" ? connecting.sourceAnchor : connecting.targetAnchor) || connecting.anchor;
      config = typeof defaults5 === "string" ? { name: defaults5 } : defaults5;
    }
    if (!config) {
      throw new Error(`Anchor should be specified.`);
    }
    let anchor2;
    const name = config.name;
    if (isEdge) {
      const fn = EdgeAnchor.registry.get(name);
      if (typeof fn !== "function") {
        return EdgeAnchor.registry.onNotFound(name);
      }
      anchor2 = main_exports.call(fn, this, cellView, magnet, ref2, config.args || {}, terminalType);
    } else {
      const fn = NodeAnchor.registry.get(name);
      if (typeof fn !== "function") {
        return NodeAnchor.registry.onNotFound(name);
      }
      anchor2 = main_exports.call(fn, this, cellView, magnet, ref2, config.args || {}, terminalType);
    }
    return anchor2 ? anchor2.round(this.POINT_ROUNDING) : new Point();
  }
  findRoutePoints(vertices = []) {
    const defaultRouter = this.graph.options.connecting.router || Router.presets.normal;
    const router2 = this.cell.getRouter() || defaultRouter;
    let routePoints;
    if (typeof router2 === "function") {
      routePoints = main_exports.call(router2, this, vertices, {}, this);
    } else {
      const name = typeof router2 === "string" ? router2 : router2.name;
      const args = typeof router2 === "string" ? {} : router2.args || {};
      const fn = name ? Router.registry.get(name) : Router.presets.normal;
      if (typeof fn !== "function") {
        return Router.registry.onNotFound(name);
      }
      routePoints = main_exports.call(fn, this, vertices, args, this);
    }
    return routePoints == null ? vertices.map((p) => Point.create(p)) : routePoints.map((p) => Point.create(p));
  }
  findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {
    const edge = this.cell;
    const connecting = this.graph.options.connecting;
    const sourceTerminal = edge.getSource();
    const targetTerminal = edge.getTarget();
    const sourceView = this.sourceView;
    const targetView = this.targetView;
    const firstRoutePoint = routePoints[0];
    const lastRoutePoint = routePoints[routePoints.length - 1];
    let sourcePoint;
    if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {
      const sourceMagnet = this.sourceMagnet || sourceView.container;
      const sourcePointRef = firstRoutePoint || targetAnchor;
      const sourceLine = new Line(sourcePointRef, sourceAnchor);
      const connectionPointDef = sourceTerminal.connectionPoint || connecting.sourceConnectionPoint || connecting.connectionPoint;
      sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, "source");
    } else {
      sourcePoint = sourceAnchor;
    }
    let targetPoint;
    if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {
      const targetMagnet = this.targetMagnet || targetView.container;
      const targetConnectionPointDef = targetTerminal.connectionPoint || connecting.targetConnectionPoint || connecting.connectionPoint;
      const targetPointRef = lastRoutePoint || sourceAnchor;
      const targetLine = new Line(targetPointRef, targetAnchor);
      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, "target");
    } else {
      targetPoint = targetAnchor;
    }
    return {
      source: sourcePoint,
      target: targetPoint
    };
  }
  getConnectionPoint(def, view, magnet, line2, endType) {
    const anchor2 = line2.end;
    if (def == null) {
      return anchor2;
    }
    const name = typeof def === "string" ? def : def.name;
    const args = typeof def === "string" ? {} : def.args;
    const fn = ConnectionPoint.registry.get(name);
    if (typeof fn !== "function") {
      return ConnectionPoint.registry.onNotFound(name);
    }
    const connectionPoint = main_exports.call(fn, this, line2, view, magnet, args || {}, endType);
    return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor2;
  }
  findMarkerPoints(routePoints, sourcePoint, targetPoint) {
    const getLineWidth = (type) => {
      const attrs = this.cell.getAttrs();
      const keys2 = Object.keys(attrs);
      for (let i = 0, l = keys2.length; i < l; i += 1) {
        const attr2 = attrs[keys2[i]];
        if (attr2[`${type}Marker`] || attr2[`${type}-marker`]) {
          const strokeWidth = attr2.strokeWidth || attr2["stroke-width"];
          if (strokeWidth) {
            return parseFloat(strokeWidth);
          }
          break;
        }
      }
      return null;
    };
    const firstRoutePoint = routePoints[0];
    const lastRoutePoint = routePoints[routePoints.length - 1];
    let sourceMarkerPoint;
    let targetMarkerPoint;
    const sourceStrokeWidth = getLineWidth("source");
    if (sourceStrokeWidth) {
      sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, -sourceStrokeWidth);
    }
    const targetStrokeWidth = getLineWidth("target");
    if (targetStrokeWidth) {
      targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, -targetStrokeWidth);
    }
    this.sourceMarkerPoint = sourceMarkerPoint || sourcePoint.clone();
    this.targetMarkerPoint = targetMarkerPoint || targetPoint.clone();
    return {
      source: sourceMarkerPoint,
      target: targetMarkerPoint
    };
  }
  findPath(routePoints, sourcePoint, targetPoint) {
    const def = this.cell.getConnector() || this.graph.options.connecting.connector;
    let name;
    let args;
    let fn;
    if (typeof def === "string") {
      name = def;
    } else {
      name = def.name;
      args = def.args;
    }
    if (name) {
      const method2 = Connector.registry.get(name);
      if (typeof method2 !== "function") {
        return Connector.registry.onNotFound(name);
      }
      fn = method2;
    } else {
      fn = Connector.presets.normal;
    }
    const path2 = main_exports.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), { raw: true }), this);
    return typeof path2 === "string" ? Path.parse(path2) : path2;
  }
  translateConnectionPoints(tx, ty) {
    this.sourcePoint.translate(tx, ty);
    this.targetPoint.translate(tx, ty);
    this.sourceAnchor.translate(tx, ty);
    this.targetAnchor.translate(tx, ty);
    this.sourceMarkerPoint.translate(tx, ty);
    this.targetMarkerPoint.translate(tx, ty);
  }
  updateLabelPositions() {
    if (this.labelContainer == null) {
      return this;
    }
    const path2 = this.path;
    if (!path2) {
      return this;
    }
    const edge = this.cell;
    const labels = edge.getLabels();
    if (labels.length === 0) {
      return this;
    }
    const defaultLabel = edge.getDefaultLabel();
    const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);
    for (let i = 0, ii = labels.length; i < ii; i += 1) {
      const label = labels[i];
      const labelNode = this.labelCache[i];
      if (!labelNode) {
        continue;
      }
      const labelPosition = this.normalizeLabelPosition(label.position);
      const pos = object_exports.merge({}, defaultPosition, labelPosition);
      const matrix = this.getLabelTransformationMatrix(pos);
      labelNode.setAttribute("transform", main_exports3.matrixToTransformString(matrix));
    }
    return this;
  }
  updateTerminalProperties(type) {
    const edge = this.cell;
    const graph = this.graph;
    const terminal = edge[type];
    const nodeId = terminal && terminal.cell;
    const viewKey = `${type}View`;
    if (!nodeId) {
      this[viewKey] = null;
      this.updateTerminalMagnet(type);
      return true;
    }
    const terminalCell = graph.getCellById(nodeId);
    if (!terminalCell) {
      throw new Error(`Edge's ${type} node with id "${nodeId}" not exists`);
    }
    const endView = terminalCell.findView(graph);
    if (!endView) {
      return false;
    }
    this[viewKey] = endView;
    this.updateTerminalMagnet(type);
    return true;
  }
  updateTerminalMagnet(type) {
    const propName = `${type}Magnet`;
    const terminalView = this.getTerminalView(type);
    if (terminalView) {
      let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);
      if (magnet === terminalView.container) {
        magnet = null;
      }
      this[propName] = magnet;
    } else {
      this[propName] = null;
    }
  }
  getLabelPositionAngle(idx) {
    const label = this.cell.getLabelAt(idx);
    if (label && label.position && typeof label.position === "object") {
      return label.position.angle || 0;
    }
    return 0;
  }
  getLabelPositionArgs(idx) {
    const label = this.cell.getLabelAt(idx);
    if (label && label.position && typeof label.position === "object") {
      return label.position.options;
    }
  }
  getDefaultLabelPositionArgs() {
    const defaultLabel = this.cell.getDefaultLabel();
    if (defaultLabel && defaultLabel.position && typeof defaultLabel.position === "object") {
      return defaultLabel.position.options;
    }
  }
  mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {
    if (labelPositionArgs === null) {
      return null;
    }
    if (labelPositionArgs === void 0) {
      if (defaultLabelPositionArgs === null) {
        return null;
      }
      return defaultLabelPositionArgs;
    }
    return object_exports.merge({}, defaultLabelPositionArgs, labelPositionArgs);
  }
  // #endregion
  getConnection() {
    return this.path != null ? this.path.clone() : null;
  }
  getConnectionPathData() {
    if (this.path == null) {
      return "";
    }
    const cache = this.cache.pathCache;
    if (!object_exports.has(cache, "data")) {
      cache.data = this.path.serialize();
    }
    return cache.data || "";
  }
  getConnectionSubdivisions() {
    if (this.path == null) {
      return null;
    }
    const cache = this.cache.pathCache;
    if (!object_exports.has(cache, "segmentSubdivisions")) {
      cache.segmentSubdivisions = this.path.getSegmentSubdivisions();
    }
    return cache.segmentSubdivisions;
  }
  getConnectionLength() {
    if (this.path == null) {
      return 0;
    }
    const cache = this.cache.pathCache;
    if (!object_exports.has(cache, "length")) {
      cache.length = this.path.length({
        segmentSubdivisions: this.getConnectionSubdivisions()
      });
    }
    return cache.length;
  }
  getPointAtLength(length2) {
    if (this.path == null) {
      return null;
    }
    return this.path.pointAtLength(length2, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getPointAtRatio(ratio2) {
    if (this.path == null) {
      return null;
    }
    if (number_exports.isPercentage(ratio2)) {
      ratio2 = parseFloat(ratio2) / 100;
    }
    return this.path.pointAt(ratio2, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getTangentAtLength(length2) {
    if (this.path == null) {
      return null;
    }
    return this.path.tangentAtLength(length2, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getTangentAtRatio(ratio2) {
    if (this.path == null) {
      return null;
    }
    return this.path.tangentAt(ratio2, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPoint(point) {
    if (this.path == null) {
      return null;
    }
    return this.path.closestPoint(point, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointLength(point) {
    if (this.path == null) {
      return null;
    }
    return this.path.closestPointLength(point, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointRatio(point) {
    if (this.path == null) {
      return null;
    }
    return this.path.closestPointNormalizedLength(point, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getLabelPosition(x, y, p3, p4) {
    const pos = { distance: 0 };
    let angle = 0;
    let options;
    if (typeof p3 === "number") {
      angle = p3;
      options = p4;
    } else {
      options = p3;
    }
    if (options != null) {
      pos.options = options;
    }
    const isOffsetAbsolute = options && options.absoluteOffset;
    const isDistanceRelative = !(options && options.absoluteDistance);
    const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance;
    const path2 = this.path;
    const pathOptions = {
      segmentSubdivisions: this.getConnectionSubdivisions()
    };
    const labelPoint = new Point(x, y);
    const t = path2.closestPointT(labelPoint, pathOptions);
    const totalLength = this.getConnectionLength() || 0;
    let labelDistance = path2.lengthAtT(t, pathOptions);
    if (isDistanceRelative) {
      labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;
    }
    if (isDistanceAbsoluteReverse) {
      labelDistance = -1 * (totalLength - labelDistance) || 1;
    }
    pos.distance = labelDistance;
    let tangent;
    if (!isOffsetAbsolute)
      tangent = path2.tangentAtT(t);
    let labelOffset;
    if (tangent) {
      labelOffset = tangent.pointOffset(labelPoint);
    } else {
      const closestPoint = path2.pointAtT(t);
      const labelOffsetDiff = labelPoint.diff(closestPoint);
      labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };
    }
    pos.offset = labelOffset;
    pos.angle = angle;
    return pos;
  }
  normalizeLabelPosition(pos) {
    if (typeof pos === "number") {
      return { distance: pos };
    }
    return pos;
  }
  getLabelTransformationMatrix(labelPosition) {
    const pos = this.normalizeLabelPosition(labelPosition);
    const options = pos.options || {};
    const labelAngle = pos.angle || 0;
    const labelDistance = pos.distance;
    const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
    let labelOffset = 0;
    const offsetCoord = { x: 0, y: 0 };
    const offset3 = pos.offset;
    if (offset3) {
      if (typeof offset3 === "number") {
        labelOffset = offset3;
      } else {
        if (offset3.x != null) {
          offsetCoord.x = offset3.x;
        }
        if (offset3.y != null) {
          offsetCoord.y = offset3.y;
        }
      }
    }
    const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;
    const isKeepGradient = options.keepGradient;
    const isEnsureLegibility = options.ensureLegibility;
    const path2 = this.path;
    const pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };
    const distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;
    const tangent = path2.tangentAtLength(distance, pathOpt);
    let translation;
    let angle = labelAngle;
    if (tangent) {
      if (isOffsetAbsolute) {
        translation = tangent.start;
        translation.translate(offsetCoord);
      } else {
        const normal3 = tangent.clone();
        normal3.rotate(-90, tangent.start);
        normal3.setLength(labelOffset);
        translation = normal3.end;
      }
      if (isKeepGradient) {
        angle = tangent.angle() + labelAngle;
        if (isEnsureLegibility) {
          angle = Angle.normalize((angle + 90) % 180 - 90);
        }
      }
    } else {
      translation = path2.start;
      if (isOffsetAbsolute) {
        translation.translate(offsetCoord);
      }
    }
    return main_exports3.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);
  }
  getVertexIndex(x, y) {
    const edge = this.cell;
    const vertices = edge.getVertices();
    const vertexLength = this.getClosestPointLength(new Point(x, y));
    let index2 = 0;
    if (vertexLength != null) {
      for (const ii = vertices.length; index2 < ii; index2 += 1) {
        const currentVertex = vertices[index2];
        const currentLength = this.getClosestPointLength(currentVertex);
        if (currentLength != null && vertexLength < currentLength) {
          break;
        }
      }
    }
    return index2;
  }
  getEventArgs(e, x, y) {
    const view = this;
    const edge = view.cell;
    const cell = edge;
    if (x == null || y == null) {
      return { e, view, edge, cell };
    }
    return { e, x, y, view, edge, cell };
  }
  notifyUnhandledMouseDown(e, x, y) {
    this.notify("edge:unhandled:mousedown", {
      e,
      x,
      y,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  notifyMouseDown(e, x, y) {
    super.onMouseDown(e, x, y);
    this.notify("edge:mousedown", this.getEventArgs(e, x, y));
  }
  notifyMouseMove(e, x, y) {
    super.onMouseMove(e, x, y);
    this.notify("edge:mousemove", this.getEventArgs(e, x, y));
  }
  notifyMouseUp(e, x, y) {
    super.onMouseUp(e, x, y);
    this.notify("edge:mouseup", this.getEventArgs(e, x, y));
  }
  onClick(e, x, y) {
    super.onClick(e, x, y);
    this.notify("edge:click", this.getEventArgs(e, x, y));
  }
  onDblClick(e, x, y) {
    super.onDblClick(e, x, y);
    this.notify("edge:dblclick", this.getEventArgs(e, x, y));
  }
  onContextMenu(e, x, y) {
    super.onContextMenu(e, x, y);
    this.notify("edge:contextmenu", this.getEventArgs(e, x, y));
  }
  onMouseDown(e, x, y) {
    this.notifyMouseDown(e, x, y);
    this.startEdgeDragging(e, x, y);
  }
  onMouseMove(e, x, y) {
    const data2 = this.getEventData(e);
    switch (data2.action) {
      case "drag-label": {
        this.dragLabel(e, x, y);
        break;
      }
      case "drag-arrowhead": {
        this.dragArrowhead(e, x, y);
        break;
      }
      case "drag-edge": {
        this.dragEdge(e, x, y);
        break;
      }
      default:
        break;
    }
    this.notifyMouseMove(e, x, y);
    return data2;
  }
  onMouseUp(e, x, y) {
    const data2 = this.getEventData(e);
    switch (data2.action) {
      case "drag-label": {
        this.stopLabelDragging(e, x, y);
        break;
      }
      case "drag-arrowhead": {
        this.stopArrowheadDragging(e, x, y);
        break;
      }
      case "drag-edge": {
        this.stopEdgeDragging(e, x, y);
        break;
      }
      default:
        break;
    }
    this.notifyMouseUp(e, x, y);
    this.checkMouseleave(e);
    return data2;
  }
  onMouseOver(e) {
    super.onMouseOver(e);
    this.notify("edge:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    super.onMouseOut(e);
    this.notify("edge:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    super.onMouseEnter(e);
    this.notify("edge:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e);
    this.notify("edge:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, x, y, delta) {
    super.onMouseWheel(e, x, y, delta);
    this.notify("edge:mousewheel", Object.assign({ delta }, this.getEventArgs(e, x, y)));
  }
  onCustomEvent(e, name, x, y) {
    const tool = main_exports3.findParentByClass(e.target, "edge-tool", this.container);
    if (tool) {
      e.stopPropagation();
      if (this.can("useEdgeTools")) {
        if (name === "edge:remove") {
          this.cell.remove({ ui: true });
          return;
        }
        this.notify("edge:customevent", Object.assign({ name }, this.getEventArgs(e, x, y)));
      }
      this.notifyMouseDown(e, x, y);
    } else {
      this.notify("edge:customevent", Object.assign({ name }, this.getEventArgs(e, x, y)));
      super.onCustomEvent(e, name, x, y);
    }
  }
  onLabelMouseDown(e, x, y) {
    this.notifyMouseDown(e, x, y);
    this.startLabelDragging(e, x, y);
    const stopPropagation = this.getEventData(e).stopPropagation;
    if (stopPropagation) {
      e.stopPropagation();
    }
  }
  // #region drag edge
  startEdgeDragging(e, x, y) {
    if (!this.can("edgeMovable")) {
      this.notifyUnhandledMouseDown(e, x, y);
      return;
    }
    this.setEventData(e, {
      x,
      y,
      moving: false,
      action: "drag-edge"
    });
  }
  dragEdge(e, x, y) {
    const data2 = this.getEventData(e);
    if (!data2.moving) {
      data2.moving = true;
      this.addClass("edge-moving");
      this.notify("edge:move", {
        e,
        x,
        y,
        view: this,
        cell: this.cell,
        edge: this.cell
      });
    }
    this.cell.translate(x - data2.x, y - data2.y, { ui: true });
    this.setEventData(e, { x, y });
    this.notify("edge:moving", {
      e,
      x,
      y,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  stopEdgeDragging(e, x, y) {
    const data2 = this.getEventData(e);
    if (data2.moving) {
      this.removeClass("edge-moving");
      this.notify("edge:moved", {
        e,
        x,
        y,
        view: this,
        cell: this.cell,
        edge: this.cell
      });
    }
    data2.moving = false;
  }
  // #endregion
  // #region drag arrowhead
  prepareArrowheadDragging(type, options) {
    const magnet = this.getTerminalMagnet(type);
    const data2 = {
      action: "drag-arrowhead",
      x: options.x,
      y: options.y,
      isNewEdge: options.isNewEdge === true,
      terminalType: type,
      initialMagnet: magnet,
      initialTerminal: object_exports.clone(this.cell[type]),
      fallbackAction: options.fallbackAction || "revert",
      getValidateConnectionArgs: this.createValidateConnectionArgs(type),
      options: options.options
    };
    this.beforeArrowheadDragging(data2);
    return data2;
  }
  createValidateConnectionArgs(type) {
    const args = [];
    args[4] = type;
    args[5] = this;
    let opposite;
    let i = 0;
    let j = 0;
    if (type === "source") {
      i = 2;
      opposite = "target";
    } else {
      j = 2;
      opposite = "source";
    }
    const terminal = this.cell[opposite];
    const cellId = terminal.cell;
    if (cellId) {
      let magnet;
      const view = args[i] = this.graph.findViewByCell(cellId);
      if (view) {
        magnet = view.getMagnetFromEdgeTerminal(terminal);
        if (magnet === view.container) {
          magnet = void 0;
        }
      }
      args[i + 1] = magnet;
    }
    return (cellView, magnet) => {
      args[j] = cellView;
      args[j + 1] = cellView.container === magnet ? void 0 : magnet;
      return args;
    };
  }
  beforeArrowheadDragging(data2) {
    data2.zIndex = this.cell.zIndex;
    this.cell.toFront();
    const style2 = this.container.style;
    data2.pointerEvents = style2.pointerEvents;
    style2.pointerEvents = "none";
    if (this.graph.options.connecting.highlight) {
      this.highlightAvailableMagnets(data2);
    }
  }
  afterArrowheadDragging(data2) {
    if (data2.zIndex != null) {
      this.cell.setZIndex(data2.zIndex, { ui: true });
      data2.zIndex = null;
    }
    const container = this.container;
    container.style.pointerEvents = data2.pointerEvents || "";
    if (this.graph.options.connecting.highlight) {
      this.unhighlightAvailableMagnets(data2);
    }
  }
  validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView, candidateTerminal) {
    const options = this.graph.options.connecting;
    const allowLoop = options.allowLoop;
    const allowNode = options.allowNode;
    const allowEdge = options.allowEdge;
    const allowPort = options.allowPort;
    const allowMulti = options.allowMulti;
    const validate = options.validateConnection;
    const edge = edgeView ? edgeView.cell : null;
    const terminalView = terminalType === "target" ? targetView : sourceView;
    const terminalMagnet = terminalType === "target" ? targetMagnet : sourceMagnet;
    let valid = true;
    const doValidate = (validate2) => {
      const sourcePort = terminalType === "source" ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getSourcePortId() : null;
      const targetPort = terminalType === "target" ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getTargetPortId() : null;
      return main_exports.call(validate2, this.graph, {
        edge,
        edgeView,
        sourceView,
        targetView,
        sourcePort,
        targetPort,
        sourceMagnet,
        targetMagnet,
        sourceCell: sourceView ? sourceView.cell : null,
        targetCell: targetView ? targetView.cell : null,
        type: terminalType
      });
    };
    if (allowLoop != null) {
      if (typeof allowLoop === "boolean") {
        if (!allowLoop && sourceView === targetView) {
          valid = false;
        }
      } else {
        valid = doValidate(allowLoop);
      }
    }
    if (valid && allowPort != null) {
      if (typeof allowPort === "boolean") {
        if (!allowPort && terminalMagnet) {
          valid = false;
        }
      } else {
        valid = doValidate(allowPort);
      }
    }
    if (valid && allowEdge != null) {
      if (typeof allowEdge === "boolean") {
        if (!allowEdge && _EdgeView.isEdgeView(terminalView)) {
          valid = false;
        }
      } else {
        valid = doValidate(allowEdge);
      }
    }
    if (valid && allowNode != null && terminalMagnet == null) {
      if (typeof allowNode === "boolean") {
        if (!allowNode && NodeView.isNodeView(terminalView)) {
          valid = false;
        }
      } else {
        valid = doValidate(allowNode);
      }
    }
    if (valid && allowMulti != null && edgeView) {
      const edge2 = edgeView.cell;
      const source = terminalType === "source" ? candidateTerminal : edge2.getSource();
      const target = terminalType === "target" ? candidateTerminal : edge2.getTarget();
      const terminalCell = candidateTerminal ? this.graph.getCellById(candidateTerminal.cell) : null;
      if (source && target && source.cell && target.cell && terminalCell) {
        if (typeof allowMulti === "function") {
          valid = doValidate(allowMulti);
        } else {
          const connectedEdges = this.graph.model.getConnectedEdges(terminalCell, {
            outgoing: terminalType === "source",
            incoming: terminalType === "target"
          });
          if (connectedEdges.length) {
            if (allowMulti === "withPort") {
              const exist = connectedEdges.some((link) => {
                const s = link.getSource();
                const t = link.getTarget();
                return s && t && s.cell === source.cell && t.cell === target.cell && s.port != null && s.port === source.port && t.port != null && t.port === target.port;
              });
              if (exist) {
                valid = false;
              }
            } else if (!allowMulti) {
              const exist = connectedEdges.some((link) => {
                const s = link.getSource();
                const t = link.getTarget();
                return s && t && s.cell === source.cell && t.cell === target.cell;
              });
              if (exist) {
                valid = false;
              }
            }
          }
        }
      }
    }
    if (valid && validate != null) {
      valid = doValidate(validate);
    }
    return valid;
  }
  allowConnectToBlank(edge) {
    const graph = this.graph;
    const options = graph.options.connecting;
    const allowBlank = options.allowBlank;
    if (typeof allowBlank !== "function") {
      return !!allowBlank;
    }
    const edgeView = graph.findViewByCell(edge);
    const sourceCell = edge.getSourceCell();
    const targetCell = edge.getTargetCell();
    const sourceView = graph.findViewByCell(sourceCell);
    const targetView = graph.findViewByCell(targetCell);
    return main_exports.call(allowBlank, graph, {
      edge,
      edgeView,
      sourceCell,
      targetCell,
      sourceView,
      targetView,
      sourcePort: edge.getSourcePortId(),
      targetPort: edge.getTargetPortId(),
      sourceMagnet: edgeView.sourceMagnet,
      targetMagnet: edgeView.targetMagnet
    });
  }
  validateEdge(edge, type, initialTerminal) {
    const graph = this.graph;
    if (!this.allowConnectToBlank(edge)) {
      const sourceId = edge.getSourceCellId();
      const targetId = edge.getTargetCellId();
      if (!(sourceId && targetId)) {
        return false;
      }
    }
    const validate = graph.options.connecting.validateEdge;
    if (validate) {
      return main_exports.call(validate, graph, {
        edge,
        type,
        previous: initialTerminal
      });
    }
    return true;
  }
  arrowheadDragging(target, x, y, data2) {
    data2.x = x;
    data2.y = y;
    if (data2.currentTarget !== target) {
      if (data2.currentMagnet && data2.currentView) {
        data2.currentView.unhighlight(data2.currentMagnet, {
          type: "magnetAdsorbed"
        });
      }
      data2.currentView = this.graph.findViewByElem(target);
      if (data2.currentView) {
        data2.currentMagnet = data2.currentView.findMagnet(target);
        if (data2.currentMagnet && this.validateConnection(...data2.getValidateConnectionArgs(data2.currentView, data2.currentMagnet), data2.currentView.getEdgeTerminal(data2.currentMagnet, x, y, this.cell, data2.terminalType))) {
          data2.currentView.highlight(data2.currentMagnet, {
            type: "magnetAdsorbed"
          });
        } else {
          data2.currentMagnet = null;
        }
      } else {
        data2.currentMagnet = null;
      }
    }
    data2.currentTarget = target;
    this.cell.prop(data2.terminalType, { x, y }, Object.assign(Object.assign({}, data2.options), { ui: true }));
  }
  arrowheadDragged(data2, x, y) {
    const view = data2.currentView;
    const magnet = data2.currentMagnet;
    if (!magnet || !view) {
      return;
    }
    view.unhighlight(magnet, { type: "magnetAdsorbed" });
    const type = data2.terminalType;
    const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);
    this.cell.setTerminal(type, terminal, { ui: true });
  }
  snapArrowhead(x, y, data2) {
    const graph = this.graph;
    const { snap: snap2, allowEdge } = graph.options.connecting;
    const radius = typeof snap2 === "object" && snap2.radius || 50;
    const anchor2 = typeof snap2 === "object" && snap2.anchor || "center";
    const views = graph.renderer.findViewsInArea({
      x: x - radius,
      y: y - radius,
      width: 2 * radius,
      height: 2 * radius
    }, { nodeOnly: true });
    if (allowEdge) {
      const edgeViews = graph.renderer.findEdgeViewsFromPoint({ x, y }, radius).filter((view) => {
        return view !== this;
      });
      views.push(...edgeViews);
    }
    const prevView = data2.closestView || null;
    const prevMagnet = data2.closestMagnet || null;
    data2.closestView = null;
    data2.closestMagnet = null;
    let distance;
    let minDistance = Number.MAX_SAFE_INTEGER;
    const pos = new Point(x, y);
    views.forEach((view) => {
      if (view.container.getAttribute("magnet") !== "false") {
        if (view.isNodeView()) {
          distance = anchor2 === "center" ? view.cell.getBBox().getCenter().distance(pos) : view.cell.getBBox().getNearestPointToPoint(pos).distance(pos);
        } else if (view.isEdgeView()) {
          const point = view.getClosestPoint(pos);
          if (point) {
            distance = point.distance(pos);
          } else {
            distance = Number.MAX_SAFE_INTEGER;
          }
        }
        if (distance < radius && distance < minDistance) {
          if (prevMagnet === view.container || this.validateConnection(...data2.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data2.terminalType))) {
            minDistance = distance;
            data2.closestView = view;
            data2.closestMagnet = view.container;
          }
        }
      }
      view.container.querySelectorAll("[magnet]").forEach((magnet) => {
        if (magnet.getAttribute("magnet") !== "false") {
          const bbox2 = view.getBBoxOfElement(magnet);
          distance = pos.distance(bbox2.getCenter());
          if (distance < radius && distance < minDistance) {
            if (prevMagnet === magnet || this.validateConnection(...data2.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data2.terminalType))) {
              minDistance = distance;
              data2.closestView = view;
              data2.closestMagnet = magnet;
            }
          }
        }
      });
    });
    let terminal;
    const type = data2.terminalType;
    const closestView = data2.closestView;
    const closestMagnet = data2.closestMagnet;
    const changed = prevMagnet !== closestMagnet;
    if (prevView && changed) {
      prevView.unhighlight(prevMagnet, {
        type: "magnetAdsorbed"
      });
    }
    if (closestView) {
      if (!changed) {
        return;
      }
      closestView.highlight(closestMagnet, {
        type: "magnetAdsorbed"
      });
      terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);
    } else {
      terminal = { x, y };
    }
    this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data2.options), { ui: true }));
  }
  snapArrowheadEnd(data2) {
    const closestView = data2.closestView;
    const closestMagnet = data2.closestMagnet;
    if (closestView && closestMagnet) {
      closestView.unhighlight(closestMagnet, {
        type: "magnetAdsorbed"
      });
      data2.currentMagnet = closestView.findMagnet(closestMagnet);
    }
    data2.closestView = null;
    data2.closestMagnet = null;
  }
  finishEmbedding(data2) {
    if (this.graph.options.embedding.enabled && this.cell.updateParent()) {
      data2.zIndex = null;
    }
  }
  fallbackConnection(data2) {
    switch (data2.fallbackAction) {
      case "remove":
        this.cell.remove({ ui: true });
        break;
      case "revert":
      default:
        this.cell.prop(data2.terminalType, data2.initialTerminal, {
          ui: true
        });
        break;
    }
  }
  notifyConnectionEvent(data2, e) {
    const terminalType = data2.terminalType;
    const initialTerminal = data2.initialTerminal;
    const currentTerminal = this.cell[terminalType];
    const changed = currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal);
    if (changed) {
      const graph = this.graph;
      const previous = initialTerminal;
      const previousCell = previous.cell ? graph.getCellById(previous.cell) : null;
      const previousPort = previous.port;
      const previousView = previousCell ? graph.findViewByCell(previousCell) : null;
      const previousPoint = previousCell || data2.isNewEdge ? null : Point.create(initialTerminal).toJSON();
      const current = currentTerminal;
      const currentCell = current.cell ? graph.getCellById(current.cell) : null;
      const currentPort = current.port;
      const currentView = currentCell ? graph.findViewByCell(currentCell) : null;
      const currentPoint = currentCell ? null : Point.create(currentTerminal).toJSON();
      this.notify("edge:connected", {
        e,
        previousCell,
        previousPort,
        previousView,
        previousPoint,
        currentCell,
        currentView,
        currentPort,
        currentPoint,
        previousMagnet: data2.initialMagnet,
        currentMagnet: data2.currentMagnet,
        edge: this.cell,
        view: this,
        type: terminalType,
        isNew: data2.isNewEdge
      });
    }
  }
  highlightAvailableMagnets(data2) {
    const graph = this.graph;
    const cells = graph.model.getCells();
    data2.marked = {};
    for (let i = 0, ii = cells.length; i < ii; i += 1) {
      const view = graph.findViewByCell(cells[i]);
      if (!view || view.cell.id === this.cell.id) {
        continue;
      }
      const magnets = Array.prototype.slice.call(view.container.querySelectorAll("[magnet]"));
      if (view.container.getAttribute("magnet") !== "false") {
        magnets.push(view.container);
      }
      const availableMagnets = magnets.filter((magnet) => this.validateConnection(...data2.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data2.x, data2.y, this.cell, data2.terminalType)));
      if (availableMagnets.length > 0) {
        for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {
          view.highlight(availableMagnets[j], { type: "magnetAvailable" });
        }
        view.highlight(null, { type: "nodeAvailable" });
        data2.marked[view.cell.id] = availableMagnets;
      }
    }
  }
  unhighlightAvailableMagnets(data2) {
    const marked = data2.marked || {};
    Object.keys(marked).forEach((id) => {
      const view = this.graph.findViewByCell(id);
      if (view) {
        const magnets = marked[id];
        magnets.forEach((magnet) => {
          view.unhighlight(magnet, { type: "magnetAvailable" });
        });
        view.unhighlight(null, { type: "nodeAvailable" });
      }
    });
    data2.marked = null;
  }
  startArrowheadDragging(e, x, y) {
    if (!this.can("arrowheadMovable")) {
      this.notifyUnhandledMouseDown(e, x, y);
      return;
    }
    const elem = e.target;
    const type = elem.getAttribute("data-terminal");
    const data2 = this.prepareArrowheadDragging(type, { x, y });
    this.setEventData(e, data2);
  }
  dragArrowhead(e, x, y) {
    const data2 = this.getEventData(e);
    if (this.graph.options.connecting.snap) {
      this.snapArrowhead(x, y, data2);
    } else {
      this.arrowheadDragging(this.getEventTarget(e), x, y, data2);
    }
  }
  stopArrowheadDragging(e, x, y) {
    const graph = this.graph;
    const data2 = this.getEventData(e);
    if (graph.options.connecting.snap) {
      this.snapArrowheadEnd(data2);
    } else {
      this.arrowheadDragged(data2, x, y);
    }
    const valid = this.validateEdge(this.cell, data2.terminalType, data2.initialTerminal);
    if (valid) {
      this.finishEmbedding(data2);
      this.notifyConnectionEvent(data2, e);
    } else {
      this.fallbackConnection(data2);
    }
    this.afterArrowheadDragging(data2);
  }
  // #endregion
  // #region drag lable
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startLabelDragging(e, x, y) {
    if (this.can("edgeLabelMovable")) {
      const target = e.currentTarget;
      const index2 = parseInt(target.getAttribute("data-index"), 10);
      const positionAngle = this.getLabelPositionAngle(index2);
      const labelPositionArgs = this.getLabelPositionArgs(index2);
      const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();
      const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
      this.setEventData(e, {
        index: index2,
        positionAngle,
        positionArgs,
        stopPropagation: true,
        action: "drag-label"
      });
    } else {
      this.setEventData(e, { stopPropagation: true });
    }
    this.graph.view.delegateDragEvents(e, this);
  }
  dragLabel(e, x, y) {
    const data2 = this.getEventData(e);
    const originLabel = this.cell.getLabelAt(data2.index);
    const label = object_exports.merge({}, originLabel, {
      position: this.getLabelPosition(x, y, data2.positionAngle, data2.positionArgs)
    });
    this.cell.setLabelAt(data2.index, label);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  stopLabelDragging(e, x, y) {
  }
};
(function(EdgeView2) {
  EdgeView2.toStringTag = `X6.${EdgeView2.name}`;
  function isEdgeView2(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof EdgeView2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    const view = instance;
    if ((tag == null || tag === EdgeView2.toStringTag) && typeof view.isNodeView === "function" && typeof view.isEdgeView === "function" && typeof view.confirmUpdate === "function" && typeof view.update === "function" && typeof view.getConnection === "function") {
      return true;
    }
    return false;
  }
  EdgeView2.isEdgeView = isEdgeView2;
})(EdgeView || (EdgeView = {}));
EdgeView.config({
  isSvgElement: true,
  priority: 1,
  bootstrap: ["render", "source", "target"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    source: ["source", "update"],
    target: ["target", "update"],
    router: ["update"],
    connector: ["update"],
    labels: ["labels"],
    defaultLabel: ["labels"],
    tools: ["tools"],
    vertices: ["vertices", "update"]
  }
});
EdgeView.registry.register("edge", EdgeView, true);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/view.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GraphView = class _GraphView extends View {
  /** Graph's `this.container` is from outer, should not dispose */
  get disposeContainer() {
    return false;
  }
  get options() {
    return this.graph.options;
  }
  constructor(graph) {
    super();
    this.graph = graph;
    const { selectors, fragment } = Markup.parseJSONMarkup(_GraphView.markup);
    this.background = selectors.background;
    this.grid = selectors.grid;
    this.svg = selectors.svg;
    this.defs = selectors.defs;
    this.viewport = selectors.viewport;
    this.primer = selectors.primer;
    this.stage = selectors.stage;
    this.decorator = selectors.decorator;
    this.overlay = selectors.overlay;
    this.container = this.options.container;
    this.restore = _GraphView.snapshoot(this.container);
    main_exports3.addClass(this.container, this.prefixClassName("graph"));
    main_exports3.append(this.container, fragment);
    this.delegateEvents();
  }
  delegateEvents() {
    const ctor = this.constructor;
    super.delegateEvents(ctor.events);
    return this;
  }
  /**
   * Guard the specified event. If the event is not interesting, it
   * returns `true`, otherwise returns `false`.
   */
  guard(e, view) {
    if (e.type === "mousedown" && e.button === 2) {
      return true;
    }
    if (this.options.guard && this.options.guard(e, view)) {
      return true;
    }
    if (e.data && e.data.guarded !== void 0) {
      return e.data.guarded;
    }
    if (view && view.cell && Cell.isCell(view.cell)) {
      return false;
    }
    if (this.svg === e.target || this.container === e.target || this.svg.contains(e.target)) {
      return false;
    }
    return true;
  }
  findView(elem) {
    return this.graph.findViewByElem(elem);
  }
  onDblClick(evt) {
    if (this.options.preventDefaultDblClick) {
      evt.preventDefault();
    }
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
    if (view) {
      view.onDblClick(e, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger("blank:dblclick", {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }
  }
  onClick(evt) {
    if (this.getMouseMovedCount(evt) <= this.options.clickThreshold) {
      const e = this.normalizeEvent(evt);
      const view = this.findView(e.target);
      if (this.guard(e, view)) {
        return;
      }
      const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
      if (view) {
        view.onClick(e, localPoint.x, localPoint.y);
      } else {
        this.graph.trigger("blank:click", {
          e,
          x: localPoint.x,
          y: localPoint.y
        });
      }
    }
  }
  isPreventDefaultContextMenu(view) {
    let preventDefaultContextMenu = this.options.preventDefaultContextMenu;
    if (typeof preventDefaultContextMenu === "function") {
      preventDefaultContextMenu = main_exports.call(preventDefaultContextMenu, this.graph, { view });
    }
    return preventDefaultContextMenu;
  }
  onContextMenu(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.isPreventDefaultContextMenu(view)) {
      evt.preventDefault();
    }
    if (this.guard(e, view)) {
      return;
    }
    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
    if (view) {
      view.onContextMenu(e, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger("blank:contextmenu", {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }
  }
  delegateDragEvents(e, view) {
    if (e.data == null) {
      e.data = {};
    }
    this.setEventData(e, {
      currentView: view || null,
      mouseMovedCount: 0,
      startPosition: {
        x: e.clientX,
        y: e.clientY
      }
    });
    const ctor = this.constructor;
    this.delegateDocumentEvents(ctor.documentEvents, e.data);
    this.undelegateEvents();
  }
  getMouseMovedCount(e) {
    const data2 = this.getEventData(e);
    return data2.mouseMovedCount || 0;
  }
  onMouseDown(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    if (this.options.preventDefaultMouseDown) {
      evt.preventDefault();
    }
    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
    if (view) {
      view.onMouseDown(e, localPoint.x, localPoint.y);
    } else {
      if (this.options.preventDefaultBlankAction && ["touchstart"].includes(e.type)) {
        evt.preventDefault();
      }
      this.graph.trigger("blank:mousedown", {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }
    this.delegateDragEvents(e, view);
  }
  onMouseMove(evt) {
    const data2 = this.getEventData(evt);
    const startPosition = data2.startPosition;
    if (startPosition && startPosition.x === evt.clientX && startPosition.y === evt.clientY) {
      return;
    }
    if (data2.mouseMovedCount == null) {
      data2.mouseMovedCount = 0;
    }
    data2.mouseMovedCount += 1;
    const mouseMovedCount = data2.mouseMovedCount;
    if (mouseMovedCount <= this.options.moveThreshold) {
      return;
    }
    const e = this.normalizeEvent(evt);
    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
    const view = data2.currentView;
    if (view) {
      view.onMouseMove(e, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger("blank:mousemove", {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }
    this.setEventData(e, data2);
  }
  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const normalized = this.normalizeEvent(e);
    const localPoint = this.graph.snapToGrid(normalized.clientX, normalized.clientY);
    const data2 = this.getEventData(e);
    const view = data2.currentView;
    if (view) {
      view.onMouseUp(normalized, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger("blank:mouseup", {
        e: normalized,
        x: localPoint.x,
        y: localPoint.y
      });
    }
    if (!e.isPropagationStopped()) {
      const ev = new main_exports3.EventObject(e, {
        type: "click",
        data: e.data
      });
      this.onClick(ev);
    }
    e.stopImmediatePropagation();
    this.delegateEvents();
  }
  onMouseOver(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    if (view) {
      view.onMouseOver(e);
    } else {
      if (this.container === e.target) {
        return;
      }
      this.graph.trigger("blank:mouseover", { e });
    }
  }
  onMouseOut(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    if (view) {
      view.onMouseOut(e);
    } else {
      if (this.container === e.target) {
        return;
      }
      this.graph.trigger("blank:mouseout", { e });
    }
  }
  onMouseEnter(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    const relatedView = this.graph.findViewByElem(e.relatedTarget);
    if (view) {
      if (relatedView === view) {
        return;
      }
      view.onMouseEnter(e);
    } else {
      if (relatedView) {
        return;
      }
      this.graph.trigger("graph:mouseenter", { e });
    }
  }
  onMouseLeave(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    const relatedView = this.graph.findViewByElem(e.relatedTarget);
    if (view) {
      if (relatedView === view) {
        return;
      }
      view.onMouseLeave(e);
    } else {
      if (relatedView) {
        return;
      }
      this.graph.trigger("graph:mouseleave", { e });
    }
  }
  onMouseWheel(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);
    if (this.guard(e, view)) {
      return;
    }
    const originalEvent = e.originalEvent;
    const localPoint = this.graph.snapToGrid(originalEvent.clientX, originalEvent.clientY);
    const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta || -originalEvent.detail));
    if (view) {
      view.onMouseWheel(e, localPoint.x, localPoint.y, delta);
    } else {
      this.graph.trigger("blank:mousewheel", {
        e,
        delta,
        x: localPoint.x,
        y: localPoint.y
      });
    }
  }
  onCustomEvent(evt) {
    const elem = evt.currentTarget;
    const event = elem.getAttribute("event") || elem.getAttribute("data-event");
    if (event) {
      const view = this.findView(elem);
      if (view) {
        const e = this.normalizeEvent(evt);
        if (this.guard(e, view)) {
          return;
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        view.onCustomEvent(e, event, localPoint.x, localPoint.y);
      }
    }
  }
  handleMagnetEvent(evt, handler) {
    const magnetElem = evt.currentTarget;
    const magnetValue = magnetElem.getAttribute("magnet");
    if (magnetValue && magnetValue.toLowerCase() !== "false") {
      const view = this.findView(magnetElem);
      if (view) {
        const e = this.normalizeEvent(evt);
        if (this.guard(e, view)) {
          return;
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        main_exports.call(handler, this.graph, view, e, magnetElem, localPoint.x, localPoint.y);
      }
    }
  }
  onMagnetMouseDown(e) {
    this.handleMagnetEvent(e, (view, e2, magnet, x, y) => {
      view.onMagnetMouseDown(e2, magnet, x, y);
    });
  }
  onMagnetDblClick(e) {
    this.handleMagnetEvent(e, (view, e2, magnet, x, y) => {
      view.onMagnetDblClick(e2, magnet, x, y);
    });
  }
  onMagnetContextMenu(e) {
    const view = this.findView(e.target);
    if (this.isPreventDefaultContextMenu(view)) {
      e.preventDefault();
    }
    this.handleMagnetEvent(e, (view2, e2, magnet, x, y) => {
      view2.onMagnetContextMenu(e2, magnet, x, y);
    });
  }
  onLabelMouseDown(evt) {
    const labelNode = evt.currentTarget;
    const view = this.findView(labelNode);
    if (view) {
      const e = this.normalizeEvent(evt);
      if (this.guard(e, view)) {
        return;
      }
      const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
      view.onLabelMouseDown(e, localPoint.x, localPoint.y);
    }
  }
  onImageDragStart() {
    return false;
  }
  dispose() {
    this.undelegateEvents();
    this.undelegateDocumentEvents();
    this.restore();
    this.restore = () => {
    };
  }
};
__decorate8([
  View.dispose()
], GraphView.prototype, "dispose", null);
(function(GraphView2) {
  const prefixCls = `${Config.prefixCls}-graph`;
  GraphView2.markup = [
    {
      ns: main_exports3.ns.xhtml,
      tagName: "div",
      selector: "background",
      className: `${prefixCls}-background`
    },
    {
      ns: main_exports3.ns.xhtml,
      tagName: "div",
      selector: "grid",
      className: `${prefixCls}-grid`
    },
    {
      ns: main_exports3.ns.svg,
      tagName: "svg",
      selector: "svg",
      className: `${prefixCls}-svg`,
      attrs: {
        width: "100%",
        height: "100%",
        "xmlns:xlink": main_exports3.ns.xlink
      },
      children: [
        {
          tagName: "defs",
          selector: "defs"
        },
        {
          tagName: "g",
          selector: "viewport",
          className: `${prefixCls}-svg-viewport`,
          children: [
            {
              tagName: "g",
              selector: "primer",
              className: `${prefixCls}-svg-primer`
            },
            {
              tagName: "g",
              selector: "stage",
              className: `${prefixCls}-svg-stage`
            },
            {
              tagName: "g",
              selector: "decorator",
              className: `${prefixCls}-svg-decorator`
            },
            {
              tagName: "g",
              selector: "overlay",
              className: `${prefixCls}-svg-overlay`
            }
          ]
        }
      ]
    }
  ];
  function snapshoot(elem) {
    const cloned = elem.cloneNode();
    elem.childNodes.forEach((child) => cloned.appendChild(child));
    return () => {
      main_exports3.empty(elem);
      while (elem.attributes.length > 0) {
        elem.removeAttribute(elem.attributes[0].name);
      }
      for (let i = 0, l = cloned.attributes.length; i < l; i += 1) {
        const attr2 = cloned.attributes[i];
        elem.setAttribute(attr2.name, attr2.value);
      }
      cloned.childNodes.forEach((child) => elem.appendChild(child));
    };
  }
  GraphView2.snapshoot = snapshoot;
})(GraphView || (GraphView = {}));
(function(GraphView2) {
  const prefixCls = Config.prefixCls;
  GraphView2.events = {
    dblclick: "onDblClick",
    contextmenu: "onContextMenu",
    touchstart: "onMouseDown",
    mousedown: "onMouseDown",
    mouseover: "onMouseOver",
    mouseout: "onMouseOut",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousewheel: "onMouseWheel",
    DOMMouseScroll: "onMouseWheel",
    [`mouseenter  .${prefixCls}-cell`]: "onMouseEnter",
    [`mouseleave  .${prefixCls}-cell`]: "onMouseLeave",
    [`mouseenter  .${prefixCls}-cell-tools`]: "onMouseEnter",
    [`mouseleave  .${prefixCls}-cell-tools`]: "onMouseLeave",
    [`mousedown   .${prefixCls}-cell [event]`]: "onCustomEvent",
    [`touchstart  .${prefixCls}-cell [event]`]: "onCustomEvent",
    [`mousedown   .${prefixCls}-cell [data-event]`]: "onCustomEvent",
    [`touchstart  .${prefixCls}-cell [data-event]`]: "onCustomEvent",
    [`dblclick    .${prefixCls}-cell [magnet]`]: "onMagnetDblClick",
    [`contextmenu .${prefixCls}-cell [magnet]`]: "onMagnetContextMenu",
    [`mousedown   .${prefixCls}-cell [magnet]`]: "onMagnetMouseDown",
    [`touchstart  .${prefixCls}-cell [magnet]`]: "onMagnetMouseDown",
    [`dblclick    .${prefixCls}-cell [data-magnet]`]: "onMagnetDblClick",
    [`contextmenu .${prefixCls}-cell [data-magnet]`]: "onMagnetContextMenu",
    [`mousedown   .${prefixCls}-cell [data-magnet]`]: "onMagnetMouseDown",
    [`touchstart  .${prefixCls}-cell [data-magnet]`]: "onMagnetMouseDown",
    [`dragstart   .${prefixCls}-cell image`]: "onImageDragStart",
    [`mousedown   .${prefixCls}-edge .${prefixCls}-edge-label`]: "onLabelMouseDown",
    [`touchstart  .${prefixCls}-edge .${prefixCls}-edge-label`]: "onLabelMouseDown"
  };
  GraphView2.documentEvents = {
    mousemove: "onMouseMove",
    touchmove: "onMouseMove",
    mouseup: "onMouseUp",
    touchend: "onMouseUp",
    touchcancel: "onMouseUp"
  };
})(GraphView || (GraphView = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/style/raw.js
var content = `.x6-graph {
  position: relative;
  overflow: hidden;
  outline: none;
  touch-action: none;
}
.x6-graph-background,
.x6-graph-grid,
.x6-graph-svg {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-background-stage,
.x6-graph-grid-stage,
.x6-graph-svg-stage {
  user-select: none;
}
.x6-graph.x6-graph-pannable {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
.x6-graph.x6-graph-panning {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
  user-select: none;
}
.x6-node {
  cursor: move;
  /* stylelint-disable-next-line */
}
.x6-node.x6-node-immovable {
  cursor: default;
}
.x6-node * {
  -webkit-user-drag: none;
}
.x6-node .scalable * {
  vector-effect: non-scaling-stroke;
}
.x6-node [magnet='true'] {
  cursor: crosshair;
  transition: opacity 0.3s;
}
.x6-node [magnet='true']:hover {
  opacity: 0.7;
}
.x6-node foreignObject {
  display: block;
  overflow: visible;
  background-color: transparent;
}
.x6-node foreignObject > body {
  position: static;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: visible;
  background-color: transparent;
}
.x6-edge .source-marker,
.x6-edge .target-marker {
  vector-effect: non-scaling-stroke;
}
.x6-edge .connection {
  stroke-linejoin: round;
  fill: none;
}
.x6-edge .connection-wrap {
  cursor: move;
  opacity: 0;
  fill: none;
  stroke: #000;
  stroke-width: 15;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.x6-edge .connection-wrap:hover {
  opacity: 0.4;
  stroke-opacity: 0.4;
}
.x6-edge .vertices {
  cursor: move;
  opacity: 0;
}
.x6-edge .vertices .vertex {
  fill: #1abc9c;
}
.x6-edge .vertices .vertex :hover {
  fill: #34495e;
  stroke: none;
}
.x6-edge .vertices .vertex-remove {
  cursor: pointer;
  fill: #fff;
}
.x6-edge .vertices .vertex-remove-area {
  cursor: pointer;
  opacity: 0.1;
}
.x6-edge .vertices .vertex-group:hover .vertex-remove-area {
  opacity: 1;
}
.x6-edge .arrowheads {
  cursor: move;
  opacity: 0;
}
.x6-edge .arrowheads .arrowhead {
  fill: #1abc9c;
}
.x6-edge .arrowheads .arrowhead :hover {
  fill: #f39c12;
  stroke: none;
}
.x6-edge .tools {
  cursor: pointer;
  opacity: 0;
}
.x6-edge .tools .tool-options {
  display: none;
}
.x6-edge .tools .tool-remove circle {
  fill: #f00;
}
.x6-edge .tools .tool-remove path {
  fill: #fff;
}
.x6-edge:hover .vertices,
.x6-edge:hover .arrowheads,
.x6-edge:hover .tools {
  opacity: 1;
}
.x6-highlight-opacity {
  opacity: 0.3;
}
.x6-cell-tool-editor {
  position: relative;
  display: inline-block;
  min-height: 1em;
  margin: 0;
  padding: 0;
  line-height: 1;
  white-space: normal;
  text-align: center;
  vertical-align: top;
  overflow-wrap: normal;
  outline: none;
  transform-origin: 0 0;
  -webkit-user-drag: none;
}
.x6-edge-tool-editor {
  border: 1px solid #275fc5;
  border-radius: 2px;
}
`;

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/base.js
var Base2 = class extends Disposable {
  get options() {
    return this.graph.options;
  }
  get model() {
    return this.graph.model;
  }
  get view() {
    return this.graph.view;
  }
  constructor(graph) {
    super();
    this.graph = graph;
    this.init();
  }
  init() {
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/css.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CSSManager = class extends Base2 {
  init() {
    if (Config.autoInsertCSS) {
      loader_exports.ensure("core", content);
    }
  }
  dispose() {
    loader_exports.clean("core");
  }
};
__decorate9([
  CSSManager.dispose()
], CSSManager.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/options.js
var __rest24 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Options;
(function(Options2) {
  function get2(options) {
    const { grid, panning, mousewheel, embedding } = options, others = __rest24(
      options,
      ["grid", "panning", "mousewheel", "embedding"]
    );
    const container = options.container;
    if (container != null) {
      if (others.width == null) {
        others.width = container.clientWidth;
      }
      if (others.height == null) {
        others.height = container.clientHeight;
      }
    } else {
      throw new Error(`Ensure the container of the graph is specified and valid`);
    }
    const result2 = object_exports.merge({}, Options2.defaults, others);
    const defaultGrid = { size: 10, visible: false };
    if (typeof grid === "number") {
      result2.grid = { size: grid, visible: false };
    } else if (typeof grid === "boolean") {
      result2.grid = Object.assign(Object.assign({}, defaultGrid), { visible: grid });
    } else {
      result2.grid = Object.assign(Object.assign({}, defaultGrid), grid);
    }
    const booleas = [
      "panning",
      "mousewheel",
      "embedding"
    ];
    booleas.forEach((key) => {
      const val = options[key];
      if (typeof val === "boolean") {
        result2[key].enabled = val;
      } else {
        result2[key] = Object.assign(Object.assign({}, result2[key]), val);
      }
    });
    return result2;
  }
  Options2.get = get2;
})(Options || (Options = {}));
(function(Options2) {
  Options2.defaults = {
    x: 0,
    y: 0,
    scaling: {
      min: 0.01,
      max: 16
    },
    grid: {
      size: 10,
      visible: false
    },
    background: false,
    panning: {
      enabled: false,
      eventTypes: ["leftMouseDown"]
    },
    mousewheel: {
      enabled: false,
      factor: 1.2,
      zoomAtMousePosition: true
    },
    highlighting: {
      default: {
        name: "stroke",
        args: {
          padding: 3
        }
      },
      nodeAvailable: {
        name: "className",
        args: {
          className: Config.prefix("available-node")
        }
      },
      magnetAvailable: {
        name: "className",
        args: {
          className: Config.prefix("available-magnet")
        }
      }
    },
    connecting: {
      snap: false,
      allowLoop: true,
      allowNode: true,
      allowEdge: false,
      allowPort: true,
      allowBlank: true,
      allowMulti: true,
      highlight: false,
      anchor: "center",
      edgeAnchor: "ratio",
      connectionPoint: "boundary",
      router: "normal",
      connector: "normal",
      validateConnection({ type, sourceView, targetView }) {
        const view = type === "target" ? targetView : sourceView;
        return view != null;
      },
      createEdge() {
        return new Edge2();
      }
    },
    translating: {
      restrict: false
    },
    embedding: {
      enabled: false,
      findParent: "bbox",
      frontOnly: true,
      validate: () => true
    },
    moveThreshold: 0,
    clickThreshold: 0,
    magnetThreshold: 0,
    preventDefaultDblClick: true,
    preventDefaultMouseDown: false,
    preventDefaultContextMenu: true,
    preventDefaultBlankAction: true,
    interacting: {
      edgeLabelMovable: false
    },
    async: true,
    virtual: false,
    guard: () => false
  };
})(Options || (Options = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/grid.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest25 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var GridManager = class extends Base2 {
  get elem() {
    return this.view.grid;
  }
  get grid() {
    return this.options.grid;
  }
  init() {
    this.startListening();
    this.draw(this.grid);
  }
  startListening() {
    this.graph.on("scale", this.update, this);
    this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this);
    this.graph.off("translate", this.update, this);
  }
  setVisible(visible) {
    if (this.grid.visible !== visible) {
      this.grid.visible = visible;
      this.update();
    }
  }
  getGridSize() {
    return this.grid.size;
  }
  setGridSize(size2) {
    this.grid.size = Math.max(size2, 1);
    this.update();
  }
  show() {
    this.setVisible(true);
    this.update();
  }
  hide() {
    this.setVisible(false);
    this.update();
  }
  clear() {
    this.elem.style.backgroundImage = "";
  }
  draw(options) {
    this.clear();
    this.instance = null;
    Object.assign(this.grid, options);
    this.patterns = this.resolveGrid(options);
    this.update();
  }
  update(options = {}) {
    const gridSize = this.grid.size;
    if (gridSize <= 1 || !this.grid.visible) {
      return this.clear();
    }
    const ctm = this.graph.matrix();
    const grid = this.getInstance();
    const items = Array.isArray(options) ? options : [options];
    this.patterns.forEach((settings, index2) => {
      const id = `pattern_${index2}`;
      const sx = ctm.a || 1;
      const sy = ctm.d || 1;
      const { update: update2, markup } = settings, others = __rest25(settings, ["update", "markup"]);
      const options2 = Object.assign(Object.assign(Object.assign({}, others), items[index2]), {
        sx,
        sy,
        ox: ctm.e || 0,
        oy: ctm.f || 0,
        width: gridSize * sx,
        height: gridSize * sy
      });
      if (!grid.has(id)) {
        grid.add(id, Vector.create("pattern", { id, patternUnits: "userSpaceOnUse" }, Vector.createVectors(markup)).node);
      }
      const patternElem = grid.get(id);
      if (typeof update2 === "function") {
        update2(patternElem.childNodes[0], options2);
      }
      let x = options2.ox % options2.width;
      if (x < 0) {
        x += options2.width;
      }
      let y = options2.oy % options2.height;
      if (y < 0) {
        y += options2.height;
      }
      main_exports3.attr(patternElem, {
        x,
        y,
        width: options2.width,
        height: options2.height
      });
    });
    const base64 = new XMLSerializer().serializeToString(grid.root);
    const url = `url(data:image/svg+xml;base64,${btoa(base64)})`;
    this.elem.style.backgroundImage = url;
  }
  getInstance() {
    if (!this.instance) {
      this.instance = new Grid();
    }
    return this.instance;
  }
  resolveGrid(options) {
    if (!options) {
      return [];
    }
    const type = options.type;
    if (type == null) {
      return [
        Object.assign(Object.assign({}, Grid.presets.dot), options.args)
      ];
    }
    const items = Grid.registry.get(type);
    if (items) {
      let args = options.args || [];
      if (!Array.isArray(args)) {
        args = [args];
      }
      return Array.isArray(items) ? items.map((item, index2) => Object.assign(Object.assign({}, item), args[index2])) : [Object.assign(Object.assign({}, items), args[0])];
    }
    return Grid.registry.onNotFound(type);
  }
  dispose() {
    this.stopListening();
    this.clear();
  }
};
__decorate10([
  Base2.dispose()
], GridManager.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/transform.js
var TransformManager = class extends Base2 {
  get container() {
    return this.graph.view.container;
  }
  get viewport() {
    return this.graph.view.viewport;
  }
  get stage() {
    return this.graph.view.stage;
  }
  init() {
    this.resize();
  }
  /**
   * Returns the current transformation matrix of the graph.
   */
  getMatrix() {
    const transform3 = this.viewport.getAttribute("transform");
    if (transform3 !== this.viewportTransformString) {
      this.viewportMatrix = this.viewport.getCTM();
      this.viewportTransformString = transform3;
    }
    return main_exports3.createSVGMatrix(this.viewportMatrix);
  }
  /**
   * Sets new transformation with the given `matrix`
   */
  setMatrix(matrix) {
    const ctm = main_exports3.createSVGMatrix(matrix);
    const transform3 = main_exports3.matrixToTransformString(ctm);
    this.viewport.setAttribute("transform", transform3);
    this.viewportMatrix = ctm;
    this.viewportTransformString = transform3;
  }
  resize(width2, height2) {
    let w = width2 === void 0 ? this.options.width : width2;
    let h = height2 === void 0 ? this.options.height : height2;
    this.options.width = w;
    this.options.height = h;
    if (typeof w === "number") {
      w = Math.round(w);
    }
    if (typeof h === "number") {
      h = Math.round(h);
    }
    this.container.style.width = w == null ? "" : `${w}px`;
    this.container.style.height = h == null ? "" : `${h}px`;
    const size2 = this.getComputedSize();
    this.graph.trigger("resize", Object.assign({}, size2));
    return this;
  }
  getComputedSize() {
    let w = this.options.width;
    let h = this.options.height;
    if (!number_exports.isNumber(w)) {
      w = this.container.clientWidth;
    }
    if (!number_exports.isNumber(h)) {
      h = this.container.clientHeight;
    }
    return { width: w, height: h };
  }
  getScale() {
    return main_exports3.matrixToScale(this.getMatrix());
  }
  scale(sx, sy = sx, ox = 0, oy = 0) {
    sx = this.clampScale(sx);
    sy = this.clampScale(sy);
    if (ox || oy) {
      const ts = this.getTranslation();
      const tx = ts.tx - ox * (sx - 1);
      const ty = ts.ty - oy * (sy - 1);
      if (tx !== ts.tx || ty !== ts.ty) {
        this.translate(tx, ty);
      }
    }
    const matrix = this.getMatrix();
    matrix.a = sx;
    matrix.d = sy;
    this.setMatrix(matrix);
    this.graph.trigger("scale", { sx, sy, ox, oy });
    return this;
  }
  clampScale(scale2) {
    const range2 = this.graph.options.scaling;
    return number_exports.clamp(scale2, range2.min || 0.01, range2.max || 16);
  }
  getZoom() {
    return this.getScale().sx;
  }
  zoom(factor, options) {
    options = options || {};
    let sx = factor;
    let sy = factor;
    const scale2 = this.getScale();
    const clientSize = this.getComputedSize();
    let cx = clientSize.width / 2;
    let cy = clientSize.height / 2;
    if (!options.absolute) {
      sx += scale2.sx;
      sy += scale2.sy;
    }
    if (options.scaleGrid) {
      sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;
      sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;
    }
    if (options.maxScale) {
      sx = Math.min(options.maxScale, sx);
      sy = Math.min(options.maxScale, sy);
    }
    if (options.minScale) {
      sx = Math.max(options.minScale, sx);
      sy = Math.max(options.minScale, sy);
    }
    if (options.center) {
      cx = options.center.x;
      cy = options.center.y;
    }
    sx = this.clampScale(sx);
    sy = this.clampScale(sy);
    if (cx || cy) {
      const ts = this.getTranslation();
      const tx = cx - (cx - ts.tx) * (sx / scale2.sx);
      const ty = cy - (cy - ts.ty) * (sy / scale2.sy);
      if (tx !== ts.tx || ty !== ts.ty) {
        this.translate(tx, ty);
      }
    }
    this.scale(sx, sy);
    return this;
  }
  getRotation() {
    return main_exports3.matrixToRotation(this.getMatrix());
  }
  rotate(angle, cx, cy) {
    if (cx == null || cy == null) {
      const bbox2 = Util2.getBBox(this.stage);
      cx = bbox2.width / 2;
      cy = bbox2.height / 2;
    }
    const ctm = this.getMatrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);
    this.setMatrix(ctm);
    return this;
  }
  getTranslation() {
    return main_exports3.matrixToTranslation(this.getMatrix());
  }
  translate(tx, ty) {
    const matrix = this.getMatrix();
    matrix.e = tx || 0;
    matrix.f = ty || 0;
    this.setMatrix(matrix);
    const ts = this.getTranslation();
    this.options.x = ts.tx;
    this.options.y = ts.ty;
    this.graph.trigger("translate", Object.assign({}, ts));
    return this;
  }
  setOrigin(ox, oy) {
    return this.translate(ox || 0, oy || 0);
  }
  fitToContent(gridWidth, gridHeight, padding, options) {
    if (typeof gridWidth === "object") {
      const opts = gridWidth;
      gridWidth = opts.gridWidth || 1;
      gridHeight = opts.gridHeight || 1;
      padding = opts.padding || 0;
      options = opts;
    } else {
      gridWidth = gridWidth || 1;
      gridHeight = gridHeight || 1;
      padding = padding || 0;
      if (options == null) {
        options = {};
      }
    }
    const paddings = number_exports.normalizeSides(padding);
    const border = options.border || 0;
    const contentArea = options.contentArea ? Rectangle.create(options.contentArea) : this.getContentArea(options);
    if (border > 0) {
      contentArea.inflate(border);
    }
    const scale2 = this.getScale();
    const translate2 = this.getTranslation();
    const sx = scale2.sx;
    const sy = scale2.sy;
    contentArea.x *= sx;
    contentArea.y *= sy;
    contentArea.width *= sx;
    contentArea.height *= sy;
    let width2 = Math.max(Math.ceil((contentArea.width + contentArea.x) / gridWidth), 1) * gridWidth;
    let height2 = Math.max(Math.ceil((contentArea.height + contentArea.y) / gridHeight), 1) * gridHeight;
    let tx = 0;
    let ty = 0;
    if (options.allowNewOrigin === "negative" && contentArea.x < 0 || options.allowNewOrigin === "positive" && contentArea.x >= 0 || options.allowNewOrigin === "any") {
      tx = Math.ceil(-contentArea.x / gridWidth) * gridWidth;
      tx += paddings.left;
      width2 += tx;
    }
    if (options.allowNewOrigin === "negative" && contentArea.y < 0 || options.allowNewOrigin === "positive" && contentArea.y >= 0 || options.allowNewOrigin === "any") {
      ty = Math.ceil(-contentArea.y / gridHeight) * gridHeight;
      ty += paddings.top;
      height2 += ty;
    }
    width2 += paddings.right;
    height2 += paddings.bottom;
    width2 = Math.max(width2, options.minWidth || 0);
    height2 = Math.max(height2, options.minHeight || 0);
    width2 = Math.min(width2, options.maxWidth || Number.MAX_SAFE_INTEGER);
    height2 = Math.min(height2, options.maxHeight || Number.MAX_SAFE_INTEGER);
    const size2 = this.getComputedSize();
    const sizeChanged = width2 !== size2.width || height2 !== size2.height;
    const originChanged = tx !== translate2.tx || ty !== translate2.ty;
    if (originChanged) {
      this.translate(tx, ty);
    }
    if (sizeChanged) {
      this.resize(width2, height2);
    }
    return new Rectangle(-tx / sx, -ty / sy, width2 / sx, height2 / sy);
  }
  scaleContentToFit(options = {}) {
    this.scaleContentToFitImpl(options);
  }
  scaleContentToFitImpl(options = {}, translate2 = true) {
    let contentBBox;
    let contentLocalOrigin;
    if (options.contentArea) {
      const contentArea = options.contentArea;
      contentBBox = this.graph.localToGraph(contentArea);
      contentLocalOrigin = Point.create(contentArea);
    } else {
      contentBBox = this.getContentBBox(options);
      contentLocalOrigin = this.graph.graphToLocal(contentBBox);
    }
    if (!contentBBox.width || !contentBBox.height) {
      return;
    }
    const padding = number_exports.normalizeSides(options.padding);
    const minScale = options.minScale || 0;
    const maxScale = options.maxScale || Number.MAX_SAFE_INTEGER;
    const minScaleX = options.minScaleX || minScale;
    const maxScaleX = options.maxScaleX || maxScale;
    const minScaleY = options.minScaleY || minScale;
    const maxScaleY = options.maxScaleY || maxScale;
    let fittingBox;
    if (options.viewportArea) {
      fittingBox = options.viewportArea;
    } else {
      const computedSize = this.getComputedSize();
      const currentTranslate = this.getTranslation();
      fittingBox = {
        x: currentTranslate.tx,
        y: currentTranslate.ty,
        width: computedSize.width,
        height: computedSize.height
      };
    }
    fittingBox = Rectangle.create(fittingBox).moveAndExpand({
      x: padding.left,
      y: padding.top,
      width: -padding.left - padding.right,
      height: -padding.top - padding.bottom
    });
    const currentScale = this.getScale();
    let newSX = fittingBox.width / contentBBox.width * currentScale.sx;
    let newSY = fittingBox.height / contentBBox.height * currentScale.sy;
    if (options.preserveAspectRatio !== false) {
      newSX = newSY = Math.min(newSX, newSY);
    }
    const gridSize = options.scaleGrid;
    if (gridSize) {
      newSX = gridSize * Math.floor(newSX / gridSize);
      newSY = gridSize * Math.floor(newSY / gridSize);
    }
    newSX = number_exports.clamp(newSX, minScaleX, maxScaleX);
    newSY = number_exports.clamp(newSY, minScaleY, maxScaleY);
    this.scale(newSX, newSY);
    if (translate2) {
      const origin = this.options;
      const newOX = fittingBox.x - contentLocalOrigin.x * newSX - origin.x;
      const newOY = fittingBox.y - contentLocalOrigin.y * newSY - origin.y;
      this.translate(newOX, newOY);
    }
  }
  getContentArea(options = {}) {
    if (options.useCellGeometry !== false) {
      return this.model.getAllCellsBBox() || new Rectangle();
    }
    return Util2.getBBox(this.stage);
  }
  getContentBBox(options = {}) {
    return this.graph.localToGraph(this.getContentArea(options));
  }
  getGraphArea() {
    const rect2 = Rectangle.fromSize(this.getComputedSize());
    return this.graph.graphToLocal(rect2);
  }
  zoomToRect(rect2, options = {}) {
    const area = Rectangle.create(rect2);
    const graph = this.graph;
    options.contentArea = area;
    if (options.viewportArea == null) {
      options.viewportArea = {
        x: graph.options.x,
        y: graph.options.y,
        width: this.options.width,
        height: this.options.height
      };
    }
    this.scaleContentToFitImpl(options, false);
    const center2 = area.getCenter();
    this.centerPoint(center2.x, center2.y);
    return this;
  }
  zoomToFit(options = {}) {
    return this.zoomToRect(this.getContentArea(options), options);
  }
  centerPoint(x, y) {
    const clientSize = this.getComputedSize();
    const scale2 = this.getScale();
    const ts = this.getTranslation();
    const cx = clientSize.width / 2;
    const cy = clientSize.height / 2;
    x = typeof x === "number" ? x : cx;
    y = typeof y === "number" ? y : cy;
    x = cx - x * scale2.sx;
    y = cy - y * scale2.sy;
    if (ts.tx !== x || ts.ty !== y) {
      this.translate(x, y);
    }
  }
  centerContent(options) {
    const rect2 = this.graph.getContentArea(options);
    const center2 = rect2.getCenter();
    this.centerPoint(center2.x, center2.y);
  }
  centerCell(cell) {
    return this.positionCell(cell, "center");
  }
  positionPoint(point, x, y) {
    const clientSize = this.getComputedSize();
    x = number_exports.normalizePercentage(x, Math.max(0, clientSize.width));
    if (x < 0) {
      x = clientSize.width + x;
    }
    y = number_exports.normalizePercentage(y, Math.max(0, clientSize.height));
    if (y < 0) {
      y = clientSize.height + y;
    }
    const ts = this.getTranslation();
    const scale2 = this.getScale();
    const dx = x - point.x * scale2.sx;
    const dy = y - point.y * scale2.sy;
    if (ts.tx !== dx || ts.ty !== dy) {
      this.translate(dx, dy);
    }
  }
  positionRect(rect2, pos) {
    const bbox2 = Rectangle.create(rect2);
    switch (pos) {
      case "center":
        return this.positionPoint(bbox2.getCenter(), "50%", "50%");
      case "top":
        return this.positionPoint(bbox2.getTopCenter(), "50%", 0);
      case "top-right":
        return this.positionPoint(bbox2.getTopRight(), "100%", 0);
      case "right":
        return this.positionPoint(bbox2.getRightMiddle(), "100%", "50%");
      case "bottom-right":
        return this.positionPoint(bbox2.getBottomRight(), "100%", "100%");
      case "bottom":
        return this.positionPoint(bbox2.getBottomCenter(), "50%", "100%");
      case "bottom-left":
        return this.positionPoint(bbox2.getBottomLeft(), 0, "100%");
      case "left":
        return this.positionPoint(bbox2.getLeftMiddle(), 0, "50%");
      case "top-left":
        return this.positionPoint(bbox2.getTopLeft(), 0, 0);
      default:
        return this;
    }
  }
  positionCell(cell, pos) {
    const bbox2 = cell.getBBox();
    return this.positionRect(bbox2, pos);
  }
  positionContent(pos, options) {
    const rect2 = this.graph.getContentArea(options);
    return this.positionRect(rect2, pos);
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/background.js
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BackgroundManager = class extends Base2 {
  get elem() {
    return this.view.background;
  }
  init() {
    this.startListening();
    if (this.options.background) {
      this.draw(this.options.background);
    }
  }
  startListening() {
    this.graph.on("scale", this.update, this);
    this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this);
    this.graph.off("translate", this.update, this);
  }
  updateBackgroundImage(options = {}) {
    let backgroundSize = options.size || "auto auto";
    let backgroundPosition = options.position || "center";
    const scale2 = this.graph.transform.getScale();
    const ts = this.graph.translate();
    if (typeof backgroundPosition === "object") {
      const x = ts.tx + scale2.sx * (backgroundPosition.x || 0);
      const y = ts.ty + scale2.sy * (backgroundPosition.y || 0);
      backgroundPosition = `${x}px ${y}px`;
    }
    if (typeof backgroundSize === "object") {
      backgroundSize = Rectangle.fromSize(backgroundSize).scale(scale2.sx, scale2.sy);
      backgroundSize = `${backgroundSize.width}px ${backgroundSize.height}px`;
    }
    this.elem.style.backgroundSize = backgroundSize;
    this.elem.style.backgroundPosition = backgroundPosition;
  }
  drawBackgroundImage(img, options = {}) {
    if (!(img instanceof HTMLImageElement)) {
      this.elem.style.backgroundImage = "";
      return;
    }
    const cache = this.optionsCache;
    if (cache && cache.image !== options.image) {
      return;
    }
    let uri;
    const opacity2 = options.opacity;
    const backgroundSize = options.size;
    let backgroundRepeat = options.repeat || "no-repeat";
    const pattern = Background.registry.get(backgroundRepeat);
    if (typeof pattern === "function") {
      const quality = options.quality || 1;
      img.width *= quality;
      img.height *= quality;
      const canvas = pattern(img, options);
      if (!(canvas instanceof HTMLCanvasElement)) {
        throw new Error("Background pattern must return an HTML Canvas instance");
      }
      uri = canvas.toDataURL("image/png");
      if (options.repeat && backgroundRepeat !== options.repeat) {
        backgroundRepeat = options.repeat;
      } else {
        backgroundRepeat = "repeat";
      }
      if (typeof backgroundSize === "object") {
        backgroundSize.width *= canvas.width / img.width;
        backgroundSize.height *= canvas.height / img.height;
      } else if (backgroundSize === void 0) {
        options.size = {
          width: canvas.width / quality,
          height: canvas.height / quality
        };
      }
    } else {
      uri = img.src;
      if (backgroundSize === void 0) {
        options.size = {
          width: img.width,
          height: img.height
        };
      }
    }
    if (cache != null && typeof options.size === "object" && options.image === cache.image && options.repeat === cache.repeat && options.quality === cache.quality) {
      cache.size = object_exports.clone(options.size);
    }
    const style2 = this.elem.style;
    style2.backgroundImage = `url(${uri})`;
    style2.backgroundRepeat = backgroundRepeat;
    style2.opacity = opacity2 == null || opacity2 >= 1 ? "" : `${opacity2}`;
    this.updateBackgroundImage(options);
  }
  updateBackgroundColor(color) {
    this.elem.style.backgroundColor = color || "";
  }
  updateBackgroundOptions(options) {
    this.graph.options.background = options;
  }
  update() {
    if (this.optionsCache) {
      this.updateBackgroundImage(this.optionsCache);
    }
  }
  draw(options) {
    const opts = options || {};
    this.updateBackgroundOptions(options);
    this.updateBackgroundColor(opts.color);
    if (opts.image) {
      this.optionsCache = object_exports.clone(opts);
      const img = document.createElement("img");
      img.onload = () => this.drawBackgroundImage(img, options);
      img.setAttribute("crossorigin", "anonymous");
      img.src = opts.image;
    } else {
      this.drawBackgroundImage(null);
      this.optionsCache = null;
    }
  }
  clear() {
    this.draw();
  }
  dispose() {
    this.clear();
    this.stopListening();
  }
};
__decorate11([
  Base2.dispose()
], BackgroundManager.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/panning.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PanningManager = class extends Base2 {
  get widgetOptions() {
    return this.options.panning;
  }
  get pannable() {
    return this.widgetOptions && this.widgetOptions.enabled === true;
  }
  init() {
    this.onRightMouseDown = this.onRightMouseDown.bind(this);
    this.onSpaceKeyDown = this.onSpaceKeyDown.bind(this);
    this.onSpaceKeyUp = this.onSpaceKeyUp.bind(this);
    this.startListening();
    this.updateClassName();
  }
  startListening() {
    this.graph.on("blank:mousedown", this.onMouseDown, this);
    this.graph.on("node:unhandled:mousedown", this.onMouseDown, this);
    this.graph.on("edge:unhandled:mousedown", this.onMouseDown, this);
    main_exports3.Event.on(this.graph.container, "mousedown", this.onRightMouseDown);
    main_exports3.Event.on(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    });
    this.mousewheelHandle = new main_exports3.MouseWheelHandle(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
    this.mousewheelHandle.enable();
  }
  stopListening() {
    this.graph.off("blank:mousedown", this.onMouseDown, this);
    this.graph.off("node:unhandled:mousedown", this.onMouseDown, this);
    this.graph.off("edge:unhandled:mousedown", this.onMouseDown, this);
    main_exports3.Event.off(this.graph.container, "mousedown", this.onRightMouseDown);
    main_exports3.Event.off(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    });
    if (this.mousewheelHandle) {
      this.mousewheelHandle.disable();
    }
  }
  allowPanning(e, strict) {
    ;
    e.spaceKey = this.isSpaceKeyPressed;
    return this.pannable && ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict);
  }
  startPanning(evt) {
    const e = this.view.normalizeEvent(evt);
    this.clientX = e.clientX;
    this.clientY = e.clientY;
    this.panning = true;
    this.updateClassName();
    main_exports3.Event.on(document.body, {
      "mousemove.panning touchmove.panning": this.pan.bind(this),
      "mouseup.panning touchend.panning": this.stopPanning.bind(this),
      "mouseleave.panning": this.stopPanning.bind(this)
    });
    main_exports3.Event.on(window, "mouseup.panning", this.stopPanning.bind(this));
  }
  pan(evt) {
    const e = this.view.normalizeEvent(evt);
    const dx = e.clientX - this.clientX;
    const dy = e.clientY - this.clientY;
    this.clientX = e.clientX;
    this.clientY = e.clientY;
    this.graph.translateBy(dx, dy);
  }
  // eslint-disable-next-line
  stopPanning(e) {
    this.panning = false;
    this.updateClassName();
    main_exports3.Event.off(document.body, ".panning");
    main_exports3.Event.off(window, ".panning");
  }
  updateClassName() {
    const container = this.view.container;
    const panning = this.view.prefixClassName("graph-panning");
    const pannable = this.view.prefixClassName("graph-pannable");
    if (this.pannable) {
      if (this.panning) {
        main_exports3.addClass(container, panning);
        main_exports3.removeClass(container, pannable);
      } else {
        main_exports3.removeClass(container, panning);
        main_exports3.addClass(container, pannable);
      }
    } else {
      main_exports3.removeClass(container, panning);
      main_exports3.removeClass(container, pannable);
    }
  }
  onMouseDown({ e }) {
    if (!this.allowBlankMouseDown(e)) {
      return;
    }
    const selection = this.graph.getPlugin("selection");
    const allowRubberband = selection && selection.allowRubberband(e, true);
    if (this.allowPanning(e, true) || this.allowPanning(e) && !allowRubberband) {
      this.startPanning(e);
    }
  }
  onRightMouseDown(e) {
    const eventTypes = this.widgetOptions.eventTypes;
    if (!((eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes("rightMouseDown")) && e.button === 2)) {
      return;
    }
    if (this.allowPanning(e, true)) {
      this.startPanning(e);
    }
  }
  onMouseWheel(e, deltaX, deltaY) {
    this.graph.translateBy(-deltaX, -deltaY);
  }
  onSpaceKeyDown(e) {
    if (e.which === 32) {
      this.isSpaceKeyPressed = true;
    }
  }
  onSpaceKeyUp(e) {
    if (e.which === 32) {
      this.isSpaceKeyPressed = false;
    }
  }
  allowBlankMouseDown(e) {
    const eventTypes = this.widgetOptions.eventTypes;
    return (eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes("leftMouseDown")) && e.button === 0 || (eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes("mouseWheelDown")) && e.button === 1;
  }
  allowMouseWheel(e) {
    var _a;
    return this.pannable && !e.ctrlKey && ((_a = this.widgetOptions.eventTypes) === null || _a === void 0 ? void 0 : _a.includes("mouseWheel"));
  }
  autoPanning(x, y) {
    const buffer = 10;
    const graphArea = this.graph.getGraphArea();
    let dx = 0;
    let dy = 0;
    if (x <= graphArea.left + buffer) {
      dx = -buffer;
    }
    if (y <= graphArea.top + buffer) {
      dy = -buffer;
    }
    if (x >= graphArea.right - buffer) {
      dx = buffer;
    }
    if (y >= graphArea.bottom - buffer) {
      dy = buffer;
    }
    if (dx !== 0 || dy !== 0) {
      this.graph.translateBy(-dx, -dy);
    }
  }
  enablePanning() {
    if (!this.pannable) {
      this.widgetOptions.enabled = true;
      this.updateClassName();
    }
  }
  disablePanning() {
    if (this.pannable) {
      this.widgetOptions.enabled = false;
      this.updateClassName();
    }
  }
  dispose() {
    this.stopListening();
  }
};
__decorate12([
  Base2.dispose()
], PanningManager.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/mousewheel.js
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var MouseWheel = class extends Base2 {
  constructor() {
    super(...arguments);
    this.cumulatedFactor = 1;
  }
  get widgetOptions() {
    return this.options.mousewheel;
  }
  init() {
    this.container = this.graph.container;
    this.target = this.widgetOptions.global ? document : this.container;
    this.mousewheelHandle = new main_exports3.MouseWheelHandle(this.target, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
    if (this.widgetOptions.enabled) {
      this.enable(true);
    }
  }
  get disabled() {
    return this.widgetOptions.enabled !== true;
  }
  enable(force) {
    if (this.disabled || force) {
      this.widgetOptions.enabled = true;
      this.mousewheelHandle.enable();
    }
  }
  disable() {
    if (!this.disabled) {
      this.widgetOptions.enabled = false;
      this.mousewheelHandle.disable();
    }
  }
  allowMouseWheel(e) {
    const guard = this.widgetOptions.guard;
    return (guard == null || guard(e)) && ModifierKey.isMatch(e, this.widgetOptions.modifiers);
  }
  onMouseWheel(e) {
    const guard = this.widgetOptions.guard;
    if ((guard == null || guard(e)) && ModifierKey.isMatch(e, this.widgetOptions.modifiers)) {
      const factor = this.widgetOptions.factor || 1.2;
      if (this.currentScale == null) {
        this.startPos = { x: e.clientX, y: e.clientY };
        this.currentScale = this.graph.transform.getScale().sx;
      }
      const delta = e.deltaY;
      if (delta < 0) {
        if (this.currentScale < 0.15) {
          this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale;
        } else {
          this.cumulatedFactor = Math.round(this.currentScale * factor * 20) / 20 / this.currentScale;
          if (this.cumulatedFactor === 1) {
            this.cumulatedFactor = 1.05;
          }
        }
      } else {
        if (this.currentScale <= 0.15) {
          this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale;
        } else {
          this.cumulatedFactor = Math.round(this.currentScale * (1 / factor) * 20) / 20 / this.currentScale;
          if (this.cumulatedFactor === 1) {
            this.cumulatedFactor = 0.95;
          }
        }
      }
      this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) / this.currentScale);
      const currentScale = this.currentScale;
      let targetScale = this.graph.transform.clampScale(currentScale * this.cumulatedFactor);
      const minScale = this.widgetOptions.minScale || Number.MIN_SAFE_INTEGER;
      const maxScale = this.widgetOptions.maxScale || Number.MAX_SAFE_INTEGER;
      targetScale = number_exports.clamp(targetScale, minScale, maxScale);
      if (targetScale !== currentScale) {
        if (this.widgetOptions.zoomAtMousePosition) {
          const hasScroller = !!this.graph.getPlugin("scroller");
          const origin = hasScroller ? this.graph.clientToLocal(this.startPos) : this.graph.clientToGraph(this.startPos);
          this.graph.zoom(targetScale, {
            absolute: true,
            center: origin.clone()
          });
        } else {
          this.graph.zoom(targetScale, { absolute: true });
        }
      }
      this.currentScale = null;
      this.cumulatedFactor = 1;
    }
  }
  dispose() {
    this.disable();
  }
};
__decorate13([
  Disposable.dispose()
], MouseWheel.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/virtual-render.js
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var VirtualRenderManager = class extends Base2 {
  init() {
    this.resetRenderArea = main_exports.throttle(this.resetRenderArea, 200, {
      leading: true
    });
    this.resetRenderArea();
    this.startListening();
  }
  startListening() {
    this.graph.on("translate", this.resetRenderArea, this);
    this.graph.on("scale", this.resetRenderArea, this);
    this.graph.on("resize", this.resetRenderArea, this);
  }
  stopListening() {
    this.graph.off("translate", this.resetRenderArea, this);
    this.graph.off("scale", this.resetRenderArea, this);
    this.graph.off("resize", this.resetRenderArea, this);
  }
  enableVirtualRender() {
    this.options.virtual = true;
    this.resetRenderArea();
  }
  disableVirtualRender() {
    this.options.virtual = false;
    this.graph.renderer.setRenderArea(void 0);
  }
  resetRenderArea() {
    if (this.options.virtual) {
      const renderArea = this.graph.getGraphArea();
      this.graph.renderer.setRenderArea(renderArea);
    }
  }
  dispose() {
    this.stopListening();
  }
};
__decorate14([
  Base2.dispose()
], VirtualRenderManager.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/renderer/queueJob.js
var JobQueue = class {
  constructor() {
    this.isFlushing = false;
    this.isFlushPending = false;
    this.scheduleId = 0;
    this.queue = [];
    this.frameInterval = 33;
    this.initialTime = Date.now();
  }
  queueJob(job) {
    if (job.priority & JOB_PRIORITY.PRIOR) {
      job.cb();
    } else {
      const index2 = this.findInsertionIndex(job);
      if (index2 >= 0) {
        this.queue.splice(index2, 0, job);
      }
    }
  }
  queueFlush() {
    if (!this.isFlushing && !this.isFlushPending) {
      this.isFlushPending = true;
      this.scheduleJob();
    }
  }
  queueFlushSync() {
    if (!this.isFlushing && !this.isFlushPending) {
      this.isFlushPending = true;
      this.flushJobsSync();
    }
  }
  clearJobs() {
    this.queue.length = 0;
    this.isFlushing = false;
    this.isFlushPending = false;
    this.cancelScheduleJob();
  }
  flushJobs() {
    this.isFlushPending = false;
    this.isFlushing = true;
    const startTime = this.getCurrentTime();
    let job;
    while (job = this.queue.shift()) {
      job.cb();
      if (this.getCurrentTime() - startTime >= this.frameInterval) {
        break;
      }
    }
    this.isFlushing = false;
    if (this.queue.length) {
      this.queueFlush();
    }
  }
  flushJobsSync() {
    this.isFlushPending = false;
    this.isFlushing = true;
    let job;
    while (job = this.queue.shift()) {
      try {
        job.cb();
      } catch (error) {
        console.log(error);
      }
    }
    this.isFlushing = false;
  }
  findInsertionIndex(job) {
    let left4 = 0;
    let ins = this.queue.length;
    let right4 = ins - 1;
    const priority = job.priority;
    while (left4 <= right4) {
      const mid = (right4 - left4 >> 1) + left4;
      if (priority <= this.queue[mid].priority) {
        left4 = mid + 1;
      } else {
        ins = mid;
        right4 = mid - 1;
      }
    }
    return ins;
  }
  scheduleJob() {
    if ("requestIdleCallback" in window) {
      if (this.scheduleId) {
        this.cancelScheduleJob();
      }
      this.scheduleId = window.requestIdleCallback(this.flushJobs.bind(this), {
        timeout: 100
      });
    } else {
      if (this.scheduleId) {
        this.cancelScheduleJob();
      }
      this.scheduleId = window.setTimeout(this.flushJobs.bind(this));
    }
  }
  cancelScheduleJob() {
    if ("cancelIdleCallback" in window) {
      if (this.scheduleId) {
        window.cancelIdleCallback(this.scheduleId);
      }
      this.scheduleId = 0;
    } else {
      if (this.scheduleId) {
        clearTimeout(this.scheduleId);
      }
      this.scheduleId = 0;
    }
  }
  getCurrentTime() {
    const hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
    if (hasPerformanceNow) {
      return performance.now();
    }
    return Date.now() - this.initialTime;
  }
};
var JOB_PRIORITY;
(function(JOB_PRIORITY2) {
  JOB_PRIORITY2[JOB_PRIORITY2["Update"] = 2] = "Update";
  JOB_PRIORITY2[JOB_PRIORITY2["RenderEdge"] = 4] = "RenderEdge";
  JOB_PRIORITY2[JOB_PRIORITY2["RenderNode"] = 8] = "RenderNode";
  JOB_PRIORITY2[JOB_PRIORITY2["PRIOR"] = 1048576] = "PRIOR";
})(JOB_PRIORITY || (JOB_PRIORITY = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/renderer/scheduler.js
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Scheduler = class _Scheduler extends Disposable {
  get model() {
    return this.graph.model;
  }
  get container() {
    return this.graph.view.stage;
  }
  constructor(graph) {
    super();
    this.views = {};
    this.willRemoveViews = {};
    this.queue = new JobQueue();
    this.graph = graph;
    this.init();
  }
  init() {
    this.startListening();
    this.renderViews(this.model.getCells());
  }
  startListening() {
    this.model.on("reseted", this.onModelReseted, this);
    this.model.on("cell:added", this.onCellAdded, this);
    this.model.on("cell:removed", this.onCellRemoved, this);
    this.model.on("cell:change:zIndex", this.onCellZIndexChanged, this);
    this.model.on("cell:change:visible", this.onCellVisibleChanged, this);
  }
  stopListening() {
    this.model.off("reseted", this.onModelReseted, this);
    this.model.off("cell:added", this.onCellAdded, this);
    this.model.off("cell:removed", this.onCellRemoved, this);
    this.model.off("cell:change:zIndex", this.onCellZIndexChanged, this);
    this.model.off("cell:change:visible", this.onCellVisibleChanged, this);
  }
  onModelReseted({ options }) {
    this.queue.clearJobs();
    this.removeZPivots();
    this.resetViews();
    const cells = this.model.getCells();
    this.renderViews(cells, Object.assign(Object.assign({}, options), { queue: cells.map((cell) => cell.id) }));
  }
  onCellAdded({ cell, options }) {
    this.renderViews([cell], options);
  }
  onCellRemoved({ cell }) {
    this.removeViews([cell]);
  }
  onCellZIndexChanged({ cell, options }) {
    const viewItem = this.views[cell.id];
    if (viewItem) {
      this.requestViewUpdate(viewItem.view, _Scheduler.FLAG_INSERT, options, JOB_PRIORITY.Update, true);
    }
  }
  onCellVisibleChanged({ cell, current }) {
    this.toggleVisible(cell, !!current);
  }
  requestViewUpdate(view, flag, options = {}, priority = JOB_PRIORITY.Update, flush = true) {
    const id = view.cell.id;
    const viewItem = this.views[id];
    if (!viewItem) {
      return;
    }
    viewItem.flag = flag;
    viewItem.options = options;
    const priorAction = view.hasAction(flag, ["translate", "resize", "rotate"]);
    if (priorAction || options.async === false) {
      priority = JOB_PRIORITY.PRIOR;
      flush = false;
    }
    this.queue.queueJob({
      id,
      priority,
      cb: () => {
        this.renderViewInArea(view, flag, options);
        const queue = options.queue;
        if (queue) {
          const index2 = queue.indexOf(view.cell.id);
          if (index2 >= 0) {
            queue.splice(index2, 1);
          }
          if (queue.length === 0) {
            this.graph.trigger("render:done");
          }
        }
      }
    });
    const effectedEdges = this.getEffectedEdges(view);
    effectedEdges.forEach((edge) => {
      this.requestViewUpdate(edge.view, edge.flag, options, priority, false);
    });
    if (flush) {
      this.flush();
    }
  }
  setRenderArea(area) {
    this.renderArea = area;
    this.flushWaitingViews();
  }
  isViewMounted(view) {
    if (view == null) {
      return false;
    }
    const viewItem = this.views[view.cell.id];
    if (!viewItem) {
      return false;
    }
    return viewItem.state === _Scheduler.ViewState.MOUNTED;
  }
  renderViews(cells, options = {}) {
    cells.sort((c1, c2) => {
      if (c1.isNode() && c2.isEdge()) {
        return -1;
      }
      return 0;
    });
    cells.forEach((cell) => {
      const id = cell.id;
      const views = this.views;
      let flag = 0;
      let viewItem = views[id];
      if (viewItem) {
        flag = _Scheduler.FLAG_INSERT;
      } else {
        const cellView = this.createCellView(cell);
        if (cellView) {
          cellView.graph = this.graph;
          flag = _Scheduler.FLAG_INSERT | cellView.getBootstrapFlag();
          viewItem = {
            view: cellView,
            flag,
            options,
            state: _Scheduler.ViewState.CREATED
          };
          this.views[id] = viewItem;
        }
      }
      if (viewItem) {
        this.requestViewUpdate(viewItem.view, flag, options, this.getRenderPriority(viewItem.view), false);
      }
    });
    this.flush();
  }
  renderViewInArea(view, flag, options = {}) {
    const cell = view.cell;
    const id = cell.id;
    const viewItem = this.views[id];
    if (!viewItem) {
      return;
    }
    let result2 = 0;
    if (this.isUpdatable(view)) {
      result2 = this.updateView(view, flag, options);
      viewItem.flag = result2;
    } else {
      if (viewItem.state === _Scheduler.ViewState.MOUNTED) {
        result2 = this.updateView(view, flag, options);
        viewItem.flag = result2;
      } else {
        viewItem.state = _Scheduler.ViewState.WAITING;
      }
    }
    if (result2) {
      if (cell.isEdge() && (result2 & view.getFlag(["source", "target"])) === 0) {
        this.queue.queueJob({
          id,
          priority: JOB_PRIORITY.RenderEdge,
          cb: () => {
            this.updateView(view, flag, options);
          }
        });
      }
    }
  }
  removeViews(cells) {
    cells.forEach((cell) => {
      const id = cell.id;
      const viewItem = this.views[id];
      if (viewItem) {
        this.willRemoveViews[id] = viewItem;
        delete this.views[id];
        this.queue.queueJob({
          id,
          priority: this.getRenderPriority(viewItem.view),
          cb: () => {
            this.removeView(viewItem.view);
          }
        });
      }
    });
    this.flush();
  }
  flush() {
    this.graph.options.async ? this.queue.queueFlush() : this.queue.queueFlushSync();
  }
  flushWaitingViews() {
    Object.values(this.views).forEach((viewItem) => {
      if (viewItem && viewItem.state === _Scheduler.ViewState.WAITING) {
        const { view, flag, options } = viewItem;
        this.requestViewUpdate(view, flag, options, this.getRenderPriority(view), false);
      }
    });
    this.flush();
  }
  updateView(view, flag, options = {}) {
    if (view == null) {
      return 0;
    }
    if (CellView.isCellView(view)) {
      if (flag & _Scheduler.FLAG_REMOVE) {
        this.removeView(view.cell);
        return 0;
      }
      if (flag & _Scheduler.FLAG_INSERT) {
        this.insertView(view);
        flag ^= _Scheduler.FLAG_INSERT;
      }
    }
    if (!flag) {
      return 0;
    }
    return view.confirmUpdate(flag, options);
  }
  insertView(view) {
    const viewItem = this.views[view.cell.id];
    if (viewItem) {
      const zIndex = view.cell.getZIndex();
      const pivot = this.addZPivot(zIndex);
      this.container.insertBefore(view.container, pivot);
      if (!view.cell.isVisible()) {
        this.toggleVisible(view.cell, false);
      }
      viewItem.state = _Scheduler.ViewState.MOUNTED;
      this.graph.trigger("view:mounted", { view });
    }
  }
  resetViews() {
    this.willRemoveViews = Object.assign(Object.assign({}, this.views), this.willRemoveViews);
    Object.values(this.willRemoveViews).forEach((viewItem) => {
      if (viewItem) {
        this.removeView(viewItem.view);
      }
    });
    this.views = {};
    this.willRemoveViews = {};
  }
  removeView(view) {
    const cell = view.cell;
    const viewItem = this.willRemoveViews[cell.id];
    if (viewItem && view) {
      viewItem.view.remove();
      delete this.willRemoveViews[cell.id];
      this.graph.trigger("view:unmounted", { view });
    }
  }
  toggleVisible(cell, visible) {
    const edges = this.model.getConnectedEdges(cell);
    for (let i = 0, len = edges.length; i < len; i += 1) {
      const edge = edges[i];
      if (visible) {
        const source = edge.getSourceCell();
        const target = edge.getTargetCell();
        if (source && !source.isVisible() || target && !target.isVisible()) {
          continue;
        }
        this.toggleVisible(edge, true);
      } else {
        this.toggleVisible(edge, false);
      }
    }
    const viewItem = this.views[cell.id];
    if (viewItem) {
      main_exports3.css(viewItem.view.container, {
        display: visible ? "unset" : "none"
      });
    }
  }
  addZPivot(zIndex = 0) {
    if (this.zPivots == null) {
      this.zPivots = {};
    }
    const pivots = this.zPivots;
    let pivot = pivots[zIndex];
    if (pivot) {
      return pivot;
    }
    pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);
    let neighborZ = -Infinity;
    for (const key in pivots) {
      const currentZ = +key;
      if (currentZ < zIndex && currentZ > neighborZ) {
        neighborZ = currentZ;
        if (neighborZ === zIndex - 1) {
          continue;
        }
      }
    }
    const layer = this.container;
    if (neighborZ !== -Infinity) {
      const neighborPivot = pivots[neighborZ];
      layer.insertBefore(pivot, neighborPivot.nextSibling);
    } else {
      layer.insertBefore(pivot, layer.firstChild);
    }
    return pivot;
  }
  removeZPivots() {
    if (this.zPivots) {
      Object.values(this.zPivots).forEach((elem) => {
        if (elem && elem.parentNode) {
          elem.parentNode.removeChild(elem);
        }
      });
    }
    this.zPivots = {};
  }
  createCellView(cell) {
    const options = { graph: this.graph };
    const createViewHook = this.graph.options.createCellView;
    if (createViewHook) {
      const ret = main_exports.call(createViewHook, this.graph, cell);
      if (ret) {
        return new ret(cell, options);
      }
      if (ret === null) {
        return null;
      }
    }
    const view = cell.view;
    if (view != null && typeof view === "string") {
      const def = CellView.registry.get(view);
      if (def) {
        return new def(cell, options);
      }
      return CellView.registry.onNotFound(view);
    }
    if (cell.isNode()) {
      return new NodeView(cell, options);
    }
    if (cell.isEdge()) {
      return new EdgeView(cell, options);
    }
    return null;
  }
  getEffectedEdges(view) {
    const effectedEdges = [];
    const cell = view.cell;
    const edges = this.model.getConnectedEdges(cell);
    for (let i = 0, n = edges.length; i < n; i += 1) {
      const edge = edges[i];
      const viewItem = this.views[edge.id];
      if (!viewItem) {
        continue;
      }
      const edgeView = viewItem.view;
      if (!this.isViewMounted(edgeView)) {
        continue;
      }
      const flagLabels = ["update"];
      if (edge.getTargetCell() === cell) {
        flagLabels.push("target");
      }
      if (edge.getSourceCell() === cell) {
        flagLabels.push("source");
      }
      effectedEdges.push({
        id: edge.id,
        view: edgeView,
        flag: edgeView.getFlag(flagLabels)
      });
    }
    return effectedEdges;
  }
  isUpdatable(view) {
    if (view.isNodeView()) {
      if (this.renderArea) {
        return this.renderArea.isIntersectWithRect(view.cell.getBBox());
      }
      return true;
    }
    if (view.isEdgeView()) {
      const edge = view.cell;
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();
      if (this.renderArea && sourceCell && targetCell) {
        return this.renderArea.isIntersectWithRect(sourceCell.getBBox()) || this.renderArea.isIntersectWithRect(targetCell.getBBox());
      }
    }
    return true;
  }
  getRenderPriority(view) {
    return view.cell.isNode() ? JOB_PRIORITY.RenderNode : JOB_PRIORITY.RenderEdge;
  }
  dispose() {
    this.stopListening();
    Object.keys(this.views).forEach((id) => {
      this.views[id].view.dispose();
    });
    this.views = {};
  }
};
__decorate15([
  Disposable.dispose()
], Scheduler.prototype, "dispose", null);
(function(Scheduler2) {
  Scheduler2.FLAG_INSERT = 1 << 30;
  Scheduler2.FLAG_REMOVE = 1 << 29;
  Scheduler2.FLAG_RENDER = (1 << 26) - 1;
})(Scheduler || (Scheduler = {}));
(function(Scheduler2) {
  let ViewState;
  (function(ViewState2) {
    ViewState2[ViewState2["CREATED"] = 0] = "CREATED";
    ViewState2[ViewState2["MOUNTED"] = 1] = "MOUNTED";
    ViewState2[ViewState2["WAITING"] = 2] = "WAITING";
  })(ViewState = Scheduler2.ViewState || (Scheduler2.ViewState = {}));
})(Scheduler || (Scheduler = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/renderer/renderer.js
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Renderer = class extends Base2 {
  constructor() {
    super(...arguments);
    this.schedule = new Scheduler(this.graph);
  }
  requestViewUpdate(view, flag, options = {}) {
    this.schedule.requestViewUpdate(view, flag, options);
  }
  isViewMounted(view) {
    return this.schedule.isViewMounted(view);
  }
  setRenderArea(area) {
    this.schedule.setRenderArea(area);
  }
  findViewByElem(elem) {
    if (elem == null) {
      return null;
    }
    const container = this.options.container;
    const target = typeof elem === "string" ? container.querySelector(elem) : elem instanceof Element ? elem : elem[0];
    if (target) {
      const id = this.graph.view.findAttr("data-cell-id", target);
      if (id) {
        const views = this.schedule.views;
        if (views[id]) {
          return views[id].view;
        }
      }
    }
    return null;
  }
  findViewByCell(cell) {
    if (cell == null) {
      return null;
    }
    const id = Cell.isCell(cell) ? cell.id : cell;
    const views = this.schedule.views;
    if (views[id]) {
      return views[id].view;
    }
    return null;
  }
  findViewsFromPoint(p) {
    const ref2 = { x: p.x, y: p.y };
    return this.model.getCells().map((cell) => this.findViewByCell(cell)).filter((view) => {
      if (view != null) {
        return Util2.getBBox(view.container, {
          target: this.view.stage
        }).containsPoint(ref2);
      }
      return false;
    });
  }
  findEdgeViewsFromPoint(p, threshold = 5) {
    return this.model.getEdges().map((edge) => this.findViewByCell(edge)).filter((view) => {
      if (view != null) {
        const point = view.getClosestPoint(p);
        if (point) {
          return point.distance(p) <= threshold;
        }
      }
      return false;
    });
  }
  findViewsInArea(rect2, options = {}) {
    const area = Rectangle.create(rect2);
    return this.model.getCells().map((cell) => this.findViewByCell(cell)).filter((view) => {
      if (view) {
        if (options.nodeOnly && !view.isNodeView()) {
          return false;
        }
        const bbox2 = Util2.getBBox(view.container, {
          target: this.view.stage
        });
        if (bbox2.width === 0) {
          bbox2.inflate(1, 0);
        } else if (bbox2.height === 0) {
          bbox2.inflate(0, 1);
        }
        return options.strict ? area.containsRect(bbox2) : area.isIntersectWithRect(bbox2);
      }
      return false;
    });
  }
  dispose() {
    this.schedule.dispose();
  }
};
__decorate16([
  Base2.dispose()
], Renderer.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/defs.js
var __rest26 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var DefsManager = class extends Base2 {
  get cid() {
    return this.graph.view.cid;
  }
  get svg() {
    return this.view.svg;
  }
  get defs() {
    return this.view.defs;
  }
  isDefined(id) {
    return this.svg.getElementById(id) != null;
  }
  filter(options) {
    let filterId = options.id;
    const name = options.name;
    if (!filterId) {
      filterId = `filter-${name}-${this.cid}-${string_exports.hashcode(JSON.stringify(options))}`;
    }
    if (!this.isDefined(filterId)) {
      const fn = Filter.registry.get(name);
      if (fn == null) {
        return Filter.registry.onNotFound(name);
      }
      const markup = fn(options.args || {});
      const attrs = Object.assign(Object.assign({ x: -1, y: -1, width: 3, height: 3, filterUnits: "objectBoundingBox" }, options.attrs), { id: filterId });
      Vector.create(Markup.sanitize(markup), attrs).appendTo(this.defs);
    }
    return filterId;
  }
  gradient(options) {
    let id = options.id;
    const type = options.type;
    if (!id) {
      id = `gradient-${type}-${this.cid}-${string_exports.hashcode(JSON.stringify(options))}`;
    }
    if (!this.isDefined(id)) {
      const stops = options.stops;
      const arr = stops.map((stop) => {
        const opacity2 = stop.opacity != null && Number.isFinite(stop.opacity) ? stop.opacity : 1;
        return `<stop offset="${stop.offset}" stop-color="${stop.color}" stop-opacity="${opacity2}"/>`;
      });
      const markup = `<${type}>${arr.join("")}</${type}>`;
      const attrs = Object.assign({ id }, options.attrs);
      Vector.create(markup, attrs).appendTo(this.defs);
    }
    return id;
  }
  marker(options) {
    const { id, refX: refX3, refY: refY3, markerUnits, markerOrient, tagName: tagName2, children: children2 } = options, attrs = __rest26(options, ["id", "refX", "refY", "markerUnits", "markerOrient", "tagName", "children"]);
    let markerId = id;
    if (!markerId) {
      markerId = `marker-${this.cid}-${string_exports.hashcode(JSON.stringify(options))}`;
    }
    if (!this.isDefined(markerId)) {
      if (tagName2 !== "path") {
        delete attrs.d;
      }
      const pathMarker = Vector.create("marker", {
        refX: refX3,
        refY: refY3,
        id: markerId,
        overflow: "visible",
        orient: markerOrient != null ? markerOrient : "auto",
        markerUnits: markerUnits || "userSpaceOnUse"
      }, children2 ? children2.map((_a) => {
        var { tagName: tagName3 } = _a, other = __rest26(_a, ["tagName"]);
        return Vector.create(`${tagName3}` || "path", main_exports3.kebablizeAttrs(Object.assign(Object.assign({}, attrs), other)));
      }) : [Vector.create(tagName2 || "path", main_exports3.kebablizeAttrs(attrs))]);
      this.defs.appendChild(pathMarker.node);
    }
    return markerId;
  }
  remove(id) {
    const elem = this.svg.getElementById(id);
    if (elem && elem.parentNode) {
      elem.parentNode.removeChild(elem);
    }
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/coord.js
var CoordManager = class extends Base2 {
  getClientMatrix() {
    return main_exports3.createSVGMatrix(this.view.stage.getScreenCTM());
  }
  /**
   * Returns coordinates of the graph viewport, relative to the window.
   */
  getClientOffset() {
    const rect2 = this.view.svg.getBoundingClientRect();
    return new Point(rect2.left, rect2.top);
  }
  /**
   * Returns coordinates of the graph viewport, relative to the document.
   */
  getPageOffset() {
    return this.getClientOffset().translate(window.scrollX, window.scrollY);
  }
  snapToGrid(x, y) {
    const p = typeof x === "number" ? this.clientToLocalPoint(x, y) : this.clientToLocalPoint(x.x, x.y);
    return p.snapToGrid(this.graph.getGridSize());
  }
  localToGraphPoint(x, y) {
    const localPoint = Point.create(x, y);
    return Util2.transformPoint(localPoint, this.graph.matrix());
  }
  localToClientPoint(x, y) {
    const localPoint = Point.create(x, y);
    return Util2.transformPoint(localPoint, this.getClientMatrix());
  }
  localToPagePoint(x, y) {
    const p = typeof x === "number" ? this.localToGraphPoint(x, y) : this.localToGraphPoint(x);
    return p.translate(this.getPageOffset());
  }
  localToGraphRect(x, y, width2, height2) {
    const localRect = Rectangle.create(x, y, width2, height2);
    return Util2.transformRectangle(localRect, this.graph.matrix());
  }
  localToClientRect(x, y, width2, height2) {
    const localRect = Rectangle.create(x, y, width2, height2);
    return Util2.transformRectangle(localRect, this.getClientMatrix());
  }
  localToPageRect(x, y, width2, height2) {
    const rect2 = typeof x === "number" ? this.localToGraphRect(x, y, width2, height2) : this.localToGraphRect(x);
    return rect2.translate(this.getPageOffset());
  }
  graphToLocalPoint(x, y) {
    const graphPoint = Point.create(x, y);
    return Util2.transformPoint(graphPoint, this.graph.matrix().inverse());
  }
  clientToLocalPoint(x, y) {
    const clientPoint = Point.create(x, y);
    return Util2.transformPoint(clientPoint, this.getClientMatrix().inverse());
  }
  clientToGraphPoint(x, y) {
    const clientPoint = Point.create(x, y);
    return Util2.transformPoint(clientPoint, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalPoint(x, y) {
    const pagePoint = Point.create(x, y);
    const graphPoint = pagePoint.diff(this.getPageOffset());
    return this.graphToLocalPoint(graphPoint);
  }
  graphToLocalRect(x, y, width2, height2) {
    const graphRect = Rectangle.create(x, y, width2, height2);
    return Util2.transformRectangle(graphRect, this.graph.matrix().inverse());
  }
  clientToLocalRect(x, y, width2, height2) {
    const clientRect = Rectangle.create(x, y, width2, height2);
    return Util2.transformRectangle(clientRect, this.getClientMatrix().inverse());
  }
  clientToGraphRect(x, y, width2, height2) {
    const clientRect = Rectangle.create(x, y, width2, height2);
    return Util2.transformRectangle(clientRect, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalRect(x, y, width2, height2) {
    const graphRect = Rectangle.create(x, y, width2, height2);
    const pageOffset = this.getPageOffset();
    graphRect.x -= pageOffset.x;
    graphRect.y -= pageOffset.y;
    return this.graphToLocalRect(graphRect);
  }
};

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/highlight.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HighlightManager = class extends Base2 {
  constructor() {
    super(...arguments);
    this.highlights = {};
  }
  init() {
    this.startListening();
  }
  startListening() {
    this.graph.on("cell:highlight", this.onCellHighlight, this);
    this.graph.on("cell:unhighlight", this.onCellUnhighlight, this);
  }
  stopListening() {
    this.graph.off("cell:highlight", this.onCellHighlight, this);
    this.graph.off("cell:unhighlight", this.onCellUnhighlight, this);
  }
  onCellHighlight({ view: cellView, magnet, options = {} }) {
    const resolved = this.resolveHighlighter(options);
    if (!resolved) {
      return;
    }
    const key = this.getHighlighterId(magnet, resolved);
    if (!this.highlights[key]) {
      const highlighter = resolved.highlighter;
      highlighter.highlight(cellView, magnet, Object.assign({}, resolved.args));
      this.highlights[key] = {
        cellView,
        magnet,
        highlighter,
        args: resolved.args
      };
    }
  }
  onCellUnhighlight({ magnet, options = {} }) {
    const resolved = this.resolveHighlighter(options);
    if (!resolved) {
      return;
    }
    const id = this.getHighlighterId(magnet, resolved);
    this.unhighlight(id);
  }
  resolveHighlighter(options) {
    const graphOptions = this.options;
    let highlighterDef = options.highlighter;
    if (highlighterDef == null) {
      const type = options.type;
      highlighterDef = type && graphOptions.highlighting[type] || graphOptions.highlighting.default;
    }
    if (highlighterDef == null) {
      return null;
    }
    const def = typeof highlighterDef === "string" ? {
      name: highlighterDef
    } : highlighterDef;
    const name = def.name;
    const highlighter = Highlighter.registry.get(name);
    if (highlighter == null) {
      return Highlighter.registry.onNotFound(name);
    }
    Highlighter.check(name, highlighter);
    return {
      name,
      highlighter,
      args: def.args || {}
    };
  }
  getHighlighterId(magnet, options) {
    main_exports3.ensureId(magnet);
    return options.name + magnet.id + JSON.stringify(options.args);
  }
  unhighlight(id) {
    const highlight2 = this.highlights[id];
    if (highlight2) {
      highlight2.highlighter.unhighlight(highlight2.cellView, highlight2.magnet, highlight2.args);
      delete this.highlights[id];
    }
  }
  dispose() {
    Object.keys(this.highlights).forEach((id) => this.unhighlight(id));
    this.stopListening();
  }
};
__decorate17([
  HighlightManager.dispose()
], HighlightManager.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/size.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SizeManager = class extends Base2 {
  getScroller() {
    const scroller = this.graph.getPlugin("scroller");
    if (scroller && scroller.options.enabled) {
      return scroller;
    }
    return null;
  }
  getContainer() {
    const scroller = this.getScroller();
    if (scroller) {
      return scroller.container.parentElement;
    }
    return this.graph.container.parentElement;
  }
  getSensorTarget() {
    const autoResize = this.options.autoResize;
    if (autoResize) {
      if (typeof autoResize === "boolean") {
        return this.getContainer();
      }
      return autoResize;
    }
  }
  init() {
    const autoResize = this.options.autoResize;
    if (autoResize) {
      const target = this.getSensorTarget();
      if (target) {
        SizeSensor.bind(target, () => {
          const width2 = target.offsetWidth;
          const height2 = target.offsetHeight;
          this.resize(width2, height2);
        });
      }
    }
  }
  resize(width2, height2) {
    const scroller = this.getScroller();
    if (scroller) {
      scroller.resize(width2, height2);
    } else {
      this.graph.transform.resize(width2, height2);
    }
  }
  dispose() {
    SizeSensor.clear(this.graph.container);
  }
};
__decorate18([
  Base2.dispose()
], SizeManager.prototype, "dispose", null);

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/graph/graph.js
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Graph = class _Graph extends Basecoat {
  get container() {
    return this.options.container;
  }
  get [Symbol.toStringTag]() {
    return _Graph.toStringTag;
  }
  constructor(options) {
    super();
    this.installedPlugins = /* @__PURE__ */ new Set();
    this.options = Options.get(options);
    this.css = new CSSManager(this);
    this.view = new GraphView(this);
    this.defs = new DefsManager(this);
    this.coord = new CoordManager(this);
    this.transform = new TransformManager(this);
    this.highlight = new HighlightManager(this);
    this.grid = new GridManager(this);
    this.background = new BackgroundManager(this);
    if (this.options.model) {
      this.model = this.options.model;
    } else {
      this.model = new Model();
      this.model.graph = this;
    }
    this.renderer = new Renderer(this);
    this.panning = new PanningManager(this);
    this.mousewheel = new MouseWheel(this);
    this.virtualRender = new VirtualRenderManager(this);
    this.size = new SizeManager(this);
  }
  // #region model
  isNode(cell) {
    return cell.isNode();
  }
  isEdge(cell) {
    return cell.isEdge();
  }
  resetCells(cells, options = {}) {
    this.model.resetCells(cells, options);
    return this;
  }
  clearCells(options = {}) {
    this.model.clear(options);
    return this;
  }
  toJSON(options = {}) {
    return this.model.toJSON(options);
  }
  parseJSON(data2) {
    return this.model.parseJSON(data2);
  }
  fromJSON(data2, options = {}) {
    this.model.fromJSON(data2, options);
    return this;
  }
  getCellById(id) {
    return this.model.getCell(id);
  }
  addNode(node, options = {}) {
    return this.model.addNode(node, options);
  }
  addNodes(nodes, options = {}) {
    return this.addCell(nodes.map((node) => Node2.isNode(node) ? node : this.createNode(node)), options);
  }
  createNode(metadata) {
    return this.model.createNode(metadata);
  }
  removeNode(node, options = {}) {
    return this.model.removeCell(node, options);
  }
  addEdge(edge, options = {}) {
    return this.model.addEdge(edge, options);
  }
  addEdges(edges, options = {}) {
    return this.addCell(edges.map((edge) => Edge.isEdge(edge) ? edge : this.createEdge(edge)), options);
  }
  removeEdge(edge, options = {}) {
    return this.model.removeCell(edge, options);
  }
  createEdge(metadata) {
    return this.model.createEdge(metadata);
  }
  addCell(cell, options = {}) {
    this.model.addCell(cell, options);
    return this;
  }
  removeCell(cell, options = {}) {
    return this.model.removeCell(cell, options);
  }
  removeCells(cells, options = {}) {
    return this.model.removeCells(cells, options);
  }
  removeConnectedEdges(cell, options = {}) {
    return this.model.removeConnectedEdges(cell, options);
  }
  disconnectConnectedEdges(cell, options = {}) {
    this.model.disconnectConnectedEdges(cell, options);
    return this;
  }
  hasCell(cell) {
    return this.model.has(cell);
  }
  getCells() {
    return this.model.getCells();
  }
  getCellCount() {
    return this.model.total();
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.model.getNodes();
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.model.getEdges();
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(cell) {
    return this.model.getOutgoingEdges(cell);
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(cell) {
    return this.model.getIncomingEdges(cell);
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(cell, options = {}) {
    return this.model.getConnectedEdges(cell, options);
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRootNodes() {
    return this.model.getRoots();
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafNodes() {
    return this.model.getLeafs();
  }
  /**
   * Returns `true` if the node is a root node, i.e.
   * there is no  edges coming to the node.
   */
  isRootNode(cell) {
    return this.model.isRoot(cell);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e.
   * there is no edges going out from the node.
   */
  isLeafNode(cell) {
    return this.model.isLeaf(cell);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(cell, options = {}) {
    return this.model.getNeighbors(cell, options);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(cell1, cell2, options = {}) {
    return this.model.isNeighbor(cell1, cell2, options);
  }
  getSuccessors(cell, options = {}) {
    return this.model.getSuccessors(cell, options);
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(cell1, cell2, options = {}) {
    return this.model.isSuccessor(cell1, cell2, options);
  }
  getPredecessors(cell, options = {}) {
    return this.model.getPredecessors(cell, options);
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(cell1, cell2, options = {}) {
    return this.model.isPredecessor(cell1, cell2, options);
  }
  getCommonAncestor(...cells) {
    return this.model.getCommonAncestor(...cells);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(cells, options = {}) {
    return this.model.getSubGraph(cells, options);
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(cells, options = {}) {
    return this.model.cloneSubGraph(cells, options);
  }
  cloneCells(cells) {
    return this.model.cloneCells(cells);
  }
  getNodesFromPoint(x, y) {
    return this.model.getNodesFromPoint(x, y);
  }
  getNodesInArea(x, y, w, h, options) {
    return this.model.getNodesInArea(x, y, w, h, options);
  }
  getNodesUnderNode(node, options = {}) {
    return this.model.getNodesUnderNode(node, options);
  }
  searchCell(cell, iterator, options = {}) {
    this.model.search(cell, iterator, options);
    return this;
  }
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(source, target, options = {}) {
    return this.model.getShortestPath(source, target, options);
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.model.getAllCellsBBox();
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(cells, options = {}) {
    return this.model.getCellsBBox(cells, options);
  }
  startBatch(name, data2 = {}) {
    this.model.startBatch(name, data2);
  }
  stopBatch(name, data2 = {}) {
    this.model.stopBatch(name, data2);
  }
  batchUpdate(arg1, arg2, arg3) {
    const name = typeof arg1 === "string" ? arg1 : "update";
    const execute = typeof arg1 === "string" ? arg2 : arg1;
    const data2 = typeof arg2 === "function" ? arg3 : arg2;
    this.startBatch(name, data2);
    const result2 = execute();
    this.stopBatch(name, data2);
    return result2;
  }
  updateCellId(cell, newId) {
    return this.model.updateCellId(cell, newId);
  }
  // #endregion
  // #region view
  findView(ref2) {
    if (Cell.isCell(ref2)) {
      return this.findViewByCell(ref2);
    }
    return this.findViewByElem(ref2);
  }
  findViews(ref2) {
    if (Rectangle.isRectangleLike(ref2)) {
      return this.findViewsInArea(ref2);
    }
    if (Point.isPointLike(ref2)) {
      return this.findViewsFromPoint(ref2);
    }
    return [];
  }
  findViewByCell(cell) {
    return this.renderer.findViewByCell(cell);
  }
  findViewByElem(elem) {
    return this.renderer.findViewByElem(elem);
  }
  findViewsFromPoint(x, y) {
    const p = typeof x === "number" ? { x, y } : x;
    return this.renderer.findViewsFromPoint(p);
  }
  findViewsInArea(x, y, width2, height2, options) {
    const rect2 = typeof x === "number" ? {
      x,
      y,
      width: width2,
      height: height2
    } : x;
    const localOptions = typeof x === "number" ? options : y;
    return this.renderer.findViewsInArea(rect2, localOptions);
  }
  matrix(mat) {
    if (typeof mat === "undefined") {
      return this.transform.getMatrix();
    }
    this.transform.setMatrix(mat);
    return this;
  }
  resize(width2, height2) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.resize(width2, height2);
    } else {
      this.transform.resize(width2, height2);
    }
    return this;
  }
  scale(sx, sy = sx, cx = 0, cy = 0) {
    if (typeof sx === "undefined") {
      return this.transform.getScale();
    }
    this.transform.scale(sx, sy, cx, cy);
    return this;
  }
  zoom(factor, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      if (typeof factor === "undefined") {
        return scroller.zoom();
      }
      scroller.zoom(factor, options);
    } else {
      if (typeof factor === "undefined") {
        return this.transform.getZoom();
      }
      this.transform.zoom(factor, options);
    }
    return this;
  }
  zoomTo(factor, options = {}) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.zoom(factor, Object.assign(Object.assign({}, options), { absolute: true }));
    } else {
      this.transform.zoom(factor, Object.assign(Object.assign({}, options), { absolute: true }));
    }
    return this;
  }
  zoomToRect(rect2, options = {}) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.zoomToRect(rect2, options);
    } else {
      this.transform.zoomToRect(rect2, options);
    }
    return this;
  }
  zoomToFit(options = {}) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.zoomToFit(options);
    } else {
      this.transform.zoomToFit(options);
    }
    return this;
  }
  rotate(angle, cx, cy) {
    if (typeof angle === "undefined") {
      return this.transform.getRotation();
    }
    this.transform.rotate(angle, cx, cy);
    return this;
  }
  translate(tx, ty) {
    if (typeof tx === "undefined") {
      return this.transform.getTranslation();
    }
    this.transform.translate(tx, ty);
    return this;
  }
  translateBy(dx, dy) {
    const ts = this.translate();
    const tx = ts.tx + dx;
    const ty = ts.ty + dy;
    return this.translate(tx, ty);
  }
  getGraphArea() {
    return this.transform.getGraphArea();
  }
  getContentArea(options = {}) {
    return this.transform.getContentArea(options);
  }
  getContentBBox(options = {}) {
    return this.transform.getContentBBox(options);
  }
  fitToContent(gridWidth, gridHeight, padding, options) {
    return this.transform.fitToContent(gridWidth, gridHeight, padding, options);
  }
  scaleContentToFit(options = {}) {
    this.transform.scaleContentToFit(options);
    return this;
  }
  /**
   * Position the center of graph to the center of the viewport.
   */
  center(options) {
    return this.centerPoint(options);
  }
  centerPoint(x, y, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.centerPoint(x, y, options);
    } else {
      this.transform.centerPoint(x, y);
    }
    return this;
  }
  centerContent(options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.centerContent(options);
    } else {
      this.transform.centerContent(options);
    }
    return this;
  }
  centerCell(cell, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.centerCell(cell, options);
    } else {
      this.transform.centerCell(cell);
    }
    return this;
  }
  positionPoint(point, x, y, options = {}) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.positionPoint(point, x, y, options);
    } else {
      this.transform.positionPoint(point, x, y);
    }
    return this;
  }
  positionRect(rect2, direction, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.positionRect(rect2, direction, options);
    } else {
      this.transform.positionRect(rect2, direction);
    }
    return this;
  }
  positionCell(cell, direction, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.positionCell(cell, direction, options);
    } else {
      this.transform.positionCell(cell, direction);
    }
    return this;
  }
  positionContent(pos, options) {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.positionContent(pos, options);
    } else {
      this.transform.positionContent(pos, options);
    }
    return this;
  }
  snapToGrid(x, y) {
    return this.coord.snapToGrid(x, y);
  }
  pageToLocal(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.pageToLocalRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.pageToLocalRect(x, y, width2, height2);
    }
    return this.coord.pageToLocalPoint(x, y);
  }
  localToPage(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.localToPageRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.localToPageRect(x, y, width2, height2);
    }
    return this.coord.localToPagePoint(x, y);
  }
  clientToLocal(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.clientToLocalRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.clientToLocalRect(x, y, width2, height2);
    }
    return this.coord.clientToLocalPoint(x, y);
  }
  localToClient(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.localToClientRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.localToClientRect(x, y, width2, height2);
    }
    return this.coord.localToClientPoint(x, y);
  }
  localToGraph(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.localToGraphRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.localToGraphRect(x, y, width2, height2);
    }
    return this.coord.localToGraphPoint(x, y);
  }
  graphToLocal(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.graphToLocalRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.graphToLocalRect(x, y, width2, height2);
    }
    return this.coord.graphToLocalPoint(x, y);
  }
  clientToGraph(x, y, width2, height2) {
    if (Rectangle.isRectangleLike(x)) {
      return this.coord.clientToGraphRect(x);
    }
    if (typeof x === "number" && typeof y === "number" && typeof width2 === "number" && typeof height2 === "number") {
      return this.coord.clientToGraphRect(x, y, width2, height2);
    }
    return this.coord.clientToGraphPoint(x, y);
  }
  // #endregion
  // #region defs
  defineFilter(options) {
    return this.defs.filter(options);
  }
  defineGradient(options) {
    return this.defs.gradient(options);
  }
  defineMarker(options) {
    return this.defs.marker(options);
  }
  // #endregion
  // #region grid
  getGridSize() {
    return this.grid.getGridSize();
  }
  setGridSize(gridSize) {
    this.grid.setGridSize(gridSize);
    return this;
  }
  showGrid() {
    this.grid.show();
    return this;
  }
  hideGrid() {
    this.grid.hide();
    return this;
  }
  clearGrid() {
    this.grid.clear();
    return this;
  }
  drawGrid(options) {
    this.grid.draw(options);
    return this;
  }
  // #endregion
  // #region background
  updateBackground() {
    this.background.update();
    return this;
  }
  drawBackground(options, onGraph) {
    const scroller = this.getPlugin("scroller");
    if (scroller != null && (this.options.background == null || !onGraph)) {
      scroller.drawBackground(options, onGraph);
    } else {
      this.background.draw(options);
    }
    return this;
  }
  clearBackground(onGraph) {
    const scroller = this.getPlugin("scroller");
    if (scroller != null && (this.options.background == null || !onGraph)) {
      scroller.clearBackground(onGraph);
    } else {
      this.background.clear();
    }
    return this;
  }
  // #endregion
  // #region virtual-render
  enableVirtualRender() {
    this.virtualRender.enableVirtualRender();
    return this;
  }
  disableVirtualRender() {
    this.virtualRender.disableVirtualRender();
    return this;
  }
  // #endregion
  // #region mousewheel
  isMouseWheelEnabled() {
    return !this.mousewheel.disabled;
  }
  enableMouseWheel() {
    this.mousewheel.enable();
    return this;
  }
  disableMouseWheel() {
    this.mousewheel.disable();
    return this;
  }
  toggleMouseWheel(enabled) {
    if (enabled == null) {
      if (this.isMouseWheelEnabled()) {
        this.disableMouseWheel();
      } else {
        this.enableMouseWheel();
      }
    } else if (enabled) {
      this.enableMouseWheel();
    } else {
      this.disableMouseWheel();
    }
    return this;
  }
  // #endregion
  // #region panning
  isPannable() {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      return scroller.isPannable();
    }
    return this.panning.pannable;
  }
  enablePanning() {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.enablePanning();
    } else {
      this.panning.enablePanning();
    }
    return this;
  }
  disablePanning() {
    const scroller = this.getPlugin("scroller");
    if (scroller) {
      scroller.disablePanning();
    } else {
      this.panning.disablePanning();
    }
    return this;
  }
  togglePanning(pannable) {
    if (pannable == null) {
      if (this.isPannable()) {
        this.disablePanning();
      } else {
        this.enablePanning();
      }
    } else if (pannable !== this.isPannable()) {
      if (pannable) {
        this.enablePanning();
      } else {
        this.disablePanning();
      }
    }
    return this;
  }
  // #endregion
  // #region plugin
  use(plugin, ...options) {
    if (!this.installedPlugins.has(plugin)) {
      this.installedPlugins.add(plugin);
      plugin.init(this, ...options);
    }
    return this;
  }
  getPlugin(pluginName) {
    return Array.from(this.installedPlugins).find((plugin) => plugin.name === pluginName);
  }
  getPlugins(pluginName) {
    return Array.from(this.installedPlugins).filter((plugin) => pluginName.includes(plugin.name));
  }
  enablePlugins(plugins) {
    let postPlugins = plugins;
    if (!Array.isArray(postPlugins)) {
      postPlugins = [postPlugins];
    }
    const aboutToChangePlugins = this.getPlugins(postPlugins);
    aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
      var _a;
      (_a = plugin === null || plugin === void 0 ? void 0 : plugin.enable) === null || _a === void 0 ? void 0 : _a.call(plugin);
    });
    return this;
  }
  disablePlugins(plugins) {
    let postPlugins = plugins;
    if (!Array.isArray(postPlugins)) {
      postPlugins = [postPlugins];
    }
    const aboutToChangePlugins = this.getPlugins(postPlugins);
    aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
      var _a;
      (_a = plugin === null || plugin === void 0 ? void 0 : plugin.disable) === null || _a === void 0 ? void 0 : _a.call(plugin);
    });
    return this;
  }
  isPluginEnabled(pluginName) {
    var _a;
    const pluginIns = this.getPlugin(pluginName);
    return (_a = pluginIns === null || pluginIns === void 0 ? void 0 : pluginIns.isEnabled) === null || _a === void 0 ? void 0 : _a.call(pluginIns);
  }
  disposePlugins(plugins) {
    let postPlugins = plugins;
    if (!Array.isArray(postPlugins)) {
      postPlugins = [postPlugins];
    }
    const aboutToChangePlugins = this.getPlugins(postPlugins);
    aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
      plugin.dispose();
      this.installedPlugins.delete(plugin);
    });
    return this;
  }
  // #endregion
  // #region dispose
  dispose(clean2 = true) {
    if (clean2) {
      this.model.dispose();
    }
    this.css.dispose();
    this.defs.dispose();
    this.grid.dispose();
    this.coord.dispose();
    this.transform.dispose();
    this.highlight.dispose();
    this.background.dispose();
    this.mousewheel.dispose();
    this.panning.dispose();
    this.view.dispose();
    this.renderer.dispose();
    this.installedPlugins.forEach((plugin) => {
      plugin.dispose();
    });
  }
};
__decorate19([
  Basecoat.dispose()
], Graph.prototype, "dispose", null);
(function(Graph2) {
  Graph2.View = GraphView;
  Graph2.Renderer = Renderer;
  Graph2.MouseWheel = MouseWheel;
  Graph2.DefsManager = DefsManager;
  Graph2.GridManager = GridManager;
  Graph2.CoordManager = CoordManager;
  Graph2.TransformManager = TransformManager;
  Graph2.HighlightManager = HighlightManager;
  Graph2.BackgroundManager = BackgroundManager;
  Graph2.PanningManager = PanningManager;
})(Graph || (Graph = {}));
(function(Graph2) {
  Graph2.toStringTag = `X6.${Graph2.name}`;
  function isGraph(instance) {
    if (instance == null) {
      return false;
    }
    if (instance instanceof Graph2) {
      return true;
    }
    const tag = instance[Symbol.toStringTag];
    if (tag == null || tag === Graph2.toStringTag) {
      return true;
    }
    return false;
  }
  Graph2.isGraph = isGraph;
})(Graph || (Graph = {}));
(function(Graph2) {
  function render(options, data2) {
    const graph = options instanceof HTMLElement ? new Graph2({ container: options }) : new Graph2(options);
    if (data2 != null) {
      graph.fromJSON(data2);
    }
    return graph;
  }
  Graph2.render = render;
})(Graph || (Graph = {}));
(function(Graph2) {
  Graph2.registerNode = Node2.registry.register;
  Graph2.registerEdge = Edge.registry.register;
  Graph2.registerView = CellView.registry.register;
  Graph2.registerAttr = Attr.registry.register;
  Graph2.registerGrid = Grid.registry.register;
  Graph2.registerFilter = Filter.registry.register;
  Graph2.registerNodeTool = NodeTool.registry.register;
  Graph2.registerEdgeTool = EdgeTool.registry.register;
  Graph2.registerBackground = Background.registry.register;
  Graph2.registerHighlighter = Highlighter.registry.register;
  Graph2.registerPortLayout = PortLayout.registry.register;
  Graph2.registerPortLabelLayout = PortLabelLayout.registry.register;
  Graph2.registerMarker = Marker.registry.register;
  Graph2.registerRouter = Router.registry.register;
  Graph2.registerConnector = Connector.registry.register;
  Graph2.registerAnchor = NodeAnchor.registry.register;
  Graph2.registerEdgeAnchor = EdgeAnchor.registry.register;
  Graph2.registerConnectionPoint = ConnectionPoint.registry.register;
})(Graph || (Graph = {}));
(function(Graph2) {
  Graph2.unregisterNode = Node2.registry.unregister;
  Graph2.unregisterEdge = Edge.registry.unregister;
  Graph2.unregisterView = CellView.registry.unregister;
  Graph2.unregisterAttr = Attr.registry.unregister;
  Graph2.unregisterGrid = Grid.registry.unregister;
  Graph2.unregisterFilter = Filter.registry.unregister;
  Graph2.unregisterNodeTool = NodeTool.registry.unregister;
  Graph2.unregisterEdgeTool = EdgeTool.registry.unregister;
  Graph2.unregisterBackground = Background.registry.unregister;
  Graph2.unregisterHighlighter = Highlighter.registry.unregister;
  Graph2.unregisterPortLayout = PortLayout.registry.unregister;
  Graph2.unregisterPortLabelLayout = PortLabelLayout.registry.unregister;
  Graph2.unregisterMarker = Marker.registry.unregister;
  Graph2.unregisterRouter = Router.registry.unregister;
  Graph2.unregisterConnector = Connector.registry.unregister;
  Graph2.unregisterAnchor = NodeAnchor.registry.unregister;
  Graph2.unregisterEdgeAnchor = EdgeAnchor.registry.unregister;
  Graph2.unregisterConnectionPoint = ConnectionPoint.registry.unregister;
})(Graph || (Graph = {}));

// ../node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/es/shape/html.js
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest27 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var HTML = class extends Node2 {
};
(function(HTML2) {
  class View2 extends NodeView {
    init() {
      super.init();
      this.cell.on("change:*", this.onCellChangeAny, this);
    }
    onCellChangeAny({ key }) {
      const content2 = HTML2.shapeMaps[this.cell.shape];
      if (content2) {
        const { effect } = content2;
        if (!effect || effect.includes(key)) {
          this.renderHTMLComponent();
        }
      }
    }
    confirmUpdate(flag) {
      const ret = super.confirmUpdate(flag);
      return this.handleAction(ret, View2.action, () => this.renderHTMLComponent());
    }
    renderHTMLComponent() {
      const container = this.selectors && this.selectors.foContent;
      if (container) {
        main_exports3.empty(container);
        const content2 = HTML2.shapeMaps[this.cell.shape];
        if (!content2) {
          return;
        }
        let { html: html2 } = content2;
        if (typeof html2 === "function") {
          html2 = html2(this.cell);
        }
        if (html2) {
          if (typeof html2 === "string") {
            container.innerHTML = html2;
          } else {
            main_exports3.append(container, html2);
          }
        }
      }
    }
    dispose() {
      this.cell.off("change:*", this.onCellChangeAny, this);
    }
  }
  __decorate20([
    View2.dispose()
  ], View2.prototype, "dispose", null);
  HTML2.View = View2;
  (function(View3) {
    View3.action = "html";
    View3.config({
      bootstrap: [View3.action],
      actions: {
        html: View3.action
      }
    });
    NodeView.registry.register("html-view", View3, true);
  })(View2 = HTML2.View || (HTML2.View = {}));
})(HTML || (HTML = {}));
(function(HTML2) {
  HTML2.config({
    view: "html-view",
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      Object.assign({}, Markup.getForeignObjectMarkup()),
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      body: {
        fill: "none",
        stroke: "none",
        refWidth: "100%",
        refHeight: "100%"
      },
      fo: {
        refWidth: "100%",
        refHeight: "100%"
      }
    }
  });
  Node2.registry.register("html", HTML2, true);
})(HTML || (HTML = {}));
(function(HTML2) {
  HTML2.shapeMaps = {};
  function register(config) {
    const { shape, html: html2, effect, inherit: inherit2 } = config, others = __rest27(config, ["shape", "html", "effect", "inherit"]);
    if (!shape) {
      throw new Error("should specify shape in config");
    }
    HTML2.shapeMaps[shape] = {
      html: html2,
      effect
    };
    Graph.registerNode(shape, Object.assign({ inherit: inherit2 || "html" }, others), true);
  }
  HTML2.register = register;
})(HTML || (HTML = {}));
export {
  Angle,
  array_exports as ArrayExt,
  BackgroundManager,
  Basecoat,
  Cell,
  CellView,
  Collection,
  Color,
  Config,
  loader_exports as CssLoader,
  Curve,
  DataUri,
  Dictionary,
  Dijkstra,
  Disablable,
  Disposable,
  DisposableDelegate,
  DisposableSet,
  main_exports3 as Dom,
  Edge,
  EdgeView,
  Ellipse,
  Events,
  main_exports as FunctionExt,
  GeometryUtil,
  Graph,
  GraphView,
  Interp,
  Line,
  Markup,
  Model,
  ModifierKey,
  Node2 as Node,
  NodeView,
  number_exports as NumberExt,
  object_exports as ObjectExt,
  Options,
  Path,
  Platform,
  Point,
  Polyline,
  PriorityQueue,
  Rectangle,
  registry_exports as Registry,
  Segment,
  shape_exports as Shape,
  SizeSensor,
  string_exports as StringExt,
  main_exports2 as Text,
  Timing,
  ToolsView,
  TransformManager,
  Unit,
  Util2 as Util,
  Vector,
  View,
  normalizePathData
};
/*! Bundled license information:

lodash-es/lodash.default.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=@antv_x6.js.map
